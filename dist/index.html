<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>RetailEdge Pro | AI Stock Screener & Portfolio Tracker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Tier 3 Libraries: ML & PDF Export -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- PWA Manifest -->
  <link rel="manifest" href="#manifest-placeholder">
  <script type="application/json" id="manifest-placeholder">
  {
    "name": "RetailEdge Pro",
    "short_name": "RetailEdge",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#020617",
    "theme_color": "#06b6d4",
    "icons": [
      { "src": "icon-192.png", "sizes": "192x192", "type": "image/png" },
      { "src": "icon-512.png", "sizes": "512x512", "type": "image/png" }
    ]
  }
  </script>

  <style>
    /* Theme Variables */
    :root {
      --bg-main: linear-gradient(135deg, #020617 0%, #0f172a 50%, #020617 100%);
      --bg-solid: #0f172a;
      --card-bg: rgba(30, 41, 59, 0.7);
      --card-border: rgba(100, 116, 139, 0.15);
      --text-main: #e2e8f0;
      --text-secondary: #94a3b8;
      --accent-primary: #06b6d4;
      --accent-secondary: #8b5cf6;
    }

    .light-mode {
      --bg-main: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 50%, #f1f5f9 100%);
      --bg-solid: #f8fafc;
      --card-bg: rgba(255, 255, 255, 0.9);
      --card-border: rgba(148, 163, 184, 0.25);
      --text-main: #1e293b;
      --text-secondary: #64748b;
      --accent-primary: #0891b2;
      --accent-secondary: #7c3aed;
    }

    /* Skeleton Loading Animation */
    @keyframes shimmer {
      0% {
        background-position: -1000px 0;
      }

      100% {
        background-position: 1000px 0;
      }
    }

    .skeleton {
      background: linear-gradient(90deg, #1e293b 25%, #334155 50%, #1e293b 75%);
      background-size: 1000px 100%;
      animation: shimmer 2s infinite linear;
      border-radius: 8px;
    }

    .light-mode .skeleton {
      background: linear-gradient(90deg, #e2e8f0 25%, #cbd5e1 50%, #e2e8f0 75%);
      background-size: 1000px 100%;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: var(--bg-main);
      min-height: 100vh;
      font-family: 'Inter', sans-serif;
      color: #e2e8f0;
    }

    .font-mono {
      font-family: 'JetBrains Mono', monospace;
    }

    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: #0f172a;
    }

    ::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }

    /* Glassmorphism */
    .glass {
      background: rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(100, 116, 139, 0.2);
    }

    .glass-card {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.7) 0%, rgba(15, 23, 42, 0.9) 100%);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 116, 139, 0.15);
      transition: all 0.3s ease;
    }

    .glass-card:hover {
      border-color: rgba(6, 182, 212, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(6, 182, 212, 0.1);
    }

    .glass-elevated {
      background: rgba(30, 41, 59, 0.85);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(100, 116, 139, 0.25);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
    }

    /* Animations */
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    @keyframes glow {

      0%,
      100% {
        box-shadow: 0 0 5px rgba(6, 182, 212, 0.3);
      }

      50% {
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.6);
      }
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Loading States */
    .data-loading {
      opacity: 0.7;
      pointer-events: none;
    }

    .data-loaded {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0.5;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideInLeft {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .animate-slide-up {
      animation: slideUp 0.4s ease-out;
    }

    .animate-fade-in {
      animation: fadeIn 0.3s ease;
    }

    .animate-pulse {
      animation: pulse 2s infinite;
    }

    .animate-glow {
      animation: glow 2s ease-in-out infinite;
    }

    .animate-spin {
      animation: spin 1s linear infinite;
    }

    .animate-slideInLeft {
      animation: slideInLeft 0.3s ease-out;
    }

    /* Table */
    .table-row {
      transition: all 0.15s ease;
      border-left: 3px solid transparent;
    }

    .table-row:hover {
      background: rgba(6, 182, 212, 0.06);
      cursor: pointer;
      border-left-color: rgba(6, 182, 212, 0.3);
    }

    .table-row.selected {
      background: rgba(6, 182, 212, 0.1);
      border-left-color: #06b6d4;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(8px);
      z-index: 1000;
      overflow-y: auto;
    }

    /* Tabs */
    .tab-btn {
      padding: 12px 20px;
      font-size: 13px;
      font-weight: 600;
      border-bottom: 2px solid transparent;
      color: #64748b;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      background: rgba(255, 255, 255, 0.03);
      color: #94a3b8;
    }

    .tab-btn.active {
      border-color: #06b6d4;
      color: #06b6d4;
    }

    /* ===== FIXED: Add underline-on-hover for fundamentals tab ===== */
    .fundamentals-tab {
      position: relative;
    }

    .fundamentals-tab:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .fundamentals-tab.active {
      border-color: #06b6d4;
      color: #06b6d4;
    }

    .fundamentals-content {
      display: none;
    }

    .fundamentals-content.active {
      display: block;
    }

    /* Chips & Badges */
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 9999px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.025em;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: 700;
    }

    /* Sparkline */
    .sparkline {
      display: flex;
      align-items: flex-end;
      gap: 1px;
      height: 28px;
    }

    .sparkline-bar {
      width: 3px;
      border-radius: 1px;
      transition: height 0.3s;
    }

    /* Health & Progress Bars */
    .health-bar {
      height: 6px;
      border-radius: 3px;
      background: #1e293b;
      overflow: hidden;
    }

    .health-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.5s ease;
    }

    /* Range Inputs */
    input[type=range] {
      -webkit-appearance: none;
      background: transparent;
      width: 100%;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 16px;
      width: 16px;
      border-radius: 50%;
      background: #06b6d4;
      cursor: pointer;
      margin-top: -6px;
      box-shadow: 0 2px 6px rgba(6, 182, 212, 0.4);
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background: #334155;
      border-radius: 2px;
    }

    /* Theme Pills */
    .theme-pill {
      padding: 8px 16px;
      border-radius: 24px;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
      cursor: pointer;
      border: 1px solid transparent;
    }

    .theme-pill:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(100, 116, 139, 0.3);
    }

    .theme-pill.active {
      background: linear-gradient(135deg, rgba(6, 182, 212, 0.2), rgba(139, 92, 246, 0.2));
      border-color: rgba(6, 182, 212, 0.4);
      color: #06b6d4;
    }

    /* Tooltips */
    .tooltip {
      position: relative;
    }

    .tooltip-content {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-8px);
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 12px 16px;
      width: 280px;
      font-size: 12px;
      line-height: 1.6;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
      z-index: 100;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .tooltip:hover .tooltip-content {
      opacity: 1;
      visibility: visible;
    }

    /* Verdict Styles */
    .verdict-bullish {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(34, 197, 94, 0.02) 100%);
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .verdict-bearish {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.02) 100%);
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .verdict-neutral {
      background: linear-gradient(135deg, rgba(234, 179, 8, 0.1) 0%, rgba(234, 179, 8, 0.02) 100%);
      border: 1px solid rgba(234, 179, 8, 0.3);
    }

    /* Live Indicator */
    .live-dot {
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
      animation: glow 2s ease-in-out infinite;
    }

    .live-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 12px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      font-size: 10px;
      font-weight: 600;
      color: #22c55e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .live-indicator.offline {
      background: rgba(148, 163, 184, 0.1);
      border-color: rgba(148, 163, 184, 0.3);
      color: #94a3b8;
    }

    .live-indicator.offline .live-dot {
      background: #94a3b8;
      animation: none;
    }

    /* Tournament Status Indicator */
    .tournament-status-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    }

    /* Preset Screen Cards */
    .preset-card {
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 10px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-card:hover {
      border-color: #06b6d4;
      background: rgba(6, 182, 212, 0.05);
    }

    .preset-card.active {
      border-color: #06b6d4;
      background: rgba(6, 182, 212, 0.1);
    }

    /* Column Selector */
    .column-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .column-toggle:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .column-toggle.active {
      background: rgba(6, 182, 212, 0.15);
    }

    /* P&L Colors */
    .pnl-positive {
      color: #22c55e;
    }

    .pnl-negative {
      color: #ef4444;
    }

    .pnl-neutral {
      color: #94a3b8;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MOBILE RESPONSIVE STYLES - PHASE 1 ENHANCED
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    @media (max-width: 768px) {

      /* Hide desktop table, show mobile cards */
      .stock-table-container {
        display: none;
      }

      .mobile-stock-cards {
        display: block !important;
      }

      /* Stock cards for mobile */
      .stock-card {
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid rgba(100, 116, 139, 0.2);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .stock-card:hover {
        background: rgba(30, 41, 59, 0.95);
        border-color: rgba(6, 182, 212, 0.5);
        transform: translateY(-2px);
      }

      .stock-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(100, 116, 139, 0.2);
      }

      .stock-card-symbol {
        font-size: 20px;
        font-weight: 700;
        color: #06b6d4;
      }

      .stock-card-price {
        font-size: 18px;
        font-weight: 700;
        color: #fff;
      }

      .stock-card-change {
        font-size: 14px;
        font-weight: 600;
      }

      .stock-card-metrics {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-top: 12px;
      }

      .stock-card-metric {
        font-size: 12px;
      }

      .stock-card-metric-label {
        color: #94a3b8;
        font-size: 11px;
        margin-bottom: 4px;
      }

      .stock-card-metric-value {
        color: #fff;
        font-weight: 600;
        font-size: 14px;
      }

      .stock-card-verdict {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid rgba(100, 116, 139, 0.2);
        text-align: center;
      }

      /* Larger tap targets */
      button,
      .tab-btn,
      a.button {
        min-height: 44px;
        padding: 12px 16px;
        font-size: 14px;
      }

      /* Full screen modals on mobile */
      .modal-overlay {
        padding: 0;
      }

      .modal-content {
        width: 100vw;
        height: 100vh;
        max-height: 100vh;
        max-width: 100vw;
        border-radius: 0;
        margin: 0;
      }

      .modal-header {
        position: sticky;
        top: 0;
        z-index: 10;
        background: rgba(15, 23, 42, 0.98);
        backdrop-filter: blur(20px);
      }

      .modal-body {
        padding: 16px;
        padding-bottom: 80px;
        /* Space for bottom nav */
      }

      /* Bottom navigation for mobile */
      .mobile-bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(15, 23, 42, 0.98);
        backdrop-filter: blur(20px);
        border-top: 1px solid rgba(100, 116, 139, 0.2);
        padding: 8px;
        display: flex;
        justify-content: space-around;
        z-index: 1000;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
      }

      .mobile-nav-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 11px;
        color: #94a3b8;
        background: transparent;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
      }

      .mobile-nav-btn.active {
        background: rgba(6, 182, 212, 0.15);
        color: #06b6d4;
      }

      .mobile-nav-icon {
        font-size: 20px;
      }

      /* Export buttons stack on mobile */
      .export-buttons {
        flex-direction: column;
        gap: 8px;
      }

      .export-buttons button {
        width: 100%;
      }

      /* Filters take full width */
      .filters-container {
        flex-direction: column;
      }

      .filter-group {
        width: 100%;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       GOAL PLANNER SPECIFIC STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .glass-goal-card {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.7) 0%, rgba(15, 23, 42, 0.9) 100%);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 116, 139, 0.15);
      border-radius: 16px;
      transition: all 0.3s ease;
    }

    .glass-goal-card:hover {
      border-color: rgba(6, 182, 212, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(6, 182, 212, 0.1);
    }

    .goal-progress-ring {
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }

    .goal-milestone {
      position: relative;
    }

    .goal-milestone::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 100%;
      width: 1px;
      height: 20px;
      background: linear-gradient(to bottom, rgba(6, 182, 212, 0.5), transparent);
    }

    .goal-input-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .goal-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 16px;
    }

    .goal-action-buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* Animation for goal completion */
    @keyframes goalComplete {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    .goal-complete-animation {
      animation: goalComplete 0.5s ease-in-out;
    }

    /* Tooltip styles for goal explanations */
    .goal-tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }

    .goal-tooltip .tooltip-content {
      visibility: hidden;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 12px;
      width: 300px;
      font-size: 12px;
      line-height: 1.5;
      z-index: 100;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .goal-tooltip:hover .tooltip-content {
      visibility: visible;
    }

    /* Print styles for goal PDF export */
    @media print {
      .goal-planner-print {
        background: white !important;
        color: black !important;
      }

      .goal-planner-print .glass-card {
        background: #f8fafc !important;
        border: 1px solid #e2e8f0 !important;
        color: #1e293b !important;
      }

      .no-print {
        display: none !important;
      }
    }

    @media (min-width: 769px) {
      .mobile-stock-cards {
        display: none;
      }

      .mobile-bottom-nav {
        display: none;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       AI TOURNAMENT STATUS INDICATOR
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .tournament-live-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      animation: pulse 2s infinite;
    }

    .tournament-live-indicator .live-dot {
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
      animation: glow 2s ease-in-out infinite;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <!-- Firebase Authentication (Optional) -->
  <script type="module">
    // Firebase config - replace with your own or leave as demo mode
    try {
      const { initializeApp } = await import("https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js");
      const { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } = await import("https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js");
      const { getFirestore, doc, setDoc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js");

      const firebaseConfig = {
        apiKey: "DEMO_MODE",
        authDomain: "demo.firebaseapp.com",
        projectId: "demo-project"
      };

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const provider = new GoogleAuthProvider();

      window.firebaseUtils = { auth, db, provider, signInWithPopup, onAuthStateChanged, doc, setDoc, getDoc };
      console.log('âœ… Firebase initialized (demo mode)');
    } catch (error) {
      console.log('â„¹ï¸ Firebase not configured - running in guest mode');
      window.firebaseUtils = null;
    }
  </script>
  <script src="./config.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">

    // CRITICAL: Ensure API_BASE_URL is always defined
    if (!window.API_BASE_URL) {
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      window.API_BASE_URL = isLocalhost
        ? 'http://localhost:3002'
        : 'https://retailedge-trading-tournament-1.onrender.com';
      console.warn('âš ï¸ API_BASE_URL was undefined, set to:', window.API_BASE_URL);
    }

    // FMP API Configuration - Use proxy server for all API calls
    window.FMP_API_KEY = ''; // Not needed in frontend - proxy server handles authentication
    window.USE_DEMO_DATA = false; // DISABLE demo mode - fetch real data from FMP

    // Default stock symbols to load on app start
    window.DEFAULT_STOCK_SYMBOLS = [
      'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'META', 'BRK.B', 'UNH', 'JPM',
      'V', 'PG', 'MA', 'HD', 'CVX', 'LLY', 'ABBV', 'MRK', 'AVGO', 'COST',
      'PEP', 'KO', 'ADBE', 'TMO', 'WMT', 'MCD', 'CSCO', 'ACN', 'ABT', 'CRM',
      'NFLX', 'DIS', 'INTC', 'AMD', 'QCOM', 'ORCL', 'IBM', 'PYPL', 'SBUX', 'NKE'
    ];

    console.log('âœ… API Configuration loaded');
    console.log('   API Base URL:', window.API_BASE_URL);
    console.log('   Demo Mode:', window.USE_DEMO_DATA ? 'ENABLED' : 'DISABLED');
    console.log('   Default Stocks:', window.DEFAULT_STOCK_SYMBOLS.length, 'symbols');

    // Fix: Add missing checkAndUnlockBadges function
    function checkAndUnlockBadges(portfolio, watchlist, goals, options) {
      // Placeholder: No badges unlocked
      return [];
    }

    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLOUD STORE HOOK - Real-time Firebase sync with localStorage fallback
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function useCloudStore(key, defaultValue) {
      const [data, setData] = useState(() => {
        // Try localStorage first
        try {
          const stored = localStorage.getItem(`re_${key}`);
          return stored ? JSON.parse(stored) : defaultValue;
        } catch {
          return defaultValue;
        }
      });

      // Listen to Firebase if authenticated
      useEffect(() => {
        if (!window.firebaseUtils?.db) return;

        const { db, doc, onSnapshot } = window.firebaseUtils;
        const user = window.firebaseUtils.auth?.currentUser;
        if (!user) return;

        try {
          const docRef = doc(db, 'users', user.uid, 'app', key);
          const unsubscribe = onSnapshot(docRef, (snapshot) => {
            if (snapshot.exists()) {
              const cloudData = snapshot.data()?.value;
              if (cloudData !== undefined) {
                setData(cloudData);
                localStorage.setItem(`re_${key}`, JSON.stringify(cloudData));
              }
            }
          });
          return unsubscribe;
        } catch (error) {
          console.warn('Cloud sync unavailable:', error);
        }
      }, [key]);

      const save = useCallback(async (value) => {
        setData(value);

        // Save to localStorage
        try {
          localStorage.setItem(`re_${key}`, JSON.stringify(value));
        } catch (error) {
          console.warn('Failed to save to localStorage:', error);
        }

        // Save to Firebase if available
        if (window.firebaseUtils?.db) {
          const user = window.firebaseUtils.auth?.currentUser;
          if (user) {
            try {
              const { db, doc, setDoc } = window.firebaseUtils;
              await setDoc(doc(db, 'users', user.uid, 'app', key), {
                value,
                updatedAt: new Date().toISOString()
              });
              console.log(`â˜ï¸ Synced ${key} to cloud`);
            } catch (error) {
              console.warn('Failed to sync to cloud:', error);
            }
          }
        }
      }, [key]);

      return [data, save];
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PREMIUM TIER HOOK - Check user subscription status
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function usePremium() {
      const [tier, setTier] = useState('free');

      useEffect(() => {
        // Check UserManager for subscription tier
        if (typeof UserManager !== 'undefined' && UserManager.getCurrentUser) {
          const user = UserManager.getCurrentUser();
          const subscription = user?.subscription || 'free';
          setTier(subscription);
        }

        // Also check SubscriptionManager if available
        if (typeof SubscriptionManager !== 'undefined' && SubscriptionManager.getCurrentTier) {
          const currentTier = SubscriptionManager.getCurrentTier();
          setTier(currentTier);
        }
      }, []);

      return {
        isPremium: tier === 'premium' || tier === 'pro',
        isPro: tier === 'pro',
        tier
      };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INSTANT STOCK DATA HOOK - Loads from cache instantly, refreshes in background
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function useInstantStockData(symbol, type = 'stock') {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // OPTIMIZED: Single cache lookup instead of 4 redundant calls!
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const initialCacheData = useMemo(() => {
        const cached = Cache.get(symbol, type);
        return {
          data: cached || null,
          hasData: !!cached,
          timestamp: Cache.getTimestamp ? Cache.getTimestamp(symbol, type) : null,
          isExpired: Cache.isExpired ? Cache.isExpired(symbol, type) : false
        };
      }, [symbol, type]);

      const [data, setData] = useState(initialCacheData.data);
      const [loading, setLoading] = useState(!initialCacheData.hasData);
      const [lastUpdated, setLastUpdated] = useState(initialCacheData.timestamp);
      const [isStale, setIsStale] = useState(initialCacheData.isExpired);

      useEffect(() => {
        if (!symbol) return;

        let isMounted = true;
        let refreshInterval = null;

        // Priority 1: Load from IndexedDB if not in localStorage
        const loadFromIndexedDB = async () => {
          try {
            const advancedData = await AdvancedStorage.get('stockData', `${symbol}_${type}`);
            if (advancedData && isMounted && !data) {
              setData(advancedData);
              setLoading(false);
              // Update localStorage cache too for consistency
              Cache.set(symbol, advancedData, type);
            }
          } catch (error) {
            console.warn('IndexedDB load failed:', error);
          }
        };

        // Priority 2: Silently refresh in background if cache is stale
        const backgroundRefresh = async () => {
          const needsRefresh = Cache.isExpired ? Cache.isExpired(symbol, type) : true;
          if (!needsRefresh) return;

          try {
            console.log(`ğŸ”„ Background refresh for ${symbol}...`);
            const endpoint = type === 'quote' ? 'quote' : 'profile';
            const response = await fetch(`https://financialmodelingprep.com/stable/${endpoint}/${symbol}?apikey=${API_KEYS.FMP}`);

            if (response.ok) {
              const result = await response.json();
              const newData = Array.isArray(result) ? result[0] : result;

              if (newData && isMounted) {
                // Update cache
                Cache.set(symbol, newData, type);

                // Only update state if data actually changed
                if (JSON.stringify(newData) !== JSON.stringify(data)) {
                  setData(newData);
                  setLastUpdated(Date.now());
                  setIsStale(false);
                }
              }
            }
          } catch (error) {
            console.warn('Background refresh failed:', error);
            // Don't throw - cached data is still valid
          }
        };

        // Execute loading strategy
        const loadData = async () => {
          if (!data) {
            await loadFromIndexedDB();
          }

          // Always check for background refresh
          await backgroundRefresh();

          if (isMounted) setLoading(false);
        };

        loadData();

        // Set up interval for periodic background updates
        if (CACHE_CONFIG.BACKGROUND_REFRESH_INTERVAL) {
          refreshInterval = setInterval(backgroundRefresh, CACHE_CONFIG.BACKGROUND_REFRESH_INTERVAL);
        }

        return () => {
          isMounted = false;
          if (refreshInterval) clearInterval(refreshInterval);
        };
      }, [symbol, type]);

      return {
        data,
        loading,
        lastUpdated,
        isStale,
        refresh: () => {
          Cache.remove(symbol, type);
          setLoading(true);
          setData(null);
        }
      };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CACHE WARMUP MANAGER - Preloads watchlist/portfolio in background
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function CacheWarmupManager() {
      const [warmupProgress, setWarmupProgress] = useState(0);
      const [isComplete, setIsComplete] = useState(false);

      useEffect(() => {
        const warmupCache = async () => {
          // Get symbols to preload
          const savedWatchlist = JSON.parse(localStorage.getItem('watchlist') || '[]');
          const savedPortfolio = JSON.parse(localStorage.getItem('portfolio') || '[]');
          const uniqueSymbols = [...new Set([
            ...savedWatchlist,
            ...savedPortfolio.map(p => p.symbol)
          ])].filter(Boolean);

          if (uniqueSymbols.length === 0) {
            setIsComplete(true);
            return;
          }

          console.log(`ğŸ”¥ Starting cache warmup for ${uniqueSymbols.length} symbols...`);

          // Process in batches
          const batchSize = 5;
          let completed = 0;

          for (let i = 0; i < uniqueSymbols.length; i += batchSize) {
            const batch = uniqueSymbols.slice(i, i + batchSize);

            // Check which symbols actually need fetching (not cached or stale)
            const symbolsNeedingFetch = batch.filter(sym => {
              const cached = Cache.get(sym, 'quote');
              if (!cached) return true;
              const timestamp = Cache.getTimestamp ? Cache.getTimestamp(sym, 'quote') : null;
              if (!timestamp) return true;
              // Refresh if older than 6 hours
              return (Date.now() - timestamp) > (6 * 60 * 60 * 1000);
            });

            if (symbolsNeedingFetch.length > 0) {
              try {
                // Use secure backend proxy
                const response = await fetch(`${window.API_BASE_URL}/api/quotes/batch`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ symbols: symbolsNeedingFetch })
                });
                if (response.ok) {
                  const quotes = await response.json();
                  if (Array.isArray(quotes)) {
                    quotes.forEach(quote => {
                      Cache.set(quote.symbol, quote, 'quote');
                    });
                  }
                }
              } catch (error) {
                console.warn('Batch warmup failed:', error);
              }
              await new Promise(r => setTimeout(r, 500));
            }

            completed += batch.length;
            setWarmupProgress(Math.round((completed / uniqueSymbols.length) * 100));
          }

          console.log('âœ… Cache warmup complete');
          setIsComplete(true);
        };

        // Start warmup after initial render
        const timer = setTimeout(warmupCache, 3000);
        return () => clearTimeout(timer);
      }, []);

      if (isComplete || warmupProgress === 0) return null;

      return (
        <div className="fixed bottom-4 right-4 z-50 glass-card px-4 py-2 rounded-lg border border-cyan-500/20 shadow-lg">
          <div className="flex items-center gap-2 text-xs text-cyan-300">
            <i className="fas fa-sync-alt animate-spin"></i>
            <span>Syncing data... {warmupProgress}%</span>
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA FRESHNESS BADGE - Shows how fresh the cached data is
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function DataFreshnessBadge({ symbol, type = 'quote', showLabel = false }) {
      const [status, setStatus] = useState({ age: null, isCached: false, isStale: false });

      useEffect(() => {
        const checkStatus = () => {
          const cached = Cache.get(symbol, type);
          if (cached) {
            const timestamp = Cache.getTimestamp ? Cache.getTimestamp(symbol, type) : null;
            if (timestamp) {
              const age = Date.now() - timestamp;
              const maxAge = Cache.getCacheDuration(type === 'quote' ? 'QUOTE_DATA' : 'STOCK_DATA');
              const minutes = Math.floor(age / 60000);

              setStatus({
                age: minutes,
                isCached: true,
                isStale: age > maxAge
              });
            }
          }
        };

        checkStatus();
        const interval = setInterval(checkStatus, 60000);
        return () => clearInterval(interval);
      }, [symbol, type]);

      if (!status.isCached) return null;

      const getColor = () => {
        if (status.isStale) return 'text-orange-400';
        if (status.age < 60) return 'text-green-400';
        if (status.age < 240) return 'text-yellow-400';
        return 'text-orange-400';
      };

      const getLabel = () => {
        if (status.isStale) return 'Update pending';
        if (status.age < 1) return 'Just now';
        if (status.age < 60) return `${status.age}m ago`;
        if (status.age < 1440) return `${Math.floor(status.age / 60)}h ago`;
        return `${Math.floor(status.age / 1440)}d ago`;
      };

      return (
        <span className={`text-[10px] ${getColor()} flex items-center gap-1`} title={status.isStale ? 'Data is stale - refreshing soon' : 'Last updated'}>
          <i className="fas fa-database"></i>
          {showLabel && <span>{getLabel()}</span>}
          {status.isStale && <i className="fas fa-exclamation-circle ml-1"></i>}
        </span>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SKELETON LOADING COMPONENTS (V2.0)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const SkeletonCard = () => (
      <div className="glass-card p-4 rounded-xl animate-pulse">
        <div className="flex items-center justify-between mb-4">
          <div className="skeleton h-6 w-16 rounded"></div>
          <div className="skeleton h-4 w-12 rounded"></div>
        </div>
        <div className="skeleton h-8 w-24 rounded mb-2"></div>
        <div className="skeleton h-4 w-full rounded mb-2"></div>
        <div className="skeleton h-4 w-3/4 rounded"></div>
      </div>
    );

    const SkeletonRow = () => (
      <tr className="border-b border-slate-700/30 animate-pulse">
        <td className="p-3"><div className="skeleton h-4 w-16 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-4 w-32 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-6 w-20 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-4 w-24 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-4 w-16 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-4 w-20 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-4 w-24 rounded"></div></td>
        <td className="p-3"><div className="skeleton h-8 w-16 rounded"></div></td>
      </tr>
    );


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIGURATION & CONSTANTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // API KEYS - PHASE 1 ENHANCED (Multi-source fallback)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MULTI-API CONFIGURATION WITH SMART FALLBACK
    // 9 APIs = 130,000+ monthly calls = Near-unlimited data access!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const API_KEYS = {
      FMP: 'h43nCTpMeyiIiNquebaqktc7ChUHMxIz',              // 250/day - Primary
      FINNHUB: 'd4fitqpr01qufc4upqn0d4fitqpr01qufc4upqng',   // 60/min, unlimited - Best backup!
      EOD_HISTORICAL: '691f22aa1a8e90.63897142',            // 100,000/month - Huge limit!
      TWELVE_DATA: '437c3794992642e29385a1ef00c9925f',       // 800/day
      INTRINIO: 'OjBmYmVhY2IyZTA3MTM2OWM4YjcwMWQwYzRlODk2NTBj', // 10,000/month
      TIINGO: '404d2953727ee5736d7b2e0671596633d730a1dc',   // 20,000/month
      ALPHA_VANTAGE: 'KUR4BDPE2H6NJMHO',                     // 25/day - sentiment only
      NEWS_API: '81a0be9978ed47c5a3d154aa0bc2feae',          // 100/day
      MARKETAUX: 'Eo8lyvncd3gFJVlVbTuZpKq2PQA3LeX2F1scj2XA', // 100/day
      DEEPSEEK: 'sk-d9a6e65b55e243389a2a5bdf40840e72',       // AI analysis
      CLAUDE: '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'
    };

    // Track API usage and health
    const API_STATS = {
      FMP: { calls: 0, failures: 0, lastSuccess: null },
      FINNHUB: { calls: 0, failures: 0, lastSuccess: null },
      EOD_HISTORICAL: { calls: 0, failures: 0, lastSuccess: null },
      TWELVE_DATA: { calls: 0, failures: 0, lastSuccess: null },
      INTRINIO: { calls: 0, failures: 0, lastSuccess: null },
      TIINGO: { calls: 0, failures: 0, lastSuccess: null }
    };

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function parseRetryAfterMs(headerValue) {
      if (!headerValue) return null;
      const trimmed = String(headerValue).trim();
      if (!trimmed) return null;
      // Retry-After can be seconds or an HTTP date
      const seconds = Number(trimmed);
      if (Number.isFinite(seconds)) return Math.max(0, seconds * 1000);

      const dateMs = Date.parse(trimmed);
      if (!Number.isFinite(dateMs)) return null;
      return Math.max(0, dateMs - Date.now());
    }

    function defaultShouldRetry({ response, error }) {
      if (error) {
        // Network errors, timeouts
        if (error.name === 'TimeoutError') return true;
        if (error.name === 'AbortError') return false;
        return true;
      }

      if (!response) return true;
      if (response.status === 429) return true;
      if (response.status === 408) return true;
      if (response.status >= 500 && response.status <= 599) return true;
      return false;
    }

    async function fetchWithRetry(url, options = {}) {
      const {
        timeoutMs = 12000,
        retries = 2,
        retryDelayMs = 600,
        maxRetryDelayMs = 8000,
        jitterRatio = 0.25,
        shouldRetry = defaultShouldRetry,
        signal: upstreamSignal,
        ...fetchOptions
      } = options;

      const totalAttempts = Math.max(1, Number(retries) + 1);
      let lastError = null;
      let lastResponse = null;

      for (let attempt = 0; attempt < totalAttempts; attempt++) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          try {
            controller.abort(new DOMException('Request timed out', 'TimeoutError'));
          } catch {
            controller.abort();
          }
        }, timeoutMs);

        let upstreamAbortHandler = null;
        if (upstreamSignal) {
          upstreamAbortHandler = () => {
            try {
              controller.abort(upstreamSignal.reason || new DOMException('Request aborted', 'AbortError'));
            } catch {
              controller.abort();
            }
          };
          if (upstreamSignal.aborted) {
            upstreamAbortHandler();
          } else {
            upstreamSignal.addEventListener('abort', upstreamAbortHandler, { once: true });
          }
        }

        try {
          const response = await fetch(url, { ...fetchOptions, signal: controller.signal });
          lastResponse = response;
          lastError = null;

          const retryAfterMs = response.status === 429
            ? parseRetryAfterMs(response.headers?.get?.('Retry-After'))
            : null;

          const canRetry = attempt < totalAttempts - 1;
          if (canRetry && shouldRetry({ response })) {
            const base = Math.min(maxRetryDelayMs, retryDelayMs * Math.pow(2, attempt));
            const jitter = base * jitterRatio * (Math.random() * 2 - 1);
            const waitMs = Math.max(0, Math.min(maxRetryDelayMs, (retryAfterMs ?? base) + jitter));
            console.warn(`â³ Retry ${attempt + 1}/${totalAttempts - 1} after ${Math.round(waitMs)}ms: ${String(url).slice(0, 120)}`);
            await sleep(waitMs);
            continue;
          }

          return response;
        } catch (error) {
          lastError = error;
          lastResponse = null;

          // If caller explicitly aborted, do not retry
          if (upstreamSignal?.aborted) throw error;

          const canRetry = attempt < totalAttempts - 1;
          if (canRetry && shouldRetry({ error })) {
            const base = Math.min(maxRetryDelayMs, retryDelayMs * Math.pow(2, attempt));
            const jitter = base * jitterRatio * (Math.random() * 2 - 1);
            const waitMs = Math.max(0, Math.min(maxRetryDelayMs, base + jitter));
            console.warn(`â³ Retry ${attempt + 1}/${totalAttempts - 1} after ${Math.round(waitMs)}ms (error: ${error?.name || 'Error'}): ${String(url).slice(0, 120)}`);
            await sleep(waitMs);
            continue;
          }

          throw error;
        } finally {
          clearTimeout(timeoutId);
          if (upstreamSignal && upstreamAbortHandler) {
            upstreamSignal.removeEventListener('abort', upstreamAbortHandler);
          }
        }
      }

      if (lastResponse) return lastResponse;
      throw lastError || new Error('Request failed');
    }

    function formatTimeAgo(timestampMs) {
      if (!timestampMs || !Number.isFinite(timestampMs)) return 'â€”';
      const deltaMs = Date.now() - timestampMs;
      if (deltaMs < 0) return 'just now';
      const seconds = Math.floor(deltaMs / 1000);
      if (seconds < 10) return 'just now';
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    function isStaleTimestamp(timestampMs, kind = 'quote') {
      if (!timestampMs || !Number.isFinite(timestampMs)) return false;
      const cacheDuration = (() => {
        try {
          if (Cache?.getCacheDuration) {
            return kind === 'quote' ? Cache.getCacheDuration('QUOTE_DATA') : Cache.getCacheDuration('STOCK_DATA');
          }
        } catch {
          // ignore
        }
        // Fallback behavior if Cache isn't available
        return kind === 'quote' ? (Cache?.isMarketOpen?.() ? (5 * 60 * 1000) : (24 * 60 * 60 * 1000))
          : (Cache?.isMarketOpen?.() ? (60 * 60 * 1000) : (24 * 60 * 60 * 1000));
      })();

      return (Date.now() - timestampMs) > cacheDuration;
    }

    // Smart fetch with automatic fallback
    async function smartFetch(endpoint, symbol, options = {}) {
      const isBrowser = typeof window !== 'undefined';

      const strategies = [
        // Strategy 1: FMP PAID (primary - use /stable/ endpoint for paid keys)
        {
          name: 'FMP',
          url: `https://financialmodelingprep.com/stable/${endpoint}?symbol=${symbol}&apikey=${API_KEYS.FMP}`,
          transform: (data) => data
        },
        // Strategy 2: Finnhub as backup (only if FMP fails)
        // NOTE: Finnhub doesn't support CORS from browsers, so skip entirely in browser environments
        ...(isBrowser ? [] : [{
          name: 'FINNHUB',
          url: endpoint.includes('quote')
            ? `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${API_KEYS.FINNHUB}`
            : null,
          transform: (data) => {
            // Transform Finnhub format to FMP format
            if (data && data.c) {
              return [{
                symbol: symbol,
                price: data.c,
                change: data.d,
                changesPercentage: data.dp,
                volume: data.v || 0
              }];
            }
            return data;
          }
        }])
      ];

      // Try each strategy in order
      for (const strategy of strategies) {
        if (!strategy.url) continue; // Skip if URL not supported for this endpoint

        // Double-check: Skip Finnhub in browser environments (extra safety)
        if (isBrowser && strategy.name === 'FINNHUB') {
          continue; // Silently skip - no logging to reduce console noise
        }

        // Additional safety: Check if URL contains finnhub and we're in browser
        if (isBrowser && strategy.url && strategy.url.includes('finnhub.io')) {
          continue; // Skip any Finnhub URLs in browsers
        }

        try {
          if (API_STATS[strategy.name]) {
            API_STATS[strategy.name].calls++;
          }

          console.log(`ğŸ”„ Trying ${strategy.name} for ${endpoint}...`);

          const response = await fetchWithRetry(strategy.url, {
            timeoutMs: options.timeoutMs ?? 12000,
            retries: options.retries ?? 2
          });

          if (response.status === 429) {
            console.warn(`â³ ${strategy.name} rate limited, trying next...`);
            if (API_STATS[strategy.name]) API_STATS[strategy.name].failures++;
            continue;
          }

          if (!response.ok) {
            // For 403 errors, log more details to help debug
            if (response.status === 403) {
              console.warn(`âŒ ${strategy.name} access denied (403)`);
              console.warn(`   URL: ${strategy.url.substring(0, 100)}...`);
              console.warn(`   Possible causes:`);
              console.warn(`   1. API key invalid or expired`);
              console.warn(`   2. Subscription tier doesn't include this endpoint`);
              console.warn(`   3. Rate limit or bandwidth exceeded`);
              console.warn(`   4. Endpoint requires higher subscription tier`);
              // Try to get error details
              try {
                const errorText = await response.clone().text();
                if (errorText) {
                  try {
                    const errorData = JSON.parse(errorText);
                    if (errorData.Error) console.warn(`   Error: ${errorData.Error}`);
                    if (errorData.message) console.warn(`   Message: ${errorData.message}`);
                  } catch (parseErr) {
                    // Not JSON, just log the text
                    if (errorText.length < 200) {
                      console.warn(`   Response: ${errorText}`);
                    }
                  }
                }
              } catch (e) {
                // Ignore errors when reading response
              }
              // For FMP 403, don't retry - go straight to backup
              if (strategy.name === 'FMP') {
                console.warn(`   Skipping FMP and using backup API...`);
              }
            }
            console.warn(`âŒ ${strategy.name} failed (${response.status}), trying next...`);
            if (API_STATS[strategy.name]) API_STATS[strategy.name].failures++;
            continue;
          }

          // Check if response is HTML (error page) before parsing JSON
          const responseText = await response.clone().text();
          if (responseText.trim().startsWith('<!DOCTYPE') || responseText.trim().startsWith('<html')) {
            console.warn(`âš ï¸ ${strategy.name} returned HTML instead of JSON (likely error page), trying next...`);
            if (API_STATS[strategy.name]) API_STATS[strategy.name].failures++;
            continue;
          }

          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            console.warn(`âš ï¸ ${strategy.name} response is not valid JSON: ${parseError.message}, trying next...`);
            if (API_STATS[strategy.name]) API_STATS[strategy.name].failures++;
            continue;
          }

          // Validate data before transforming
          if (!data || (Array.isArray(data) && data.length === 0)) {
            console.warn(`âš ï¸ ${strategy.name} returned empty data, trying next...`);
            if (API_STATS[strategy.name]) API_STATS[strategy.name].failures++;
            continue;
          }

          const transformed = strategy.transform(data);

          // Validate transformed data
          if (!transformed || (Array.isArray(transformed) && transformed.length === 0)) {
            console.warn(`âš ï¸ ${strategy.name} transformation returned empty data, trying next...`);
            if (API_STATS[strategy.name]) API_STATS[strategy.name].failures++;
            continue;
          }

          if (API_STATS[strategy.name]) {
            API_STATS[strategy.name].lastSuccess = new Date();
          }
          console.log(`âœ… ${strategy.name} succeeded for ${endpoint}!`);

          return { data: transformed, source: strategy.name };

        } catch (error) {
          // Check for CORS errors specifically
          const isCorsError = error.message?.includes('CORS') ||
            error.message?.includes('Failed to fetch') ||
            error.name === 'TypeError' ||
            error.message?.includes('blocked by CORS') ||
            error.message?.includes('Access-Control-Allow-Origin');

          if (isCorsError) {
            // Silently skip CORS errors - they're expected in browsers
            if (API_STATS[strategy.name]) {
              API_STATS[strategy.name].failures++;
            }
            continue;
          }

          // Check for rate limiting (429)
          if (error.message?.includes('429') || error.message?.includes('Too Many Requests')) {
            console.warn(`âš ï¸ ${strategy.name} rate limited (429), skipping...`);
            if (API_STATS[strategy.name]) {
              API_STATS[strategy.name].failures++;
            }
            continue;
          }

          // Check for rate limiting (429)
          if (error.message?.includes('429') || error.message?.includes('Too Many Requests')) {
            console.warn(`âš ï¸ ${strategy.name} rate limited (429), skipping...`);
            if (API_STATS[strategy.name]) {
              API_STATS[strategy.name].failures++;
            }
            continue;
          }

          // Only log non-expected errors
          console.error(`âŒ ${strategy.name} error:`, error.message);
          if (API_STATS[strategy.name]) {
            API_STATS[strategy.name].failures++;
          }
          continue;
        }
      }

      // All strategies failed
      throw new Error(`All API sources failed for ${endpoint}`);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEEPSEEK AI ANALYSIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function getDeepSeekAnalysis(stock) {
      try {
        // Validate API key
        if (!API_KEYS.DEEPSEEK || API_KEYS.DEEPSEEK === '') {
          throw new Error('DeepSeek API key is missing. Please configure your API key.');
        }
        console.log('DeepSeek API key found:', API_KEYS.DEEPSEEK.substring(0, 10) + '...');

        const stockData = {
          symbol: stock.symbol,
          name: stock.name,
          price: stock.price,
          change: stock.change,
          changePct: stock.changePct,
          volume: stock.volume,
          marketCap: stock.marketCap,
          pe: stock.pe,
          eps: stock.eps,
          beta: stock.beta,
          dividend: stock.dividend,
          divYield: stock.divYield,
          fiftyTwoWkHigh: stock.fiftyTwoWkHigh,
          fiftyTwoWkLow: stock.fiftyTwoWkLow,
          avgVolume: stock.avgVolume,
          sector: stock.sector,
          industry: stock.industry,
          roe: stock.roe,
          roa: stock.roa,
          debtToEquity: stock.debtToEquity,
          currentRatio: stock.currentRatio,
          quickRatio: stock.quickRatio,
          revenueGrowth: stock.revenueGrowth,
          earningsGrowth: stock.earningsGrowth,
          priceToBook: stock.priceToBook,
          priceToSales: stock.priceToSales,
          analystRating: stock.analystRating,
          priceTarget: stock.priceTarget
        };

        const prompt = `You are a professional stock analyst. Analyze the following stock data and provide a comprehensive investment analysis including:
1. Overall Assessment (bullish/neutral/bearish)
2. Key Strengths (3-4 points)
3. Key Risks (3-4 points)
4. Valuation Analysis
5. Technical Outlook
6. Investment Recommendation (Buy/Hold/Sell with reasoning)

Stock Data:
${JSON.stringify(stockData, null, 2)}

Please provide a clear, structured analysis in markdown format.`;

        const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_KEYS.DEEPSEEK}`
          },
          body: JSON.stringify({
            model: 'deepseek-chat',
            messages: [
              {
                role: 'system',
                content: 'You are a professional stock market analyst with expertise in fundamental and technical analysis.'
              },
              {
                role: 'user',
                content: prompt
              }
            ],
            temperature: 0.7,
            max_tokens: 2000
          })
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(`DeepSeek API error: ${response.status} - ${error}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;

      } catch (error) {
        console.error('DeepSeek AI analysis error:', error);
        throw error;
      }
    }



    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ADVANCED CHARTING UTILITIES (Lightweight Charts)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function parseFmpCandleTime(dateStr) {
      if (dateStr == null) return null;

      // Some endpoints return epoch seconds/ms
      if (typeof dateStr === 'number' && Number.isFinite(dateStr)) {
        const ms = dateStr > 2e12 ? dateStr : (dateStr > 2e10 ? dateStr : dateStr * 1000);
        return Math.floor(ms / 1000);
      }

      const s = String(dateStr).trim();
      if (!s) return null;

      // FMP frequently returns "YYYY-MM-DD HH:mm:ss" (non-ISO).
      // Normalize to ISO for consistent parsing.
      const isoish = s.includes(' ') && !s.includes('T')
        ? s.replace(' ', 'T')
        : s;

      // If there's a time component but no timezone, treat as UTC.
      const needsZ = /T\d{2}:\d{2}/.test(isoish) && !/[zZ]|[+-]\d{2}:?\d{2}$/.test(isoish);
      const candidate = needsZ ? `${isoish}Z` : isoish;

      const ms = Date.parse(candidate);
      if (!Number.isFinite(ms)) return null;
      return Math.floor(ms / 1000);
    }

    function normalizeFmpCandles(raw) {
      if (!Array.isArray(raw)) return [];
      return raw
        .map(c => {
          const time = parseFmpCandleTime(c.date);
          if (!time) return null;
          return {
            time,
            open: Number(c.open),
            high: Number(c.high),
            low: Number(c.low),
            close: Number(c.close),
            volume: Number(c.volume || c.vol || 0)
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.time - b.time);
    }

    function sma(values, period) {
      const out = new Array(values.length).fill(null);
      if (!period || period < 2) return out;
      let sum = 0;
      for (let i = 0; i < values.length; i++) {
        sum += values[i];
        if (i >= period) sum -= values[i - period];
        if (i >= period - 1) out[i] = sum / period;
      }
      return out;
    }

    function ema(values, period) {
      const out = new Array(values.length).fill(null);
      if (!period || period < 2 || values.length === 0) return out;
      const k = 2 / (period + 1);
      let prev = values[0];
      out[0] = prev;
      for (let i = 1; i < values.length; i++) {
        const next = values[i] * k + prev * (1 - k);
        out[i] = next;
        prev = next;
      }
      return out;
    }

    function stddev(values, period, smaArr) {
      const out = new Array(values.length).fill(null);
      if (!period || period < 2) return out;
      for (let i = period - 1; i < values.length; i++) {
        const mean = smaArr[i];
        if (mean == null) continue;
        let variance = 0;
        for (let j = i - period + 1; j <= i; j++) {
          const d = values[j] - mean;
          variance += d * d;
        }
        out[i] = Math.sqrt(variance / period);
      }
      return out;
    }

    function computeBollinger(closes, period = 20, mult = 2) {
      const mid = sma(closes, period);
      const sd = stddev(closes, period, mid);
      const upper = mid.map((m, i) => (m == null || sd[i] == null) ? null : m + mult * sd[i]);
      const lower = mid.map((m, i) => (m == null || sd[i] == null) ? null : m - mult * sd[i]);
      return { mid, upper, lower };
    }

    function computeRSI(closes, period = 14) {
      const out = new Array(closes.length).fill(null);
      if (closes.length < period + 1) return out;
      let gain = 0;
      let loss = 0;
      for (let i = 1; i <= period; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff >= 0) gain += diff;
        else loss -= diff;
      }
      let avgGain = gain / period;
      let avgLoss = loss / period;
      out[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));

      for (let i = period + 1; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        const g = diff > 0 ? diff : 0;
        const l = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + g) / period;
        avgLoss = (avgLoss * (period - 1) + l) / period;
        out[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
      }
      return out;
    }

    function computeMACD(closes, fast = 12, slow = 26, signal = 9) {
      const fastEma = ema(closes, fast);
      const slowEma = ema(closes, slow);
      const macd = closes.map((_, i) => (fastEma[i] == null || slowEma[i] == null) ? null : (fastEma[i] - slowEma[i]));

      const macdForEma = macd.map(v => v == null ? 0 : v);
      const signalLine = ema(macdForEma, signal).map((v, i) => (i < slow - 1 ? null : v));
      const hist = macd.map((v, i) => (v == null || signalLine[i] == null) ? null : (v - signalLine[i]));
      return { macd, signal: signalLine, hist };
    }

    function computeVolumeProfile(candles, bins = 24) {
      if (!Array.isArray(candles) || candles.length === 0) return [];
      let min = Infinity;
      let max = -Infinity;
      for (const c of candles) {
        min = Math.min(min, c.low);
        max = Math.max(max, c.high);
      }
      if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) return [];

      const binSize = (max - min) / bins;
      const acc = new Array(bins).fill(0);
      for (const c of candles) {
        const tp = (c.high + c.low + c.close) / 3;
        const idx = Math.min(bins - 1, Math.max(0, Math.floor((tp - min) / binSize)));
        acc[idx] += Number(c.volume || 0);
      }

      const maxVol = Math.max(...acc, 1);
      return acc.map((v, i) => {
        const lo = min + i * binSize;
        const hi = lo + binSize;
        return { lo, hi, volume: v, pct: (v / maxVol) * 100 };
      }).reverse();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART CACHING SYSTEM - Speeds up loading by 10x!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const CACHE_CONFIG = {
      // ULTRA-EXTENDED CACHE DURATIONS - 90 days for most data
      STOCK_DATA: 90 * 24 * 60 * 60 * 1000,      // 90 DAYS - Fundamentals rarely change
      QUOTE_DATA_MARKET_OPEN: 15 * 60 * 1000,    // 15 minutes during market hours
      QUOTE_DATA_MARKET_CLOSED: 48 * 60 * 60 * 1000, // 48 hours when closed
      CHART_DATA: 30 * 24 * 60 * 60 * 1000,      // 30 DAYS - Historical doesn't change
      NEWS_DATA: 12 * 60 * 60 * 1000,            // 12 hours
      SENTIMENT_DATA: 24 * 60 * 60 * 1000,       // 24 hours
      EARNINGS_DATA: 90 * 24 * 60 * 60 * 1000,   // 90 days - Earnings are quarterly
      PROFILE_DATA: 90 * 24 * 60 * 60 * 1000,    // 90 days - Company profiles are stable
      MARKET_CLOSED: 7 * 24 * 60 * 60 * 1000,    // 7 days when market closed
      MAX_CACHE_SIZE: 2000,                      // Increased from 1000
      CACHE_VERSION: 'v7',                       // Bump version for 90-day cache
      OFFLINE_MODE: true,

      // Aggressive prefetching settings
      PREFETCH_ENABLED: true,
      PREFETCH_BATCH_SIZE: 20,                   // Load 20 stocks at once
      BACKGROUND_REFRESH_INTERVAL: 10 * 60 * 1000 // Check for updates every 10 min
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REFRESH THROTTLER - Prevent Unnecessary API Calls
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class RefreshThrottler {
      constructor() {
        this.lastRefreshTime = parseInt(localStorage.getItem('re_last_refresh_time') || '0');
        this.minRefreshInterval = 5 * 60 * 1000; // 5 minutes minimum between refreshes
      }

      shouldRefresh(force = false) {
        const now = Date.now();

        if (force) return true;

        // If less than min interval passed, use cache
        if (now - this.lastRefreshTime < this.minRefreshInterval) {
          console.log('â±ï¸ Refresh throttled - using cached data');
          return false;
        }

        this.lastRefreshTime = now;
        localStorage.setItem('re_last_refresh_time', now.toString());
        return true;
      }

      markRefreshed() {
        this.lastRefreshTime = Date.now();
        localStorage.setItem('re_last_refresh_time', this.lastRefreshTime.toString());
      }
    }

    const refreshThrottler = new RefreshThrottler();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VIEWPORT LOADER - Only Load Visible Stocks (HUGE Performance Win!)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const ViewportLoader = {
      observer: null,
      visibleSymbols: new Set(),
      loadedDetailSymbols: new Set(),
      pendingLoads: new Map(),
      callbacks: new Map(),

      init() {
        if (typeof IntersectionObserver === 'undefined') {
          console.warn('IntersectionObserver not supported');
          return;
        }

        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const symbol = entry.target.dataset?.symbol;
            if (!symbol) return;

            if (entry.isIntersecting) {
              this.onSymbolVisible(symbol);
            } else {
              this.visibleSymbols.delete(symbol);
            }
          });
        }, {
          rootMargin: '100px', // Start loading 100px before visible
          threshold: 0.01
        });

        console.log('ğŸ‘€ ViewportLoader initialized');
      },

      observe(element, symbol, onVisible) {
        if (!this.observer || !element) return;
        element.dataset.symbol = symbol;
        if (onVisible) {
          this.callbacks.set(symbol, onVisible);
        }
        this.observer.observe(element);
      },

      unobserve(element) {
        if (!this.observer || !element) return;
        this.observer.unobserve(element);
        const symbol = element.dataset?.symbol;
        if (symbol) {
          this.visibleSymbols.delete(symbol);
          this.callbacks.delete(symbol);
        }
      },

      onSymbolVisible(symbol) {
        this.visibleSymbols.add(symbol);

        // Skip if already loaded detailed data
        if (this.loadedDetailSymbols.has(symbol)) return;

        // Skip if already pending
        if (this.pendingLoads.has(symbol)) return;

        this.pendingLoads.set(symbol, true);

        // Call the callback if registered
        const callback = this.callbacks.get(symbol);
        if (callback) {
          callback(symbol);
        }

        // Mark as loaded after a delay
        setTimeout(() => {
          this.loadedDetailSymbols.add(symbol);
          this.pendingLoads.delete(symbol);
        }, 500);
      },

      isVisible(symbol) {
        return this.visibleSymbols.has(symbol);
      },

      getVisibleSymbols() {
        return Array.from(this.visibleSymbols);
      },

      destroy() {
        if (this.observer) {
          this.observer.disconnect();
        }
        this.visibleSymbols.clear();
        this.loadedDetailSymbols.clear();
        this.pendingLoads.clear();
        this.callbacks.clear();
      }
    };

    // Initialize ViewportLoader
    ViewportLoader.init();
    window.ViewportLoader = ViewportLoader;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEBOUNCED LOCALSTORAGE - Batch writes to avoid blocking main thread
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const DebouncedStorage = {
      pending: new Map(),
      timers: new Map(),

      setItem(key, value, delay = 1000) {
        // Store pending write
        this.pending.set(key, value);

        // Clear existing timer
        if (this.timers.has(key)) {
          clearTimeout(this.timers.get(key));
        }

        // Schedule write
        const timer = setTimeout(() => {
          try {
            const pendingValue = this.pending.get(key);
            if (pendingValue !== undefined) {
              localStorage.setItem(key, pendingValue);
              this.pending.delete(key);
              this.timers.delete(key);
            }
          } catch (err) {
            console.warn('DebouncedStorage write failed:', err);
          }
        }, delay);

        this.timers.set(key, timer);
      },

      flush() {
        // Write all pending immediately
        this.pending.forEach((value, key) => {
          try {
            localStorage.setItem(key, value);
          } catch (err) {
            console.warn('Flush failed for', key, err);
          }
        });
        this.pending.clear();
        this.timers.forEach(timer => clearTimeout(timer));
        this.timers.clear();
      }
    };

    // Flush on page unload
    window.addEventListener('beforeunload', () => DebouncedStorage.flush());

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BATCHED LOCALSTORAGE - Debounced writes to avoid blocking UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const BatchedLocalStorage = {
      pendingWrites: new Map(),
      writeTimer: null,
      DEBOUNCE_MS: 500,

      set(key, value) {
        // Queue the write
        this.pendingWrites.set(key, value);

        // Debounce actual write
        if (this.writeTimer) clearTimeout(this.writeTimer);
        this.writeTimer = setTimeout(() => this.flush(), this.DEBOUNCE_MS);
      },

      flush() {
        if (this.pendingWrites.size === 0) return;

        // Batch write all pending
        requestIdleCallback(() => {
          this.pendingWrites.forEach((value, key) => {
            try {
              localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
            } catch (err) {
              console.warn(`LocalStorage write failed for ${key}:`, err);
            }
          });
          this.pendingWrites.clear();
        }, { timeout: 1000 });
      },

      // Immediate write (for critical data)
      setImmediate(key, value) {
        try {
          localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
        } catch (err) {
          console.warn(`LocalStorage immediate write failed for ${key}:`, err);
        }
      }
    };

    window.BatchedLocalStorage = BatchedLocalStorage;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION PERSISTENCE - Instant Load Between Refreshes
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const SessionPersistence = {
      SESSION_KEY: 're_current_session_data_v2',
      MAX_SESSION_AGE: 2 * 60 * 60 * 1000, // 2 hours

      saveSession(stocks, filters = {}, watchlist = [], viewState = {}) {
        try {
          const sessionData = {
            stocks: stocks.map(s => ({
              symbol: s.symbol,
              price: s.price,
              changePct: s.changePct,
              pe: s.pe,
              roe: s.roe,
              aiScore: s.aiScore,
              verdict: s.verdict,
              sector: s.sector,
              name: s.name,
              marketCap: s.marketCap
            })),
            filters,
            watchlist,
            viewState,
            timestamp: Date.now(),
            version: 'v2'
          };

          localStorage.setItem(this.SESSION_KEY, JSON.stringify(sessionData));
          console.log('ğŸ’¾ Session data saved');
        } catch (error) {
          console.warn('Failed to save session:', error);
        }
      },

      loadSession() {
        try {
          const sessionJson = localStorage.getItem(this.SESSION_KEY);
          if (!sessionJson) return null;

          const sessionData = JSON.parse(sessionJson);

          // Check if session is still valid
          if (Date.now() - sessionData.timestamp > this.MAX_SESSION_AGE) {
            this.clearSession();
            return null;
          }

          console.log('ğŸ“‚ Session loaded from storage');
          return sessionData;
        } catch (error) {
          console.warn('Failed to load session:', error);
          return null;
        }
      },

      clearSession() {
        localStorage.removeItem(this.SESSION_KEY);
      },

      hasValidSession() {
        const session = this.loadSession();
        return session !== null && session.stocks?.length > 0;
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VISIBILITY-BASED OPTIMIZATIONS - Save resources when tab hidden
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function setupVisibilityOptimizations() {
      // FIX: Ensure listener is added only once
      if (window.VISIBILITY_LISTENER_ATTACHED) return;
      window.VISIBILITY_LISTENER_ATTACHED = true;

      const handleVisibilityChange = () => {
        if (document.hidden) {
          console.log('ğŸ“´ Tab hidden - pausing background activity');
          window.TAB_HIDDEN = true;

          // OPTIMIZATION: Pause all active intervals when tab is hidden
          if (window.ACTIVE_INTERVALS) {
            window.PAUSED_INTERVALS = [...window.ACTIVE_INTERVALS];
            window.ACTIVE_INTERVALS.forEach(id => clearInterval(id));
            window.ACTIVE_INTERVALS.clear();
          }
        } else {
          console.log('ğŸ“± Tab visible - restoring normal activity');
          window.TAB_HIDDEN = false;

          // OPTIMIZATION: Resume intervals when tab becomes visible
          if (window.PAUSED_INTERVALS && window.PAUSED_INTERVALS.length > 0) {
            console.log('ğŸ”„ Resuming background tasks...');
            window.PAUSED_INTERVALS = [];
          }
        }
      };

      document.addEventListener('visibilitychange', handleVisibilityChange);

      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        document.removeEventListener('visibilitychange', handleVisibilityChange);
      });
    }

    // Initialize visibility optimizations
    window.ACTIVE_INTERVALS = window.ACTIVE_INTERVALS || new Set();
    setupVisibilityOptimizations();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLEANUP OLD CACHE DATA - Weekly cleanup to prevent bloat
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function cleanupOldCacheData() {
      const cleanupKey = 're_last_cache_cleanup';
      const lastCleanup = parseInt(localStorage.getItem(cleanupKey) || '0');
      const oneWeek = 7 * 24 * 60 * 60 * 1000;

      if (Date.now() - lastCleanup > oneWeek) {
        console.log('ğŸ§¹ Running weekly cache cleanup...');

        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);

          if (key && (key.startsWith('re_advanced_') || key.startsWith('re_cache_') || key.startsWith('v5_') || key.startsWith('v6_'))) {
            try {
              const data = JSON.parse(localStorage.getItem(key));
              if (data && Date.now() - (data.timestamp || 0) > 90 * 24 * 60 * 60 * 1000) {
                keysToRemove.push(key);
              }
            } catch {
              // If can't parse, remove it
              keysToRemove.push(key);
            }
          }
        }

        keysToRemove.forEach(key => localStorage.removeItem(key));

        localStorage.setItem(cleanupKey, Date.now().toString());
        console.log(`ğŸ§¹ Cleaned up ${keysToRemove.length} old cache entries`);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PLACEHOLDER STOCK GENERATOR - Instant UI with loading states
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const PlaceholderManager = {
      // Create placeholder stocks for instant display
      createPlaceholders(symbols) {
        return symbols.map((symbol, index) => ({
          symbol: symbol.toUpperCase(),
          name: symbol,
          price: null,
          changePct: null,
          marketCap: null,
          pe: null,
          roe: null,
          aiScore: null,
          verdict: 'Loading...',
          _isPlaceholder: true,
          _loadOrder: index
        }));
      },

      // Merge real data into placeholder
      mergeWithPlaceholder(placeholder, realData) {
        if (!realData) return placeholder;
        return {
          ...placeholder,
          ...realData,
          _isPlaceholder: false,
          _loadOrder: placeholder._loadOrder
        };
      }
    };

    // Run cleanup on startup (delayed)
    setTimeout(cleanupOldCacheData, 5000);

    // Expose for manual use
    window.SessionPersistence = SessionPersistence;
    window.refreshThrottler = refreshThrottler;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ULTRA-FAST CACHE - In-memory layer + localStorage persistence
    // Eliminates redundant localStorage reads and parsing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const Cache = {
      // IN-MEMORY CACHE LAYER - Instant access, no parsing needed
      _memoryCache: new Map(),
      _memoryCacheMaxSize: 500,
      _marketOpenCached: null,
      _marketOpenCacheTime: 0,

      // Check if market is currently open (cached for 1 minute)
      isMarketOpen() {
        const now = Date.now();
        if (this._marketOpenCached !== null && (now - this._marketOpenCacheTime) < 60000) {
          return this._marketOpenCached;
        }

        const date = new Date();
        const et = new Date(date.toLocaleString('en-US', { timeZone: 'America/New_York' }));
        const day = et.getDay();
        const hour = et.getHours();
        const minute = et.getMinutes();

        // Weekend
        if (day === 0 || day === 6) {
          this._marketOpenCached = false;
          this._marketOpenCacheTime = now;
          return false;
        }

        // Before market open (9:30 AM) or after close (4:00 PM)
        const isOpen = !(hour < 9 || (hour === 9 && minute < 30) || hour >= 16);
        this._marketOpenCached = isOpen;
        this._marketOpenCacheTime = now;
        return isOpen;
      },

      // Get appropriate cache duration - Smart intervals based on data type and market hours
      getCacheDuration(type = 'STOCK_DATA') {
        if (type === 'QUOTE_DATA') {
          return this.isMarketOpen()
            ? CACHE_CONFIG.QUOTE_DATA_MARKET_OPEN
            : CACHE_CONFIG.QUOTE_DATA_MARKET_CLOSED;
        }

        const intervals = {
          'STOCK_DATA': CACHE_CONFIG.STOCK_DATA,
          'CHART_DATA': CACHE_CONFIG.CHART_DATA,
          'NEWS_DATA': CACHE_CONFIG.NEWS_DATA,
          'SENTIMENT_DATA': CACHE_CONFIG.SENTIMENT_DATA,
          'EARNINGS_DATA': CACHE_CONFIG.EARNINGS_DATA
        };

        return intervals[type] || CACHE_CONFIG.STOCK_DATA;
      },

      // Generate cache key
      key(symbol, type = 'stock') {
        return `${CACHE_CONFIG.CACHE_VERSION}_${type}_${symbol.toUpperCase()}`;
      },

      // INTERNAL: Load from localStorage into memory cache
      _loadToMemory(key) {
        // Already in memory?
        if (this._memoryCache.has(key)) {
          return this._memoryCache.get(key);
        }

        try {
          const cached = localStorage.getItem(key);
          if (!cached) return null;

          // Parse once, store in memory
          const parsed = JSON.parse(cached);

          // Store in memory cache with LRU eviction
          if (this._memoryCache.size >= this._memoryCacheMaxSize) {
            // Remove oldest entry
            const firstKey = this._memoryCache.keys().next().value;
            this._memoryCache.delete(firstKey);
          }
          this._memoryCache.set(key, parsed);

          return parsed;
        } catch (error) {
          return null;
        }
      },

      // Get cached data - INSTANT from memory, falls back to localStorage
      get(symbol, type = 'stock') {
        const key = this.key(symbol, type);
        const cached = this._loadToMemory(key);

        if (!cached) return null;

        // Return data immediately - no logging in hot path
        return cached.data;
      },

      // BATCH GET - Optimized for checking many symbols at once
      getBatch(symbols, type = 'stock') {
        const results = { cached: [], uncached: [] };

        symbols.forEach(symbol => {
          const data = this.get(symbol, type);
          if (data) {
            results.cached.push({ symbol, data });
          } else {
            results.uncached.push(symbol);
          }
        });

        return results;
      },

      // Get with metadata (for when you need timestamp too)
      getWithMeta(symbol, type = 'stock') {
        const key = this.key(symbol, type);
        return this._loadToMemory(key);
      },

      // Check if cache is expired - uses memory cache, no redundant reads
      isExpired(symbol, type = 'stock') {
        const key = this.key(symbol, type);
        const cached = this._loadToMemory(key);

        if (!cached) return true;

        const age = Date.now() - cached.timestamp;
        const maxAge = this.getCacheDuration(type === 'quote' ? 'QUOTE_DATA' : 'STOCK_DATA');
        return age > maxAge;
      },

      // Get cache timestamp - uses memory cache
      getTimestamp(symbol, type = 'stock') {
        const key = this.key(symbol, type);
        const cached = this._loadToMemory(key);
        return cached ? cached.timestamp : null;
      },

      // Set cached data - writes to both memory and localStorage
      set(symbol, data, type = 'stock') {
        const key = this.key(symbol, type);
        const cacheData = {
          data,
          timestamp: Date.now(),
          version: CACHE_CONFIG.CACHE_VERSION
        };

        // Update memory cache immediately (fast)
        if (this._memoryCache.size >= this._memoryCacheMaxSize) {
          const firstKey = this._memoryCache.keys().next().value;
          this._memoryCache.delete(firstKey);
        }
        this._memoryCache.set(key, cacheData);

        // Persist to localStorage asynchronously (don't block UI)
        requestAnimationFrame(() => {
          try {
            localStorage.setItem(key, JSON.stringify(cacheData));
          } catch (error) {
            if (error.name === 'QuotaExceededError') {
              this.aggressiveCleanup();
              try {
                localStorage.setItem(key, JSON.stringify(cacheData));
              } catch { /* give up */ }
            }
          }
        });
      },

      // Remove specific cache
      remove(symbol, type = 'stock') {
        const key = this.key(symbol, type);
        this._memoryCache.delete(key);
        try {
          localStorage.removeItem(key);
        } catch { /* ignore */ }
      },

      // Clear all caches
      clear() {
        this._memoryCache.clear();
        try {
          const keys = Object.keys(localStorage);
          const cacheKeys = keys.filter(k => k.startsWith(CACHE_CONFIG.CACHE_VERSION));
          cacheKeys.forEach(key => localStorage.removeItem(key));
          console.log(`ğŸ§¹ Cleared ${cacheKeys.length} cached items`);
        } catch { /* ignore */ }
      },

      // Preload frequently accessed stocks into memory (call on app init)
      preloadToMemory(symbols) {
        const startTime = performance.now();
        let loaded = 0;

        symbols.forEach(symbol => {
          const quoteKey = this.key(symbol, 'quote');
          const stockKey = this.key(symbol, 'stock');

          if (this._loadToMemory(quoteKey)) loaded++;
          if (this._loadToMemory(stockKey)) loaded++;
        });

        console.log(`âš¡ Preloaded ${loaded} cache entries to memory in ${(performance.now() - startTime).toFixed(0)}ms`);
      },

      // Remove oldest caches to free up space
      clearOldest() {
        try {
          const keys = Object.keys(localStorage);
          const cacheKeys = keys.filter(k => k.startsWith(CACHE_CONFIG.CACHE_VERSION));

          // Get timestamps and sort by age
          const cacheItems = cacheKeys.map(key => {
            try {
              const { timestamp } = JSON.parse(localStorage.getItem(key));
              return { key, timestamp };
            } catch {
              return { key, timestamp: 0 };
            }
          }).sort((a, b) => a.timestamp - b.timestamp);

          // Remove oldest 20%
          const toRemove = Math.ceil(cacheItems.length * 0.2);
          cacheItems.slice(0, toRemove).forEach(item => {
            localStorage.removeItem(item.key);
          });

          console.log(`ğŸ§¹ Removed ${toRemove} oldest cache items`);
        } catch (error) {
          console.warn('Cache cleanup error:', error);
        }
      },

      // Fetch with cache - returns cached data immediately, refreshes in background if needed
      async fetchWithCache(symbol, type, fetchFunction, options = {}) {
        const { forceRefresh = false } = options;

        // Always return cached data immediately if available (from memory!)
        const cached = this.get(symbol, type);
        if (cached && !forceRefresh) {
          // Use memory-cached metadata instead of re-reading localStorage
          if (this.isExpired(symbol, type)) {
            // Trigger background refresh - use requestIdleCallback for better performance
            const refresh = () => fetchFunction(symbol).then(data => {
              if (data) this.set(symbol, data, type);
            }).catch(() => { });

            if ('requestIdleCallback' in window) {
              requestIdleCallback(refresh, { timeout: 5000 });
            } else {
              setTimeout(refresh, 1000);
            }
          }
          return cached;
        }

        // If no cache or forced refresh, fetch now
        try {
          const freshData = await fetchFunction(symbol);
          if (freshData) {
            this.set(symbol, freshData, type);
            return freshData;
          }
        } catch (error) {
          // Return stale cache as fallback
          if (cached) {
            return cached;
          }
          throw error;
        }

        return null;
      },

      // Smart cleanup - remove expired items
      cleanup() {
        try {
          const keys = Object.keys(localStorage);
          const cacheKeys = keys.filter(k => k.startsWith(CACHE_CONFIG.CACHE_VERSION));

          if (cacheKeys.length <= CACHE_CONFIG.MAX_CACHE_SIZE) return;

          let removed = 0;
          cacheKeys.forEach(key => {
            try {
              const { timestamp } = JSON.parse(localStorage.getItem(key));
              const age = Date.now() - timestamp;

              // Remove if older than 24 hours
              if (age > 24 * 60 * 60 * 1000) {
                localStorage.removeItem(key);
                removed++;
              }
            } catch {
              localStorage.removeItem(key);
              removed++;
            }
          });

          if (removed > 0) {
            console.log(`ğŸ§¹ Cleanup removed ${removed} expired items`);
          }
        } catch (error) {
          console.warn('Cache cleanup error:', error);
        }
      },

      // Get cache statistics (optimized - no full scan)
      stats() {
        return {
          memoryCount: this._memoryCache.size,
          marketOpen: this.isMarketOpen(),
          // Only do full localStorage scan if explicitly requested
          getFullStats: () => {
            const keys = Object.keys(localStorage);
            const cacheKeys = keys.filter(k => k.startsWith(CACHE_CONFIG.CACHE_VERSION));
            let totalSize = 0;
            cacheKeys.forEach(key => {
              totalSize += (localStorage.getItem(key) || '').length;
            });
            return {
              localStorageCount: cacheKeys.length,
              sizeKB: Math.round(totalSize / 1024)
            };
          }
        };
      },

      // Cache index management
      cacheIndex() {
        try {
          const index = localStorage.getItem('re_cache_index');
          return index ? JSON.parse(index) : {};
        } catch {
          return {};
        }
      },

      updateIndex(symbol, type, timestamp) {
        const index = this.cacheIndex();
        const key = this.key(symbol, type);

        index[key] = {
          symbol,
          type,
          timestamp,
          lastAccessed: Date.now(),
          size: JSON.stringify(localStorage.getItem(key) || '').length
        };

        localStorage.setItem('re_cache_index', JSON.stringify(index));
      },

      aggressiveCleanup() {
        const index = this.cacheIndex();
        const entries = Object.entries(index);

        // Sort by last accessed (oldest first)
        entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);

        // Remove 30% oldest entries
        const toRemove = Math.ceil(entries.length * 0.3);
        for (let i = 0; i < toRemove; i++) {
          const [key] = entries[i];
          localStorage.removeItem(key);
          delete index[key];
        }

        localStorage.setItem('re_cache_index', JSON.stringify(index));
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ADVANCED STORAGE MANAGER - IndexedDB + localStorage Hybrid
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const AdvancedStorage = {
      dbName: 'RetailEdgePro_v4',
      version: 4,
      stores: ['stockData', 'chartData', 'newsData', 'analytics'],

      async init() {
        if (!window.indexedDB) {
          console.warn('âš ï¸ IndexedDB not available, falling back to localStorage');
          return false;
        }

        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.version);

          request.onerror = () => {
            console.error('âŒ IndexedDB initialization failed');
            resolve(false);
          };

          request.onsuccess = () => {
            this.db = request.result;
            console.log('âœ… IndexedDB initialized');
            resolve(true);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Stock data store
            if (!db.objectStoreNames.contains('stockData')) {
              const store = db.createObjectStore('stockData', { keyPath: 'id' });
              store.createIndex('timestamp', 'timestamp', { unique: false });
              store.createIndex('symbol', 'symbol', { unique: false });
            }

            // Chart data store (larger datasets)
            if (!db.objectStoreNames.contains('chartData')) {
              const store = db.createObjectStore('chartData', { keyPath: 'id' });
              store.createIndex('symbol', 'symbol', { unique: false });
              store.createIndex('timeframe', 'timeframe', { unique: false });
            }

            // News data store
            if (!db.objectStoreNames.contains('newsData')) {
              const store = db.createObjectStore('newsData', { keyPath: 'id' });
              store.createIndex('symbol', 'symbol', { unique: false });
              store.createIndex('publishedAt', 'publishedAt', { unique: false });
            }

            // Analytics cache
            if (!db.objectStoreNames.contains('analytics')) {
              const store = db.createObjectStore('analytics', { keyPath: 'id' });
              store.createIndex('symbol', 'symbol', { unique: false });
              store.createIndex('type', 'type', { unique: false });
            }
          };
        });
      },

      // Compress data before storing
      compress(data) {
        try {
          const stringified = JSON.stringify(data);
          return stringified.length > 1000 ? btoa(stringified) : data;
        } catch {
          return data;
        }
      },

      decompress(data) {
        if (typeof data === 'string' && data.length > 1000) {
          try {
            return JSON.parse(atob(data));
          } catch {
            return data;
          }
        }
        return data;
      },

      // Set data with TTL (default 24 hours instead of 1 hour)
      async set(store, key, value, ttl = 24 * 60 * 60 * 1000) {
        const data = {
          id: key,
          symbol: key.split('_')[0],
          data: this.compress(value),
          timestamp: Date.now(),
          expiresAt: Date.now() + ttl
        };

        try {
          // Try IndexedDB first
          if (this.db) {
            const tx = this.db.transaction(store, 'readwrite');
            await tx.objectStore(store).put(data);
            return true;
          }
        } catch (error) {
          console.warn('âš ï¸ IndexedDB write failed, falling back to localStorage');
        }

        // Fallback to localStorage
        try {
          localStorage.setItem(
            `re_advanced_${store}_${key}`,
            JSON.stringify({ ...data, data: value }) // Don't compress for localStorage
          );
          return true;
        } catch (error) {
          this.handleQuotaExceeded(error, store);
          return false;
        }
      },

      // Get data
      async get(store, key) {
        try {
          // Try IndexedDB first
          if (this.db) {
            const tx = this.db.transaction(store, 'readonly');
            const data = await tx.objectStore(store).get(key);

            if (data && data.expiresAt > Date.now()) {
              return this.decompress(data.data);
            }
            if (data) {
              // Clean up expired data
              this.remove(store, key);
            }
          }
        } catch (error) {
          console.warn('âš ï¸ IndexedDB read failed, falling back to localStorage');
        }

        // Fallback to localStorage
        try {
          const raw = localStorage.getItem(`re_advanced_${store}_${key}`);
          if (!raw) return null;

          const parsed = JSON.parse(raw);
          if (parsed.expiresAt > Date.now()) {
            return parsed.data;
          }
          localStorage.removeItem(`re_advanced_${store}_${key}`);
          return null;
        } catch {
          return null;
        }
      },

      // Remove specific key
      async remove(store, key) {
        try {
          if (this.db) {
            const tx = this.db.transaction(store, 'readwrite');
            await tx.objectStore(store).delete(key);
          }
        } catch { }
        try {
          localStorage.removeItem(`re_advanced_${store}_${key}`);
        } catch { }
      },

      // Clear expired data
      async cleanup(store) {
        if (!this.db) return;

        const tx = this.db.transaction(store, 'readwrite');
        const storeObj = tx.objectStore(store);
        const now = Date.now();

        let count = 0;
        await new Promise((resolve) => {
          const request = storeObj.openCursor();
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              if (cursor.value.expiresAt < now) {
                cursor.delete();
                count++;
              }
              cursor.continue();
            } else {
              resolve();
            }
          };
        });

        console.log(`ğŸ§¹ Cleaned up ${count} expired items from ${store}`);
      },

      // Handle quota exceeded
      handleQuotaExceeded(error, store) {
        console.warn(`âš ï¸ Storage quota exceeded for ${store}`);

        // Clear oldest 20% of data
        try {
          const keys = Object.keys(localStorage).filter(k => k.startsWith(`re_advanced_${store}_`));
          const items = keys.map(k => {
            try {
              const item = localStorage.getItem(k);
              return item ? { key: k, timestamp: JSON.parse(item).timestamp || 0 } : { key: k, timestamp: 0 };
            } catch {
              return { key: k, timestamp: 0 };
            }
          }).sort((a, b) => a.timestamp - b.timestamp);

          const toRemove = Math.ceil(items.length * 0.2);
          items.slice(0, toRemove).forEach(item => {
            try {
              localStorage.removeItem(item.key);
            } catch { }
          });

          console.log(`ğŸ§¹ Removed ${toRemove} oldest items`);
        } catch { }
      },

      // Get storage stats
      async stats() {
        const stats = { indexedDB: { total: 0, stores: {} }, localStorage: 0 };

        try {
          if (this.db) {
            for (const store of this.stores) {
              const tx = this.db.transaction(store, 'readonly');
              const count = await new Promise((resolve) => {
                const request = tx.objectStore(store).count();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve(0);
              });
              stats.indexedDB.stores[store] = count;
              stats.indexedDB.total += count;
            }
          }
        } catch { }

        try {
          stats.localStorage = Object.keys(localStorage).filter(k => k.startsWith('re_advanced_')).length;
        } catch { }

        return stats;
      }
    };

    // Initialize advanced storage
    AdvancedStorage.init();
    window.AdvancedStorage = AdvancedStorage;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REQUEST MANAGER - Deduplication & Batching
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const RequestManager = {
      pendingRequests: new Map(),
      batchQueue: [],
      batchTimer: null,
      BATCH_DELAY: 30, // 30ms batching window (faster response)
      MAX_BATCH_SIZE: 25, // Increased from 10 to 25 (FMP supports up to 100)

      // Deduplicate requests
      async fetchUnique(url, options = {}) {
        const key = `${url}_${JSON.stringify(options)}`;

        // If exact request is pending, return its promise
        if (this.pendingRequests.has(key)) {
          console.log(`ğŸ“‹ Using pending request for ${url}`);
          return this.pendingRequests.get(key);
        }

        // Create new promise
        const promise = fetchWithRetry(url, options)
          .finally(() => {
            // Clean up after completion
            setTimeout(() => this.pendingRequests.delete(key), 1000);
          });

        this.pendingRequests.set(key, promise);
        return promise;
      },

      // Batch multiple symbol requests
      batchFetch(apiEndpoint, symbols, params = {}) {
        return new Promise((resolve) => {
          const batchItem = {
            endpoint: apiEndpoint,
            symbols: Array.isArray(symbols) ? symbols : [symbols],
            params,
            resolve
          };

          this.batchQueue.push(batchItem);

          // Clear timer if exists
          if (this.batchTimer) clearTimeout(this.batchTimer);

          // Process batch after delay or when full
          if (this.batchQueue.length >= this.MAX_BATCH_SIZE) {
            this.processBatch();
          } else {
            this.batchTimer = setTimeout(() => this.processBatch(), this.BATCH_DELAY);
          }
        });
      },

      // Process batch queue
      async processBatch() {
        if (this.batchQueue.length === 0) return;

        const queue = [...this.batchQueue];
        this.batchQueue = [];
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
          this.batchTimer = null;
        }

        // Group by endpoint
        const byEndpoint = {};
        queue.forEach(item => {
          if (!byEndpoint[item.endpoint]) byEndpoint[item.endpoint] = [];
          byEndpoint[item.endpoint].push(item);
        });

        // Execute batches in parallel (multiple endpoints at once)
        const batchPromises = Object.entries(byEndpoint).map(async ([endpoint, items]) => {
          const allSymbols = items.flatMap(i => i.symbols);
          const uniqueSymbols = [...new Set(allSymbols)];

          try {
            // Split into chunks if > 50 symbols (FMP works best with <50 at a time)
            const chunks = [];
            for (let i = 0; i < uniqueSymbols.length; i += 50) {
              chunks.push(uniqueSymbols.slice(i, i + 50));
            }

            // Fetch all chunks in parallel
            const chunkResults = await Promise.all(
              chunks.map(async (chunk) => {
                // FIX: Symbols should be in path, not query parameter
                const batchUrl = `https://financialmodelingprep.com/stable/${endpoint}/${chunk.join(',')}?apikey=${API_KEYS.FMP}`;
                console.log(`ğŸš€ Batch fetching ${chunk.length} symbols for ${endpoint}`);
                const response = await this.fetchUnique(batchUrl);
                return await response.json();
              })
            );

            // Combine all chunk results
            const data = chunkResults.flat();

            // Resolve individual promises
            items.forEach(item => {
              const itemData = Array.isArray(data)
                ? data.filter(d => item.symbols.includes(d.symbol))
                : data;
              item.resolve({ data: itemData, success: true });
            });

          } catch (error) {
            console.error(`âŒ Batch fetch failed for ${endpoint}:`, error);
            items.forEach(item => item.resolve({ data: null, success: false }));
          }
        });

        // Wait for all batches to complete
        await Promise.all(batchPromises);
      },

      // Priority-based loading
      async loadWithPriority(symbols, priority = 'high') {
        const priorityWeights = { high: 1, medium: 2, low: 3 };
        const delay = priorityWeights[priority] * 100; // Stagger by priority

        await new Promise(resolve => setTimeout(resolve, delay));

        return this.batchFetch('quote', symbols);
      }
    };

    // Override the existing smartFetch for deduplication
    const originalSmartFetch = smartFetch;
    smartFetch = async function (endpoint, symbol, options = {}) {
      // Use batching for quote and profile endpoints
      if (endpoint.includes('quote') || endpoint.includes('profile')) {
        const result = await RequestManager.batchFetch(endpoint, symbol, options);
        return { data: result.data || [], source: 'batched' };
      }

      // Use deduplication for other requests
      const url = `https://financialmodelingprep.com/stable/${endpoint}?symbol=${symbol}&apikey=${API_KEYS.FMP}`;
      const response = await RequestManager.fetchUnique(url, options);
      const data = await response.json();
      return { data, source: 'deduplicated' };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PREFETCH MANAGER - Load Before User Needs It
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const PrefetchManager = {
      warming: false,
      warmupQueue: [],
      instantLoadComplete: false,

      // INSTANT LOAD: Serve all cached stocks immediately on page load (no API calls!)
      async loadAllFromCache() {
        console.log('âš¡ INSTANT LOAD: Loading all stocks from cache...');
        const startTime = performance.now();

        try {
          // Get all cached stock data from IndexedDB
          const cachedStocks = [];

          if (AdvancedStorage.db) {
            const tx = AdvancedStorage.db.transaction('stockData', 'readonly');
            const store = tx.objectStore('stockData');
            const allData = await new Promise((resolve, reject) => {
              const request = store.getAll();
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
            });

            // Filter for quote data (critical data)
            allData.forEach(item => {
              if (item.data?.critical && item.id && !item.id.includes('_')) {
                cachedStocks.push({
                  symbol: item.id,
                  ...item.data.critical
                });
              }
            });
          }

          // Also check localStorage for any additional cached data
          const localKeys = Object.keys(localStorage).filter(k => k.startsWith('re_advanced_stockData_'));
          localKeys.forEach(key => {
            try {
              const data = JSON.parse(localStorage.getItem(key));
              if (data?.data?.critical) {
                const symbol = key.replace('re_advanced_stockData_', '');
                if (!symbol.includes('_') && !cachedStocks.find(s => s.symbol === symbol)) {
                  cachedStocks.push({
                    symbol,
                    ...data.data.critical
                  });
                }
              }
            } catch (e) { /* ignore */ }
          });

          const duration = performance.now() - startTime;
          console.log(`âš¡ INSTANT LOAD: Loaded ${cachedStocks.length} stocks from cache in ${duration.toFixed(0)}ms`);
          this.instantLoadComplete = true;

          return cachedStocks;
        } catch (error) {
          console.warn('Instant load from cache failed:', error);
          return [];
        }
      },

      // Warm up cache on app load (only fetches missing data)
      async warmupDefaultStocks() {
        if (this.warming) return;
        this.warming = true;

        console.log('ğŸ”¥ Starting cache warmup (only missing data)...');

        // Priority 1: Watchlist stocks (if any) - only fetch if not cached
        const savedWatchlist = JSON.parse(localStorage.getItem('watchlist') || '[]');
        if (savedWatchlist.length > 0) {
          // OPTIMIZED: Check all in parallel instead of sequential
          const uncachedWatchlist = [];
          const watchlistChecks = savedWatchlist.slice(0, 20).map(async (symbol) => {
            const cached = await AdvancedStorage.get('stockData', symbol);
            return { symbol, cached: !!cached };
          });

          const results = await Promise.all(watchlistChecks);
          results.forEach(({ symbol, cached }) => {
            if (!cached) uncachedWatchlist.push(symbol);
          });

          if (uncachedWatchlist.length > 0) {
            console.log(`ğŸ“‹ Fetching ${uncachedWatchlist.length} uncached watchlist stocks`);
            await RequestManager.loadWithPriority(uncachedWatchlist, 'high');
          } else {
            console.log(`ğŸ“‹ All ${savedWatchlist.length} watchlist stocks already cached`);
          }

          // Also fetch chart data for watchlist (if not cached)
          savedWatchlist.slice(0, 10).forEach(symbol => {
            this.prefetchChartData(symbol, '1day');
          });
        }

        // Priority 2: Popular S&P 500 stocks - only fetch if not cached
        const popularStocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'COIN'];

        // OPTIMIZED: Parallel cache checks instead of sequential
        const uncachedPopular = [];
        const popularChecks = popularStocks.map(async (symbol) => {
          const cached = await AdvancedStorage.get('stockData', symbol);
          return { symbol, cached: !!cached };
        });

        const popularResults = await Promise.all(popularChecks);
        popularResults.forEach(({ symbol, cached }) => {
          if (!cached) uncachedPopular.push(symbol);
        });

        if (uncachedPopular.length > 0) {
          console.log(`ğŸ“ˆ Fetching ${uncachedPopular.length} uncached popular stocks`);
          await RequestManager.loadWithPriority(uncachedPopular, 'medium');
        } else {
          console.log(`ğŸ“ˆ All popular stocks already cached`);
        }

        // Priority 3: Sector data
        console.log('ğŸ¢ Pre-fetching sector averages');
        this.prefetchSectorData();

        this.warming = false;
        console.log('âœ… Cache warmup complete');
      },

      // Prefetch chart data in background
      async prefetchChartData(symbol, timeframe = '1day') {
        const cacheKey = `${symbol}_${timeframe}`;
        const cached = await AdvancedStorage.get('chartData', cacheKey);
        if (cached) return; // Already cached

        try {
          const response = await fetch(
            `https://financialmodelingprep.com/stable/historical-chart/${timeframe}?symbol=${symbol}&apikey=${API_KEYS.FMP}`
          );
          const data = await response.json();

          // Cache for 24 hours (chart data is stable)
          await AdvancedStorage.set('chartData', cacheKey, data, CACHE_CONFIG.CHART_DATA);
          console.log(`ğŸ’¾ Cached chart data for ${symbol} (${timeframe})`);
        } catch (error) {
          console.warn(`âš ï¸ Failed to prefetch chart for ${symbol}:`, error);
        }
      },

      // Prefetch sector averages - uses real cached/loaded stocks only
      async prefetchSectorData(loadedStocks = []) {
        if (!loadedStocks || loadedStocks.length === 0) {
          console.log('ğŸ“Š Skipping sector prefetch - no loaded stocks yet');
          return;
        }

        const sectors = [...new Set(loadedStocks.map(s => s.sector).filter(Boolean))];
        for (const sector of sectors) {
          const sectorStocks = loadedStocks.filter(s => s.sector === sector);
          if (sectorStocks.length === 0) continue;

          const avgMetrics = {
            pe: sectorStocks.reduce((sum, s) => sum + (parseFloat(s.pe) || 0), 0) / sectorStocks.length,
            roe: sectorStocks.reduce((sum, s) => sum + (parseFloat(s.roe) || 0), 0) / sectorStocks.length,
            grossMargin: sectorStocks.reduce((sum, s) => sum + (parseFloat(s.grossMargin) || 0), 0) / sectorStocks.length
          };

          await AdvancedStorage.set('analytics', `sector_${sector}`, avgMetrics, 7 * 24 * 60 * 60 * 1000);
        }
        console.log(`ğŸ“Š Cached sector averages for ${sectors.length} sectors`);
      },

      // Predictive fetch based on user behavior - uses real loaded stocks only
      async onStockViewed(symbol, loadedStocks = []) {
        // Fetch related stocks (same sector) from real loaded data
        const stock = loadedStocks.find(s => s.symbol === symbol);
        if (stock?.sector) {
          const related = loadedStocks.filter(s => s.sector === stock.sector && s.symbol !== symbol).slice(0, 5);
          if (related.length > 0) {
            console.log(`ğŸ”® Predictively fetching ${related.length} related stocks in ${stock.sector} sector`);
            related.forEach(s => this.prefetchChartData(s.symbol, '4hour'));
          }
        }

        // Preload next earnings date if available
        this.prefetchEarningsData(symbol);
      },

      // Prefetch earnings data
      async prefetchEarningsData(symbol) {
        try {
          const response = await fetch(
            `https://financialmodelingprep.com/stable/earnings?symbol=${symbol}&apikey=${API_KEYS.FMP}`
          );
          const data = await response.json();
          await AdvancedStorage.set('stockData', `${symbol}_earnings`, data, CACHE_CONFIG.EARNINGS_DATA);
        } catch (error) {
          console.warn(`âš ï¸ Failed to prefetch earnings for ${symbol}:`, error);
        }
      }
    };

    // Expose PrefetchManager for instant load feature
    window.PrefetchManager = PrefetchManager;

    // DELAYED WARMUP: Start only AFTER main loading completes (60 seconds)
    // This prevents API conflicts during initial load
    setTimeout(() => {
      if (!window.isFetchingStocks) {
        PrefetchManager.warmupDefaultStocks();
      } else {
        // Retry after another 30 seconds if still loading
        setTimeout(() => PrefetchManager.warmupDefaultStocks(), 30000);
      }
    }, 60000);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PERFORMANCE MONITOR - Track & Optimize
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const PerformanceMonitor = {
      metrics: [],

      track(operation, duration, success = true) {
        this.metrics.push({
          operation,
          duration,
          success,
          timestamp: Date.now(),
          apiCalls: API_STATS
        });

        // Keep only last 100 metrics
        if (this.metrics.length > 100) {
          this.metrics = this.metrics.slice(-100);
        }

        console.log(`âš¡ ${operation}: ${duration}ms ${success ? 'âœ…' : 'âŒ'}`);
      },

      // Calculate cache hit rate
      getCacheStats() {
        const total = this.metrics.length;
        const cached = this.metrics.filter(m => m.duration < 5).length; // <5ms = cache

        return {
          hitRate: total > 0 ? Math.round((cached / total) * 100) : 0,
          avgDuration: total > 0 ? Math.round(this.metrics.reduce((sum, m) => sum + m.duration, 0) / total) : 0,
          apiCalls: Object.entries(API_STATS).map(([api, stats]) => ({
            api,
            calls: stats.calls,
            failures: stats.failures,
            successRate: Math.round((1 - stats.failures / Math.max(1, stats.calls)) * 100)
          }))
        };
      },

      // Export performance report
      exportReport() {
        const stats = this.getCacheStats();
        const report = {
          timestamp: new Date().toISOString(),
          cacheHitRate: `${stats.hitRate}%`,
          averageLatency: `${stats.avgDuration}ms`,
          apiPerformance: stats.apiCalls,
          storageStats: AdvancedStorage.stats()
        };

        console.table(report.apiPerformance);
        console.log('ğŸ“Š Performance Report:', report);

        // Download as JSON
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `perf-report-${Date.now()}.json`;
        a.click();

        return report;
      },

      // Show loading indicators based on performance
      getLoadingRecommendation() {
        const stats = this.getCacheStats();

        if (stats.hitRate > 80) {
          return { strategy: 'aggressive', message: 'Cache is hot - use optimistic UI' };
        } else if (stats.hitRate > 50) {
          return { strategy: 'balanced', message: 'Moderate cache hit rate - show skeletons' };
        } else {
          return { strategy: 'conservative', message: 'Cache is cold - show loading spinners' };
        }
      }
    };

    // Add to window for debugging
    window.PerformanceMonitor = PerformanceMonitor;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OPTIMIZED STOCK LOADER - Load What You Need, When You Need It
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const OptimizedStockLoader = {
      // Stale-while-revalidate: serve cached data instantly, refresh in background
      STALE_WHILE_REVALIDATE: true,

      // Load critical data first, then enhance
      async loadStock(symbol) {
        const startTime = performance.now();

        // Phase 1: Critical data (price, change, volume) - uses stale-while-revalidate
        const critical = await this.loadCriticalData(symbol);

        // Phase 2: Fundamental data (PE, ROE, growth) - cached for 7 days
        this.loadFundamentalData(symbol).then(data => {
          this.mergeStockData(symbol, { fundamental: data });
        });

        // Phase 3: Technical data (RSI, SMA)
        this.loadTechnicalData(symbol).then(data => {
          this.mergeStockData(symbol, { technical: data });
        });

        // Phase 4: Non-critical (news, sentiment)
        this.loadEnhancementData(symbol);

        const duration = performance.now() - startTime;
        PerformanceMonitor.track(`loadStock:${symbol}`, duration);

        return critical;
      },

      async loadCriticalData(symbol) {
        // STALE-WHILE-REVALIDATE: Return cached data immediately, refresh in background
        const cached = await AdvancedStorage.get('stockData', symbol);

        if (cached && cached.critical) {
          // Check if data is stale (older than quote cache duration)
          const isStale = cached.timestamp && (Date.now() - cached.timestamp > Cache.getCacheDuration('QUOTE_DATA'));

          if (this.STALE_WHILE_REVALIDATE && isStale) {
            // Return stale data immediately, refresh in background
            console.log(`âš¡ Serving stale data for ${symbol}, refreshing in background...`);
            this.refreshInBackground(symbol);
          }

          return cached.critical;
        }

        // No cache - fetch from API
        const response = await RequestManager.batchFetch('quote', symbol);
        const data = Array.isArray(response.data) ? response.data[0] : response.data;

        // Cache with timestamp for stale checking
        const ttl = Cache.getCacheDuration('QUOTE_DATA');
        await AdvancedStorage.set('stockData', symbol, {
          critical: data,
          timestamp: Date.now()
        }, ttl);

        return data;
      },

      // Background refresh without blocking UI
      async refreshInBackground(symbol) {
        try {
          const response = await RequestManager.batchFetch('quote', symbol);
          const data = Array.isArray(response.data) ? response.data[0] : response.data;

          if (data) {
            const ttl = Cache.getCacheDuration('QUOTE_DATA');
            await AdvancedStorage.set('stockData', symbol, {
              critical: data,
              timestamp: Date.now()
            }, ttl);
            console.log(`ğŸ”„ Background refresh complete for ${symbol}`);
          }
        } catch (error) {
          console.warn(`Background refresh failed for ${symbol}:`, error);
        }
      },

      async loadFundamentalData(symbol) {
        // CACHE-FIRST: Fundamentals rarely change, serve from cache when available
        const cached = await AdvancedStorage.get('stockData', `${symbol}_fundamentals`);
        if (cached) {
          // Fundamentals cached for 7 days - no background refresh needed
          return cached;
        }

        const [profile, ratios, growth] = await Promise.all([
          fetch(`https://financialmodelingprep.com/stable/profile/${symbol}?apikey=${API_KEYS.FMP}`).then(r => r.json()),
          fetch(`https://financialmodelingprep.com/stable/ratios?symbol=${symbol}&limit=1&apikey=${API_KEYS.FMP}`).then(r => r.json()),
          fetch(`https://financialmodelingprep.com/stable/financial-growth?symbol=${symbol}&limit=5&apikey=${API_KEYS.FMP}`).then(r => r.json())
        ]);

        const data = {
          ...profile[0],
          ...ratios[0],
          ...growth[0]
        };

        // Cache for 7 days (CACHE_CONFIG.STOCK_DATA)
        await AdvancedStorage.set('stockData', `${symbol}_fundamentals`, data, CACHE_CONFIG.STOCK_DATA);
        return data;
      },

      async loadTechnicalData(symbol) {
        // STALE-WHILE-REVALIDATE for technicals too
        const cached = await AdvancedStorage.get('stockData', `${symbol}_technical`);
        if (cached) {
          // Check staleness - refresh in background if old
          const age = cached.timestamp ? (Date.now() - cached.timestamp) : Infinity;
          if (age > Cache.getCacheDuration('QUOTE_DATA')) {
            this.refreshTechnicalInBackground(symbol);
          }
          return cached;
        }

        return await this.fetchTechnicalData(symbol);
      },

      async fetchTechnicalData(symbol) {
        // Use multiple sources for technicals
        const [taData, quote] = await Promise.all([
          fetch(`https://financialmodelingprep.com/stable/technical-indicator/1hour?symbol=${symbol}&apikey=${API_KEYS.FMP}`).then(r => r.json()),
          fetch(`https://financialmodelingprep.com/stable/quote/${symbol}?apikey=${API_KEYS.FMP}`).then(r => r.json())
        ]);

        const data = {
          rsi: quote[0]?.rsi || taData[0]?.rsi,
          sma20: taData[0]?.sma20,
          sma50: taData[0]?.sma50,
          macd: taData[0]?.macd,
          timestamp: Date.now()
        };

        await AdvancedStorage.set('stockData', `${symbol}_technical`, data, Cache.getCacheDuration('QUOTE_DATA'));
        return data;
      },

      async refreshTechnicalInBackground(symbol) {
        try {
          await this.fetchTechnicalData(symbol);
          console.log(`ğŸ”„ Technical data refreshed for ${symbol}`);
        } catch (e) {
          console.warn(`Technical refresh failed for ${symbol}`);
        }
      },

      // LEGACY: Keep for compatibility
      async loadTechnicalDataLegacy(symbol) {
        const cached = await AdvancedStorage.get('stockData', `${symbol}_technical`);
        if (cached) return cached;

        // Use multiple sources for technicals
        const [taData, quote] = await Promise.all([
          fetch(`https://financialmodelingprep.com/stable/technical-indicator/1hour?symbol=${symbol}&apikey=${API_KEYS.FMP}`).then(r => r.json()),
          fetch(`https://financialmodelingprep.com/stable/quote/${symbol}?apikey=${API_KEYS.FMP}`).then(r => r.json())
        ]);

        const data = {
          rsi: quote[0]?.rsi || taData[0]?.rsi,
          sma20: taData[0]?.sma20,
          sma50: taData[0]?.sma50,
          macd: taData[0]?.macd
        };

        await AdvancedStorage.set('stockData', `${symbol}_technical`, data, Cache.getCacheDuration('QUOTE_DATA'));
        return data;
      },

      async loadEnhancementData(symbol) {
        // Non-blocking background load
        Promise.all([
          this.prefetchNewsData(symbol),
          this.prefetchSocialData(symbol)
        ]);
      },

      async prefetchNewsData(symbol) {
        // Placeholder for news prefetching
        return Promise.resolve();
      },

      async prefetchSocialData(symbol) {
        // Placeholder for social data prefetching
        return Promise.resolve();
      },

      mergeStockData(symbol, updates) {
        // Merge incremental updates into existing data
        // This would integrate with your React state management
        console.log(`ğŸ“¦ Merging updates for ${symbol}:`, Object.keys(updates));
      }
    };

    window.OptimizedStockLoader = OptimizedStockLoader;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PREDICTIVE PREFETCHER - Learn User Patterns
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class PredictivePrefetcher {
      constructor() {
        this.userPatterns = this.loadPatterns();
        this.prefetchQueue = [];
        this.maxPrefetch = 5;
      }

      loadPatterns() {
        return JSON.parse(localStorage.getItem('re_user_patterns') || '{}');
      }

      savePatterns() {
        localStorage.setItem('re_user_patterns', JSON.stringify(this.userPatterns));
      }

      recordView(symbol) {
        if (!this.userPatterns[symbol]) {
          this.userPatterns[symbol] = { views: 0, lastViewed: Date.now() };
        }
        this.userPatterns[symbol].views++;
        this.userPatterns[symbol].lastViewed = Date.now();

        // Keep only top 50 most viewed symbols
        const sorted = Object.entries(this.userPatterns)
          .sort((a, b) => b[1].views - a[1].views)
          .slice(0, 50);

        this.userPatterns = Object.fromEntries(sorted);
        this.savePatterns();

        // Trigger prefetch for related symbols
        this.schedulePrefetch(symbol);
      }

      schedulePrefetch(currentSymbol) {
        // Get similar symbols (same sector, similar market cap)
        const topSymbols = Object.keys(this.userPatterns)
          .filter(s => s !== currentSymbol)
          .slice(0, this.maxPrefetch);

        topSymbols.forEach(symbol => {
          if (!this.prefetchQueue.includes(symbol)) {
            this.prefetchQueue.push(symbol);
          }
        });

        // Process queue in background
        setTimeout(() => this.processPrefetchQueue(), 100);
      }

      async processPrefetchQueue() {
        while (this.prefetchQueue.length > 0) {
          const symbol = this.prefetchQueue.shift();

          // Check if cache is stale or missing
          const cached = Cache.get(symbol);
          if (!cached || isStaleTimestamp(cached.timestamp, 'quote')) {
            // Fetch in background with low priority
            setTimeout(async () => {
              try {
                const result = await smartFetch('quote', symbol);
                if (result?.data) {
                  Cache.set(symbol, result.data, 'quote');
                }
              } catch (error) {
                // Silent fail for prefetch
              }
            }, Math.random() * 3000); // Random delay to avoid rate limits
          }
        }
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMMON DATA STORE - Shared Data Across All Stocks
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const CommonDataStore = {
      // Store frequently used data in a single key
      sectors: null,
      indices: null,
      marketStatus: null,

      init() {
        this.loadCommonData();
        // Refresh every 30 minutes
        setInterval(() => this.refreshCommonData(), 30 * 60 * 1000);
      },

      loadCommonData() {
        try {
          const data = localStorage.getItem('re_common_data');
          if (data) {
            const parsed = JSON.parse(data);
            this.sectors = parsed.sectors || {};
            this.indices = parsed.indices || {};
            this.marketStatus = parsed.marketStatus || {};
          }
        } catch (error) {
          console.warn('Failed to load common data:', error);
        }
      },

      saveCommonData() {
        const data = {
          sectors: this.sectors,
          indices: this.indices,
          marketStatus: this.marketStatus,
          timestamp: Date.now()
        };

        try {
          localStorage.setItem('re_common_data', JSON.stringify(data));
        } catch (error) {
          console.warn('Failed to save common data:', error);
        }
      },

      async refreshCommonData() {
        // Fetch common data once and share across all stocks
        try {
          // Fetch sector performance
          const sectorsResponse = await fetch(
            `https://financialmodelingprep.com/stable/sector-performance?apikey=${API_KEYS.FMP}`
          );
          if (sectorsResponse.ok) {
            this.sectors = await sectorsResponse.json();
          }

          // Fetch market indices
          const indices = ['^GSPC', '^DJI', '^IXIC', '^RUT'];
          const indexPromises = indices.map(symbol =>
            smartFetch('quote', symbol).catch(() => null)
          );

          const indexResults = await Promise.all(indexPromises);
          this.indices = indexResults.filter(r => r).map(r => r.data[0]);

          this.saveCommonData();
        } catch (error) {
          console.warn('Common data refresh failed:', error);
        }
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEB WORKER - Background Data Fetching
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Create web worker for background fetching
    const createDataWorker = () => {
      if (typeof Worker !== 'undefined') {
        const workerCode = `
          self.onmessage = function(e) {
            const { symbols, apiKey } = e.data;
            
            // Process in background
            symbols.forEach(symbol => {
              fetch(\`https://financialmodelingprep.com/stable/quote/\${symbol}?apikey=\${apiKey}\`)
                .then(r => r.json())
                .then(data => {
                  self.postMessage({ symbol, data });
                })
                .catch(error => {
                  // Silent fail
                });
            });
          };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
      }
      return null;
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BATCH API PROCESSOR - Efficient Batch Requests
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class BatchAPIProcessor {
      constructor() {
        this.batchSize = 5; // Max symbols per batch
        this.batchDelay = 100; // ms between batches
        this.pendingRequests = new Map();
      }

      async batchFetch(symbols, endpoint = 'quote') {
        const results = {};
        const batches = [];

        // Create batches
        for (let i = 0; i < symbols.length; i += this.batchSize) {
          batches.push(symbols.slice(i, i + this.batchSize));
        }

        // Process batches with delay
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          const batchResults = await this.processBatch(batch, endpoint);
          Object.assign(results, batchResults);

          // Delay between batches (except last)
          if (i < batches.length - 1) {
            await new Promise(resolve => setTimeout(resolve, this.batchDelay));
          }
        }

        return results;
      }

      async processBatch(symbols, endpoint) {
        // Use backend proxy for batch quotes
        if (endpoint === 'quote' && symbols.length > 1) {
          try {
            const response = await fetch(`${window.API_BASE_URL}/api/quotes/batch`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ symbols })
            });

            if (response.ok) {
              const data = await response.json();
              const result = {};
              symbols.forEach((symbol, index) => {
                result[symbol] = Array.isArray(data) ? data[index] : null;
              });
              return result;
            }
          } catch (error) {
            // Fall back to individual
          }
        }

        // Individual fallback
        const promises = symbols.map(symbol =>
          smartFetch(endpoint, symbol).then(r => r.data).catch(() => null)
        );

        const results = await Promise.all(promises);
        const mapped = {};
        symbols.forEach((symbol, i) => {
          mapped[symbol] = results[i];
        });

        return mapped;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STORAGE MANAGER - Adaptive Storage Management
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const StorageManager = {
      modes: ['optimal', 'degraded', 'minimal'],
      currentMode: 'optimal',

      init() {
        this.detectStorageCapabilities();
        this.setupFallbacks();
      },

      detectStorageCapabilities() {
        try {
          // Test storage
          localStorage.setItem('re_test', 'test');
          localStorage.removeItem('re_test');

          // Check available space
          let testData = '';
          for (let i = 0; i < 1024; i++) {
            testData += '1234567890';
          }

          try {
            localStorage.setItem('re_space_test', testData);
            localStorage.removeItem('re_space_test');
            this.currentMode = 'optimal';
          } catch {
            this.currentMode = 'degraded';
          }
        } catch (error) {
          this.currentMode = 'minimal';
        }
      },

      setupFallbacks() {
        switch (this.currentMode) {
          case 'optimal':
            // Full caching enabled
            CACHE_CONFIG.MAX_CACHE_SIZE = 500;
            break;

          case 'degraded':
            // Reduced caching
            CACHE_CONFIG.MAX_CACHE_SIZE = 100;
            CACHE_CONFIG.STOCK_DATA = 30 * 60 * 1000; // 30 min
            CACHE_CONFIG.QUOTE_DATA = 5 * 60 * 1000;  // 5 min
            break;

          case 'minimal':
            // Minimal caching
            CACHE_CONFIG.MAX_CACHE_SIZE = 20;
            CACHE_CONFIG.STOCK_DATA = 10 * 60 * 1000; // 10 min
            CACHE_CONFIG.QUOTE_DATA = 2 * 60 * 1000;  // 2 min
            break;
        }
      },

      getItem(key) {
        try {
          return localStorage.getItem(key);
        } catch {
          return null;
        }
      },

      setItem(key, value) {
        try {
          localStorage.setItem(key, value);
          return true;
        } catch {
          // Try to make space
          this.emergencyCleanup();
          try {
            localStorage.setItem(key, value);
            return true;
          } catch {
            return false;
          }
        }
      },

      emergencyCleanup() {
        // Remove oldest 50% of cache
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith(CACHE_CONFIG.CACHE_VERSION)) {
            keys.push(key);
          }
        }

        // Remove half
        const toRemove = Math.floor(keys.length / 2);
        for (let i = 0; i < toRemove; i++) {
          try {
            localStorage.removeItem(keys[i]);
          } catch { }
        }
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIORITY LOADER - Load Critical Data First
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class PriorityLoader {
      constructor() {
        this.priorities = {
          critical: ['price', 'changePct', 'symbol', 'name'],
          high: ['pe', 'roe', 'volume', 'marketCap'],
          medium: ['rsi', 'beta', 'debtToEquity', 'currentRatio'],
          low: ['revenueGrowth', 'netMargin', 'analystRating', 'dividendYield']
        };
      }

      async loadStockWithPriority(symbol, priority = 'critical') {
        const cached = Cache.get(symbol);
        if (cached) {
          // Return cached data immediately
          const result = { ...cached };

          // If we need more data than cached, fetch in background
          if (priority !== 'critical' && this.needsEnhancedData(cached, priority)) {
            setTimeout(() => this.loadEnhancedData(symbol), 0);
          }

          return result;
        }

        // Load critical data first
        const criticalData = await this.fetchPriorityData(symbol, 'critical');
        if (criticalData) {
          Cache.set(symbol, criticalData);
        }

        // Load other priorities in background
        if (priority !== 'critical') {
          setTimeout(() => this.loadEnhancedData(symbol, priority), 100);
        }

        return criticalData;
      }

      async fetchPriorityData(symbol, priority) {
        const fields = this.getFieldsForPriority(priority);

        // Build API call with only needed fields
        // Use backend proxy for single quote
        try {
          const response = await fetch(`${window.API_BASE_URL}/api/quote/${symbol}`);
          if (response.ok) {
            const data = await response.json();
            return this.filterDataByPriority(Array.isArray(data) ? data[0] : data, fields);
          }
        } catch (error) {
          // Fallback
        }

        return null;
      }

      async loadEnhancedData(symbol, priority = 'high') {
        const fields = this.getFieldsForPriority(priority);
        const url = `https://financialmodelingprep.com/stable/profile/${symbol}?apikey=${API_KEYS.FMP}`;

        try {
          const response = await fetch(url);
          if (response.ok) {
            const data = await response.json();
            const enhanced = this.filterDataByPriority(Array.isArray(data) ? data[0] : data, fields);

            // Update cache
            const cached = Cache.get(symbol) || {};
            Cache.set(symbol, { ...cached, ...enhanced });
          }
        } catch (error) {
          // Silent fail for background loading
        }
      }

      getFieldsForPriority(priority) {
        return this.priorities[priority] || this.priorities.critical;
      }

      filterDataByPriority(data, fields) {
        if (!data) return {};
        const filtered = {};
        fields.forEach(field => {
          if (data[field] !== undefined) {
            filtered[field] = data[field];
          }
        });
        return filtered;
      }

      needsEnhancedData(cachedData, requestedPriority) {
        const requestedFields = this.getFieldsForPriority(requestedPriority);
        return requestedFields.some(field => cachedData[field] === undefined);
      }
    }

    // Initialize optimizations
    StorageManager.init();
    CommonDataStore.init();
    const predictivePrefetcher = new PredictivePrefetcher();
    const priorityLoader = new PriorityLoader();
    const batchProcessor = new BatchAPIProcessor();

    // Helper functions
    async function loadStockData(symbol) {
      // Use priority loader for immediate critical data
      const criticalData = await priorityLoader.loadStockWithPriority(symbol, 'critical');

      // Record for prefetching
      predictivePrefetcher.recordView(symbol);

      return criticalData;
    }

    async function loadMultipleStocks(symbols) {
      return batchProcessor.batchFetch(symbols, 'quote');
    }

    // Make available globally
    window.predictivePrefetcher = predictivePrefetcher;
    window.priorityLoader = priorityLoader;
    window.batchProcessor = batchProcessor;
    window.loadStockData = loadStockData;
    window.loadMultipleStocks = loadMultipleStocks;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SECTOR-AWARE AI SCORING CONFIGURATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const SECTOR_METRICS = {
      'Technology': {
        pe_base: 28,
        pe_acceptable: 35,
        roe_target: 20,
        roe_excellent: 30,
        growth_target: 15,
        growth_excellent: 25,
        margin_target: 25
      },
      'Financial Services': {
        pe_base: 12,
        pe_acceptable: 15,
        roe_target: 12,
        roe_excellent: 18,
        growth_target: 5,
        growth_excellent: 10,
        margin_target: 30
      },
      'Healthcare': {
        pe_base: 22,
        pe_acceptable: 28,
        roe_target: 15,
        roe_excellent: 25,
        growth_target: 10,
        growth_excellent: 18,
        margin_target: 20
      },
      'Consumer Cyclical': {
        pe_base: 20,
        pe_acceptable: 25,
        roe_target: 15,
        roe_excellent: 22,
        growth_target: 8,
        growth_excellent: 15,
        margin_target: 15
      },
      'Consumer Defensive': {
        pe_base: 18,
        pe_acceptable: 22,
        roe_target: 18,
        roe_excellent: 25,
        growth_target: 5,
        growth_excellent: 10,
        margin_target: 12
      },
      'Energy': {
        pe_base: 15,
        pe_acceptable: 20,
        roe_target: 12,
        roe_excellent: 20,
        growth_target: 5,
        growth_excellent: 12,
        margin_target: 10
      },
      'Industrials': {
        pe_base: 18,
        pe_acceptable: 23,
        roe_target: 14,
        roe_excellent: 20,
        growth_target: 7,
        growth_excellent: 12,
        margin_target: 12
      },
      'Communication Services': {
        pe_base: 25,
        pe_acceptable: 30,
        roe_target: 18,
        roe_excellent: 25,
        growth_target: 12,
        growth_excellent: 20,
        margin_target: 20
      },
      'Default': {
        pe_base: 20,
        pe_acceptable: 25,
        roe_target: 15,
        roe_excellent: 22,
        growth_target: 10,
        growth_excellent: 18,
        margin_target: 15
      }
    };

    // Get sector benchmarks with fallback
    function getSectorBenchmarks(sector) {
      return SECTOR_METRICS[sector] || SECTOR_METRICS['Default'];
    }



    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: COMMERCIAL FEATURES - USER ACCOUNT SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const UserManager = {
      isLoggedIn() {
        return localStorage.getItem('re_user_id') !== null;
      },

      getCurrentUser() {
        const userId = localStorage.getItem('re_user_id');
        if (!userId) return null;

        try {
          return JSON.parse(localStorage.getItem(`re_user_${userId}`));
        } catch {
          return null;
        }
      },

      register(email, password, name) {
        return new Promise((resolve, reject) => {
          try {
            if (!email || !password || !name) {
              reject('All fields are required');
              return;
            }

            const existingUsers = this.getAllUsers();
            if (existingUsers.find(u => u.email === email)) {
              reject('Email already registered');
              return;
            }

            const userId = 'user_' + Date.now() + Math.random().toString(36).substr(2, 9);
            const user = {
              id: userId,
              email,
              name,
              createdAt: new Date().toISOString(),
              lastLogin: new Date().toISOString(),
              preferences: {
                theme: 'dark',
                defaultView: 'beginner',
                notifications: true,
                riskTolerance: 'moderate'
              },
              investmentProfile: {
                experience: 'beginner',
                goals: [],
                timeHorizon: 'medium'
              },
              subscription: {
                tier: 'free',
                expiresAt: null,
                features: ['basic_screening', 'watchlist', 'portfolio_tracking']
              }
            };

            localStorage.setItem('re_user_id', userId);
            localStorage.setItem(`re_user_${userId}`, JSON.stringify(user));
            this.initializeUserData(userId);

            resolve(user);
          } catch (error) {
            reject('Registration failed');
          }
        });
      },

      login(email, password) {
        return new Promise((resolve, reject) => {
          try {
            const users = this.getAllUsers();
            const user = users.find(u => u.email === email);

            if (!user) {
              reject('User not found');
              return;
            }

            if (!password) {
              reject('Password required');
              return;
            }

            user.lastLogin = new Date().toISOString();
            localStorage.setItem(`re_user_${user.id}`, JSON.stringify(user));
            localStorage.setItem('re_user_id', user.id);

            resolve(user);
          } catch (error) {
            reject('Login failed');
          }
        });
      },

      logout() {
        localStorage.removeItem('re_user_id');
      },

      updatePreferences(preferences) {
        const user = this.getCurrentUser();
        if (!user) return null;
        user.preferences = { ...user.preferences, ...preferences };
        localStorage.setItem(`re_user_${user.id}`, JSON.stringify(user));
        return user;
      },

      updateInvestmentProfile(profile) {
        const user = this.getCurrentUser();
        if (!user) return null;
        user.investmentProfile = { ...user.investmentProfile, ...profile };
        localStorage.setItem(`re_user_${user.id}`, JSON.stringify(user));
        return user;
      },

      getAllUsers() {
        const users = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('re_user_') && !key.endsWith('_data')) {
            try {
              users.push(JSON.parse(localStorage.getItem(key)));
            } catch { }
          }
        }
        return users;
      },

      initializeUserData(userId) {
        const userData = {
          watchlist: [],
          portfolio: [],
          savedScreens: [],
          alerts: [],
          learningProgress: {
            completedLessons: [],
            currentStreak: 0,
            totalPoints: 0
          }
        };
        localStorage.setItem(`re_user_${userId}_data`, JSON.stringify(userData));
      },

      getUserData() {
        const user = this.getCurrentUser();
        if (!user) return null;

        try {
          const data = localStorage.getItem(`re_user_${user.id}_data`);
          if (!data) {
            this.initializeUserData(user.id);
            return JSON.parse(localStorage.getItem(`re_user_${user.id}_data`));
          }
          return JSON.parse(data);
        } catch {
          this.initializeUserData(user.id);
          return JSON.parse(localStorage.getItem(`re_user_${user.id}_data`));
        }
      },

      updateUserData(data) {
        const user = this.getCurrentUser();
        if (!user) return null;
        const currentData = this.getUserData();
        const newData = { ...currentData, ...data };
        localStorage.setItem(`re_user_${user.id}_data`, JSON.stringify(newData));
        return newData;
      }
    };


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: SUBSCRIPTION SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const SubscriptionManager = {
      TIERS: {
        free: {
          name: 'Free',
          price: 0,
          limits: {
            stocksPerScreen: 20,
            watchlistItems: 10,
            portfolioItems: 5,
            alerts: 3,
            apiCallsPerDay: 100
          },
          features: [
            'Basic stock screening',
            'Watchlist (10 stocks)',
            'Portfolio tracking (5 stocks)',
            'Price alerts (3)',
            'Community access'
          ]
        },
        premium: {
          name: 'Premium',
          price: 9.99,
          limits: {
            stocksPerScreen: 100,
            watchlistItems: 50,
            portfolioItems: 25,
            alerts: 25,
            apiCallsPerDay: 1000
          },
          features: [
            'Advanced stock screening',
            'Unlimited watchlist',
            'Portfolio tracking (25 stocks)',
            'Price alerts (25)',
            'Real-time data',
            'Advanced analytics',
            'Priority support'
          ]
        },
        pro: {
          name: 'Pro',
          price: 19.99,
          limits: {
            stocksPerScreen: 500,
            watchlistItems: 200,
            portfolioItems: 100,
            alerts: 100,
            apiCallsPerDay: 10000
          },
          features: [
            'Everything in Premium',
            'API access',
            'Custom screening criteria',
            'Portfolio optimization',
            'Tax loss harvesting',
            'Dedicated support'
          ]
        }
      },

      getCurrentSubscription() {
        const user = UserManager.getCurrentUser();
        if (!user) return this.TIERS.free;
        const tier = user.subscription?.tier || 'free';
        return { ...this.TIERS[tier], tier };
      },

      hasFeature(feature) {
        const subscription = this.getCurrentSubscription();
        return subscription.features.includes(feature);
      },

      checkLimit(limitType, currentCount) {
        const subscription = this.getCurrentSubscription();
        const limit = subscription.limits[limitType];
        return currentCount < limit;
      },

      upgrade(tier) {
        return new Promise((resolve, reject) => {
          const user = UserManager.getCurrentUser();
          if (!user) {
            reject('User not logged in');
            return;
          }

          if (!this.TIERS[tier]) {
            reject('Invalid tier');
            return;
          }

          user.subscription = {
            tier: tier,
            expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
            features: this.TIERS[tier].features
          };

          localStorage.setItem(`re_user_${user.id}`, JSON.stringify(user));
          resolve(user.subscription);
        });
      }
    };


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: BEGINNER MODE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const BeginnerMode = {
      SIMPLIFIED_METRICS: [
        { key: 'price', label: 'Price', explanation: 'Current stock price' },
        { key: 'changePct', label: 'Today\'s Change', explanation: 'Price change today' },
        { key: 'pe', label: 'P/E Ratio', explanation: 'Price Ã· Earnings. Lower may be better value' },
        { key: 'roe', label: 'ROE', explanation: 'Return on Equity. Higher is better' },
        { key: 'aiScore', label: 'AI Score', explanation: 'Overall rating from our analysis' }
      ],

      EXPLANATIONS: {
        pe: "Think of P/E like a price tag for earnings. A P/E of 20 means you're paying $20 for each $1 of company earnings.",
        roe: "ROE measures how efficiently a company uses your money. 15%+ is excellent.",
        debtToEquity: "This shows how much debt a company has compared to its value. Lower is safer.",
        rsi: "RSI measures if a stock is overbought (above 70) or oversold (below 30).",
        marketCap: "Market Cap is the total value of all the company's shares. Larger companies are usually more stable.",
        volume: "Volume shows how many shares were traded. Higher volume means more interest in the stock.",
        changePct: "This shows how much the stock price moved today. Green (positive) is up, red (negative) is down."
      },

      shouldShowBeginnerMode() {
        const user = UserManager.getCurrentUser();
        if (!user) return true;
        return user.preferences?.defaultView === 'beginner' ||
          user.investmentProfile?.experience === 'beginner';
      },

      getSimplifiedView(stock) {
        return this.SIMPLIFIED_METRICS.map(metric => ({
          ...metric,
          value: stock[metric.key],
          formattedValue: this.formatValue(stock[metric.key], metric.key)
        }));
      },

      formatValue(value, key) {
        if (value == null || isNaN(value)) return 'â€”';

        switch (key) {
          case 'price': return `$${value.toFixed(2)}`;
          case 'changePct': return `${value > 0 ? '+' : ''}${value.toFixed(2)}%`;
          case 'pe': return value.toFixed(1);
          case 'roe': return `${value.toFixed(1)}%`;
          case 'aiScore': return `${Math.round(value)}/100`;
          default: return value.toString();
        }
      },

      getExplanation(key) {
        return this.EXPLANATIONS[key] || 'No explanation available.';
      }
    };


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FINANCIAL GLOSSARY - Tooltips for key metrics
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const FINANCIAL_GLOSSARY = {
      'P/E': '<strong>Price-to-Earnings Ratio</strong><br>Shows how much investors pay for $1 of earnings.<br><em>Lower = potentially better value</em>',
      'ROE': '<strong>Return on Equity</strong><br>Measures how efficiently a company uses shareholder money.<br><em>15%+ is excellent</em>',
      'Market Cap': '<strong>Market Capitalization</strong><br>Total value of all company shares.<br><em>Large cap: $10B+, Mid: $2-10B, Small: <$2B</em>',
      'Revenue Growth': '<strong>Revenue Growth Rate</strong><br>Year-over-year sales increase.<br><em>10%+ is strong growth</em>',
      'Net Margin': '<strong>Net Profit Margin</strong><br>What % of revenue becomes profit.<br><em>20%+ is excellent</em>',
      'Debt/Equity': '<strong>Debt-to-Equity Ratio</strong><br>Company debt vs shareholder equity.<br><em>Lower = less financial risk</em>',
      'RSI': '<strong>Relative Strength Index</strong><br>Momentum indicator (0-100).<br><em>>70 = overbought, <30 = oversold</em>',
      'AI Score': '<strong>AI Composite Score</strong><br>Combines fundamentals, technicals & risk.<br><em>80+ = Strong Buy, 60-80 = Buy, 40-60 = Hold</em>',
      'Confidence': '<strong>AI Confidence Level</strong><br>How certain the AI is about its rating.<br><em>Higher = more reliable signal</em>',
      'Current Ratio': '<strong>Current Ratio</strong><br>Can the company pay short-term debts?<br><em>1.5+ = healthy liquidity</em>',
      'Gross Margin': '<strong>Gross Profit Margin</strong><br>Revenue minus cost of goods sold.<br><em>40%+ is strong</em>',
      'Dividend Yield': '<strong>Dividend Yield</strong><br>Annual dividend as % of stock price.<br><em>3-6% is attractive for income</em>'
    };


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEMO MODE - Sample Stock Data
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const DEMO_STOCKS = [
      {
        symbol: 'AAPL', name: 'Apple Inc.', price: 182.45, changePct: 2.34,
        pe: 28.5, roe: 147.2, revenueGrowth: 16.3, grossMargin: 44.1,
        netMargin: 25.3, debtToEquity: 1.8, currentRatio: 1.0,
        marketCap: 2.85e12, volume: 52431000, rsi: 58,
        sector: 'Technology', index: 'S&P500'
      },
      {
        symbol: 'MSFT', name: 'Microsoft Corporation', price: 378.91, changePct: 1.87,
        pe: 34.2, roe: 38.4, revenueGrowth: 13.1, grossMargin: 69.8,
        netMargin: 34.1, debtToEquity: 0.4, currentRatio: 1.8,
        marketCap: 2.81e12, volume: 23456000, rsi: 62,
        sector: 'Technology', index: 'S&P500'
      },
      {
        symbol: 'GOOGL', name: 'Alphabet Inc.', price: 141.23, changePct: 1.45,
        pe: 24.8, roe: 25.1, revenueGrowth: 11.2, grossMargin: 56.9,
        netMargin: 23.7, debtToEquity: 0.1, currentRatio: 2.6,
        marketCap: 1.78e12, volume: 28901000, rsi: 54,
        sector: 'Technology', index: 'S&P500'
      },
      {
        symbol: 'NVDA', name: 'NVIDIA Corporation', price: 495.22, changePct: 3.12,
        pe: 72.1, roe: 74.3, revenueGrowth: 126.0, grossMargin: 72.4,
        netMargin: 48.9, debtToEquity: 0.3, currentRatio: 4.1,
        marketCap: 1.22e12, volume: 45678000, rsi: 68,
        sector: 'Technology', index: 'NASDAQ100'
      },
      {
        symbol: 'AMZN', name: 'Amazon.com Inc.', price: 151.94, changePct: 0.89,
        pe: 58.3, roe: 16.8, revenueGrowth: 10.8, grossMargin: 48.1,
        netMargin: 5.7, debtToEquity: 0.7, currentRatio: 1.0,
        marketCap: 1.57e12, volume: 39012000, rsi: 51,
        sector: 'Consumer', index: 'S&P500'
      },
      {
        symbol: 'TSLA', name: 'Tesla Inc.', price: 238.72, changePct: -1.23,
        pe: 62.4, roe: 22.4, revenueGrowth: 18.8, grossMargin: 18.2,
        netMargin: 14.5, debtToEquity: 0.1, currentRatio: 1.7,
        marketCap: 758e9, volume: 98234000, rsi: 45,
        sector: 'Consumer', index: 'NASDAQ100'
      },
      {
        symbol: 'META', name: 'Meta Platforms Inc.', price: 352.89, changePct: 2.67,
        pe: 26.1, roe: 30.2, revenueGrowth: 23.4, grossMargin: 81.5,
        netMargin: 29.1, debtToEquity: 0.0, currentRatio: 2.9,
        marketCap: 895e9, volume: 15678000, rsi: 65,
        sector: 'Technology', index: 'S&P500'
      },
      {
        symbol: 'BRK.B', name: 'Berkshire Hathaway', price: 383.45, changePct: 0.34,
        pe: 8.9, roe: 14.2, revenueGrowth: 8.1, grossMargin: 22.3,
        netMargin: 16.8, debtToEquity: 0.3, currentRatio: 1.4,
        marketCap: 878e9, volume: 3421000, rsi: 52,
        sector: 'Financials', index: 'S&P500'
      },
      {
        symbol: 'JPM', name: 'JPMorgan Chase', price: 155.67, changePct: 1.12,
        pe: 11.3, roe: 15.8, revenueGrowth: 9.4, grossMargin: 35.2,
        netMargin: 28.9, debtToEquity: 1.2, currentRatio: 1.1,
        marketCap: 456e9, volume: 8234000, rsi: 56,
        sector: 'Financials', index: 'S&P500'
      },
      {
        symbol: 'V', name: 'Visa Inc.', price: 267.43, changePct: 0.78,
        pe: 30.2, roe: 41.5, revenueGrowth: 11.3, grossMargin: 98.2,
        netMargin: 52.4, debtToEquity: 0.6, currentRatio: 1.4,
        marketCap: 548e9, volume: 5123000, rsi: 59,
        sector: 'Financials', index: 'S&P500'
      },
      {
        symbol: 'UNH', name: 'UnitedHealth Group', price: 524.89, changePct: 0.56,
        pe: 24.7, roe: 25.3, revenueGrowth: 14.2, grossMargin: 27.8,
        netMargin: 6.1, debtToEquity: 0.6, currentRatio: 0.8,
        marketCap: 489e9, volume: 2345000, rsi: 53,
        sector: 'Healthcare', index: 'S&P500'
      },
      {
        symbol: 'JNJ', name: 'Johnson & Johnson', price: 157.23, changePct: -0.23,
        pe: 15.8, roe: 22.1, revenueGrowth: 5.3, grossMargin: 68.4,
        netMargin: 16.7, debtToEquity: 0.5, currentRatio: 1.2,
        marketCap: 378e9, volume: 6789000, rsi: 48,
        sector: 'Healthcare', index: 'S&P500'
      },
      {
        symbol: 'XOM', name: 'Exxon Mobil', price: 103.45, changePct: -0.89,
        pe: 9.2, roe: 17.4, revenueGrowth: -2.1, grossMargin: 35.6,
        netMargin: 10.2, debtToEquity: 0.2, currentRatio: 1.3,
        marketCap: 421e9, volume: 18234000, rsi: 42,
        sector: 'Energy', index: 'S&P500'
      },
      {
        symbol: 'WMT', name: 'Walmart Inc.', price: 162.34, changePct: 0.45,
        pe: 28.4, roe: 18.9, revenueGrowth: 5.9, grossMargin: 24.8,
        netMargin: 2.4, debtToEquity: 0.7, currentRatio: 0.8,
        marketCap: 441e9, volume: 7123000, rsi: 55,
        sector: 'Consumer', index: 'S&P500'
      },
      {
        symbol: 'PG', name: 'Procter & Gamble', price: 152.89, changePct: 0.34,
        pe: 25.3, roe: 28.4, revenueGrowth: 4.2, grossMargin: 49.8,
        netMargin: 16.1, debtToEquity: 0.5, currentRatio: 0.6,
        marketCap: 362e9, volume: 5678000, rsi: 51,
        sector: 'Consumer', index: 'S&P500'
      },
      {
        symbol: 'HD', name: 'Home Depot', price: 342.56, changePct: 1.23,
        pe: 22.1, roe: 1247.3, revenueGrowth: 6.4, grossMargin: 33.6,
        netMargin: 10.9, debtToEquity: -8.2, currentRatio: 1.1,
        marketCap: 348e9, volume: 3456000, rsi: 58,
        sector: 'Consumer', index: 'S&P500'
      },
      {
        symbol: 'MA', name: 'Mastercard Inc.', price: 437.89, changePct: 0.89,
        pe: 35.6, roe: 148.2, revenueGrowth: 13.1, grossMargin: 100.0,
        netMargin: 45.3, debtToEquity: 2.1, currentRatio: 1.3,
        marketCap: 412e9, volume: 2891000, rsi: 60,
        sector: 'Financials', index: 'S&P500'
      },
      {
        symbol: 'DIS', name: 'Walt Disney Co.', price: 92.34, changePct: -0.56,
        pe: 42.1, roe: 3.2, revenueGrowth: -0.8, grossMargin: 34.2,
        netMargin: 2.9, debtToEquity: 0.5, currentRatio: 1.0,
        marketCap: 168e9, volume: 9234000, rsi: 44,
        sector: 'Consumer', index: 'S&P500'
      },
      {
        symbol: 'NFLX', name: 'Netflix Inc.', price: 447.12, changePct: 2.34,
        pe: 41.3, roe: 28.9, revenueGrowth: 9.2, grossMargin: 42.8,
        netMargin: 16.0, debtToEquity: 1.1, currentRatio: 1.2,
        marketCap: 192e9, volume: 4567000, rsi: 63,
        sector: 'Technology', index: 'NASDAQ100'
      },
      {
        symbol: 'COST', name: 'Costco Wholesale', price: 672.45, changePct: 0.67,
        pe: 47.2, roe: 29.4, revenueGrowth: 6.7, grossMargin: 11.0,
        netMargin: 2.6, debtToEquity: 0.4, currentRatio: 1.0,
        marketCap: 298e9, volume: 1789000, rsi: 57,
        sector: 'Consumer', index: 'S&P500'
      }
    ];


    // Process demo stocks with enhanced analysis
    const processedDemoStocks = DEMO_STOCKS.map(stock => {
      const analysis = computeEnhancedAnalysis(stock);
      return { ...stock, ...analysis };
    });


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EDUCATION CENTER - Investing 101 & Learning Modules
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const EDUCATION_CENTER = {
      tutorials: [
        {
          id: 'what-is-stock',
          title: 'What is a Stock?',
          category: 'basics',
          duration: '5 min',
          icon: 'ğŸ“ˆ',
          content: {
            intro: 'A stock represents ownership in a company. When you buy a share, you own a small piece of that business.',
            keyPoints: [
              'Stocks give you partial ownership of a company',
              'Share prices go up and down based on company performance and investor sentiment',
              'You can make money through price appreciation or dividends',
              'Stocks are traded on exchanges like NYSE and NASDAQ'
            ],
            example: 'If Apple has 16 billion shares and you own 100 shares, you own 0.00000625% of Apple.',
            nextSteps: ['Learn about P/E Ratio', 'Understanding Market Cap', 'How to Read Stock Charts']
          }
        },
        {
          id: 'pe-ratio-explained',
          title: 'Understanding P/E Ratio',
          category: 'metrics',
          duration: '7 min',
          icon: 'ğŸ”¢',
          content: {
            intro: 'The Price-to-Earnings (P/E) ratio is one of the most important valuation metrics for stocks.',
            keyPoints: [
              'P/E = Stock Price Ã· Earnings Per Share',
              'Shows how much investors pay for each $1 of company earnings',
              'Lower P/E might indicate undervaluation',
              'Compare P/E ratios within the same industry',
              'Tech stocks typically have higher P/E ratios than utilities'
            ],
            example: 'If a stock costs $100 and earns $5 per share, its P/E is 20. You\'re paying $20 for every $1 of earnings.',
            whyItMatters: 'P/E helps you determine if a stock is overpriced or a good value compared to its earnings power.',
            practicalTip: 'A P/E under 15 is often considered undervalued, 15-25 is fair, and over 25 might be overvalued (but growth stocks are exceptions).',
            nextSteps: ['Learn ROE', 'Explore Debt-to-Equity', 'Master Market Cap']
          }
        },
        {
          id: 'roe-explained',
          title: 'Return on Equity (ROE)',
          category: 'metrics',
          duration: '6 min',
          icon: 'ğŸ’°',
          content: {
            intro: 'ROE measures how efficiently a company uses shareholder money to generate profits.',
            keyPoints: [
              'ROE = Net Income Ã· Shareholder Equity',
              'Shows profit generated from shareholder investments',
              '15%+ ROE is considered strong',
              '20%+ ROE is excellent',
              'Compare ROE within the same industry'
            ],
            example: 'If a company has $1 million equity and makes $200,000 profit, ROE is 20%. For every $1 invested, they generate $0.20 profit.',
            whyItMatters: 'ROE tells you if management is good at growing the business with your money.',
            practicalTip: 'Look for companies with consistently high ROE over several yearsâ€”it shows sustainable competitive advantage.',
            nextSteps: ['Understand ROIC', 'Learn Profit Margins', 'Study Buffett Strategy']
          }
        },
        {
          id: 'market-cap-sizes',
          title: 'Market Cap: Small, Mid, Large',
          category: 'basics',
          duration: '5 min',
          icon: 'ğŸ¢',
          content: {
            intro: 'Market capitalization (market cap) is the total value of all a company\'s shares.',
            keyPoints: [
              'Market Cap = Share Price Ã— Total Shares Outstanding',
              'Large Cap: $10 billion+ (stable, lower risk)',
              'Mid Cap: $2-10 billion (growth + stability)',
              'Small Cap: Under $2 billion (higher growth, higher risk)',
              'Mega Cap: $200 billion+ (Apple, Microsoft, etc.)'
            ],
            example: 'Apple with 16B shares at $180 = $2.88 trillion market cap (mega cap)',
            whyItMatters: 'Market cap indicates company size, risk level, and growth potential.',
            practicalTip: 'Beginners should focus on large caps for stability. Once comfortable, add mid and small caps for growth.',
            nextSteps: ['Portfolio Diversification', 'Risk Management', 'Asset Allocation']
          }
        },
        {
          id: 'reading-charts',
          title: 'How to Read Stock Charts',
          category: 'technical',
          duration: '10 min',
          icon: 'ğŸ“Š',
          content: {
            intro: 'Stock charts visualize price movements over time, helping you spot trends and patterns.',
            keyPoints: [
              'Candlesticks show Open, High, Low, Close prices',
              'Green/white candles = price went up, Red/black = down',
              'Support levels: price tends to bounce back up',
              'Resistance levels: price struggles to break through',
              'Volume bars show trading activity'
            ],
            example: 'If you see multiple bounces at $150, that\'s a support level. If price keeps hitting $175 but can\'t break through, that\'s resistance.',
            whyItMatters: 'Charts help you time your entry and exit points for better returns.',
            practicalTip: 'Start with simple trend lines. Uptrend = series of higher lows. Downtrend = series of lower highs.',
            nextSteps: ['RSI Indicator', 'Moving Averages', 'MACD Strategy']
          }
        },
        {
          id: 'rsi-indicator',
          title: 'RSI: Overbought or Oversold?',
          category: 'technical',
          duration: '8 min',
          icon: 'ğŸ“‰',
          content: {
            intro: 'The Relative Strength Index (RSI) measures momentum to identify overbought or oversold conditions.',
            keyPoints: [
              'RSI ranges from 0 to 100',
              'Above 70 = overbought (potential pullback coming)',
              'Below 30 = oversold (potential bounce coming)',
              'Best used with other indicators, not alone',
              '14-period RSI is the standard'
            ],
            example: 'If RSI hits 80, the stock may have risen too fast and could drop soon. If RSI is 25, it may have fallen too much and could bounce.',
            whyItMatters: 'RSI helps you avoid buying at peaks and identifies potential buying opportunities at dips.',
            practicalTip: 'Don\'t sell just because RSI is highâ€”strong trends can stay "overbought" for weeks. Use with trend analysis.',
            nextSteps: ['MACD Divergence', 'Bollinger Bands', 'Combine Indicators']
          }
        },
        {
          id: 'diversification',
          title: 'Portfolio Diversification 101',
          category: 'strategy',
          duration: '8 min',
          icon: 'ğŸ¯',
          content: {
            intro: 'Diversification means spreading your money across different investments to reduce risk.',
            keyPoints: [
              'Don\'t put all your eggs in one basket',
              'Diversify across sectors (tech, healthcare, finance, etc.)',
              'Mix large, mid, and small cap stocks',
              'Include different asset classes (stocks, bonds, real estate)',
              'International diversification reduces country-specific risk'
            ],
            example: 'Instead of putting $10,000 in one tech stock, spread it across 10 stocks in 5 different sectors.',
            whyItMatters: 'If one stock or sector crashes, you don\'t lose everything. Diversification smooths out returns.',
            practicalTip: 'Start with 8-15 stocks across different sectors. Too few = too risky. Too many = hard to track.',
            nextSteps: ['Asset Allocation', 'Sector Rotation', 'Rebalancing Strategy']
          }
        },
        {
          id: 'dollar-cost-averaging',
          title: 'Dollar-Cost Averaging Strategy',
          category: 'strategy',
          duration: '6 min',
          icon: 'ğŸ’µ',
          content: {
            intro: 'Dollar-cost averaging (DCA) means investing a fixed amount regularly, regardless of price.',
            keyPoints: [
              'Invest the same amount weekly/monthly',
              'Buy more shares when prices are low',
              'Buy fewer shares when prices are high',
              'Reduces impact of market volatility',
              'Removes emotion from investing decisions'
            ],
            example: 'Invest $500/month. When stock is $50, you buy 10 shares. When it drops to $25, you buy 20 shares. Your average cost is lower.',
            whyItMatters: 'DCA prevents you from investing everything at the peak and helps build wealth steadily.',
            practicalTip: 'Set up automatic monthly investments so you stick with it through market ups and downs.',
            nextSteps: ['Index Fund Investing', 'Long-term Wealth Building', 'Compound Growth']
          }
        }
      ],

      caseStudies: [
        {
          id: 'buffett-coca-cola',
          title: 'Warren Buffett & Coca-Cola',
          investor: 'Warren Buffett',
          year: '1988',
          icon: 'ğŸ¥¤',
          summary: 'How Buffett turned $1 billion into $25 billion by buying a simple, understandable business.',
          story: 'In 1988, Warren Buffett bought $1 billion worth of Coca-Cola stock when the market undervalued it during a temporary setback. He recognized Coke\'s powerful brand, global reach, and consistent earnings.',
          keyLessons: [
            'Invest in businesses you understand',
            'Look for strong brands with pricing power',
            'Buy quality companies when they\'re temporarily down',
            'Hold for the long term (35+ years and counting)',
            'Focus on business fundamentals, not market noise'
          ],
          metrics: {
            initialInvestment: '$1 billion',
            currentValue: '$25+ billion',
            annualReturn: '~10% per year',
            holdingPeriod: '35+ years'
          },
          takeaway: 'Simple businesses with strong competitive advantages can generate massive wealth if you\'re patient.'
        },
        {
          id: 'lynch-fidelity',
          title: 'Peter Lynch\'s 10-Baggers',
          investor: 'Peter Lynch',
          year: '1977-1990',
          icon: 'ğŸ¯',
          summary: 'How a retail investor mindset helped Lynch beat the market by finding everyday winners.',
          story: 'Peter Lynch ran Fidelity Magellan Fund and achieved 29% annual returns by investing in companies he encountered in daily lifeâ€”Dunkin\' Donuts, Hanes, Home Depot. He called these "10-baggers" (stocks that returned 10x).',
          keyLessons: [
            'Look for investment ideas in your daily life',
            'Do your homeworkâ€”understand what the company does',
            'Small companies can become big winners',
            'Visit stores, talk to customers, read annual reports',
            'You don\'t need Wall Street connections to find great stocks'
          ],
          metrics: {
            annualReturn: '29.2%',
            period: '13 years',
            $10kGrowth: '$280,000',
            famousWins: 'Taco Bell, Home Depot, Chrysler'
          },
          takeaway: 'Retail investors have an edgeâ€”you can discover great companies before Wall Street does.'
        },
        {
          id: 'oneil-canslim',
          title: 'William O\'Neil\'s CANSLIM',
          investor: 'William O\'Neil',
          year: '1960s+',
          icon: 'ğŸš€',
          summary: 'A systematic approach to finding growth stocks before they skyrocket.',
          story: 'William O\'Neil studied the best-performing stocks from 1953-1993 and found patterns. He created CANSLIMâ€”a checklist for identifying winning stocks. His system helped countless retail investors.',
          keyLessons: [
            'C: Current quarterly earnings up 25%+',
            'A: Annual earnings growth consistent',
            'N: New products, management, or highs',
            'S: Supply & Demandâ€”low float stocks move more',
            'L: Leader in industry, not laggard',
            'I: Institutional sponsorship present',
            'M: Market direction is upward'
          ],
          metrics: {
            avgWinner: '+100-300%',
            timeframe: '3-12 months',
            successRate: '~33% (1 in 3 big winners)',
            strategy: 'Growth stocks with momentum'
          },
          takeaway: 'Follow a proven system. Cut losses quickly at -7%, let winners run.'
        },
        {
          id: 'reit-income',
          title: 'Building Income with REITs',
          investor: 'Retail Investor Case',
          year: '2010-2025',
          icon: 'ğŸ˜ï¸',
          summary: 'How a teacher built $500/month passive income with real estate stocks.',
          story: 'A school teacher invested $50,000 into diversified REITs (Real Estate Investment Trusts) yielding 5-8% dividends. After 15 years, between dividends and growth, her portfolio generates $500+/month in passive income.',
          keyLessons: [
            'REITs must pay 90% of income as dividends',
            'Diversify across property types (retail, office, residential)',
            'Reinvest dividends in early years for compound growth',
            'REITs provide real estate exposure without property management',
            'Focus on quality REITs with strong balance sheets'
          ],
          metrics: {
            initialInvestment: '$50,000',
            monthlyIncome: '$500+',
            totalValue: '$125,000',
            averageYield: '6%',
            period: '15 years'
          },
          takeaway: 'Dividend-paying stocks can create reliable passive income streams over time.'
        }
      ],

      getProgress(userId) {
        const key = `re_education_progress_${userId || 'guest'}`;
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : { completed: [], inProgress: [] };
      },

      markComplete(userId, tutorialId) {
        const progress = this.getProgress(userId);
        if (!progress.completed.includes(tutorialId)) {
          progress.completed.push(tutorialId);
          progress.inProgress = progress.inProgress.filter(id => id !== tutorialId);
          localStorage.setItem(`re_education_progress_${userId || 'guest'}`, JSON.stringify(progress));
        }
      },

      markInProgress(userId, tutorialId) {
        const progress = this.getProgress(userId);
        if (!progress.completed.includes(tutorialId) && !progress.inProgress.includes(tutorialId)) {
          progress.inProgress.push(tutorialId);
          localStorage.setItem(`re_education_progress_${userId || 'guest'}`, JSON.stringify(progress));
        }
      },

      getCompletionRate(userId) {
        const progress = this.getProgress(userId);
        return Math.round((progress.completed.length / this.tutorials.length) * 100);
      },

      getTutorialsByCategory(category) {
        return this.tutorials.filter(t => t.category === category);
      },

      getNextTutorial(userId) {
        const progress = this.getProgress(userId);
        return this.tutorials.find(t =>
          !progress.completed.includes(t.id) &&
          !progress.inProgress.includes(t.id)
        );
      }
    };


    // Demo mode state
    let isDemoMode = false;

    // INVESTMENT STYLES
    const INVESTMENT_STYLES = {
      growth: {
        name: 'Growth', emoji: 'ğŸš€', description: 'High growth tech & innovation',
        symbols: ['NVDA', 'SMCI', 'ARM', 'SNOW', 'TTD', 'UBER', 'SQ', 'SHOP', 'NET', 'DDOG']
      },
      value: {
        name: 'Value', emoji: 'ğŸ’°', description: 'Undervalued stable businesses',
        symbols: ['BRK.B', 'JNJ', 'MMM', 'VZ', 'T', 'KO', 'PG', 'WMT', 'CVX', 'XOM']
      },
      momentum: {
        name: 'Momentum', emoji: 'âš¡', description: 'Strong price trends',
        symbols: ['TSLA', 'META', 'AMD', 'MU', 'COIN', 'MARA', 'PLTR', 'HOOD']
      },
      quality: {
        name: 'Quality', emoji: 'â­', description: 'Excellent businesses',
        symbols: ['MSFT', 'AAPL', 'GOOGL', 'COST', 'HD', 'ADBE', 'INTU', 'MA', 'V']
      },
      dividend: {
        name: 'Dividend', emoji: 'ğŸ’µ', description: 'Reliable income',
        symbols: ['VZ', 'T', 'KO', 'PG', 'MMM', 'JNJ', 'XOM', 'CVX', 'MO', 'ABBV']
      }
    };


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENHANCED AI ANALYSIS - Tier 1 Features
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function computeEnhancedAnalysis(stock) {
      // Calculate subscores
      const fundamentalScore = calculateFundamentalScore(stock);
      const technicalScore = calculateTechnicalScore(stock);
      const riskScore = calculateRiskScore(stock);

      const aiScore = Math.round((fundamentalScore * 0.5) + (technicalScore * 0.3) + (riskScore * 0.2));
      const verdict = getVerdict(aiScore);
      const confidence = calculateConfidence(stock);

      // Generate factor analysis (Bulls vs Bears)
      const factors = generateFactorAnalysis(stock);

      // Generate AI takeaway
      const takeaway = generateTakeaway(stock, verdict, factors);

      // Generate watchlist guidance
      const watchlistGuidance = generateWatchlistGuidance(stock, factors);

      return {
        aiScore,
        verdict,
        confidence,
        subscores: {
          fundamental: Math.round(fundamentalScore),
          technical: Math.round(technicalScore),
          risk: Math.round(riskScore)
        },
        topDrivers: {
          positive: factors.bullish,
          negative: factors.bearish
        },
        takeaway,
        watchlistGuidance,
        reassurance: "Remember: this is a data-driven assessment. Always do your own research and consider your risk tolerance before investing."
      };
    }

    function calculateFundamentalScore(stock) {
      let score = 50;

      // Get sector-specific benchmarks
      const benchmarks = getSectorBenchmarks(stock.sector);

      // === SECTOR-AWARE ROE SCORING ===
      if (stock.roe !== undefined && stock.roe !== null) {
        if (stock.roe > benchmarks.roe_excellent) {
          score += 15; // Exceptional profitability
        } else if (stock.roe > benchmarks.roe_target) {
          score += 10; // Strong profitability
        } else if (stock.roe > benchmarks.roe_target * 0.5) {
          score += 5; // Acceptable
        } else if (stock.roe < 0) {
          score -= 15; // Unprofitable
        } else {
          score -= 5; // Below sector standards
        }
      }

      // === SECTOR-AWARE P/E SCORING ===
      if (stock.pe > 0) {
        if (stock.pe < benchmarks.pe_base * 0.7) {
          score += 15; // Significantly undervalued
        } else if (stock.pe < benchmarks.pe_base) {
          score += 10; // Undervalued
        } else if (stock.pe < benchmarks.pe_acceptable) {
          score += 5; // Fairly valued
        } else if (stock.pe < benchmarks.pe_acceptable * 1.3) {
          score -= 5; // Slightly overvalued
        } else {
          score -= 10; // Significantly overvalued
        }
      }

      // === SECTOR-AWARE GROWTH SCORING ===
      if (stock.revenueGrowth !== undefined && stock.revenueGrowth !== null) {
        if (stock.revenueGrowth > benchmarks.growth_excellent) {
          score += 15; // Exceptional growth
        } else if (stock.revenueGrowth > benchmarks.growth_target) {
          score += 10; // Strong growth
        } else if (stock.revenueGrowth > benchmarks.growth_target * 0.5) {
          score += 5; // Moderate growth
        } else if (stock.revenueGrowth < -10) {
          score -= 15; // Significant decline
        } else if (stock.revenueGrowth < 0) {
          score -= 10; // Declining
        }
      }

      // === SECTOR-AWARE MARGIN SCORING ===
      if (stock.grossMargin !== undefined && stock.grossMargin !== null) {
        if (stock.grossMargin > benchmarks.margin_target * 1.5) {
          score += 12; // Exceptional margins
        } else if (stock.grossMargin > benchmarks.margin_target) {
          score += 8; // Strong margins
        } else if (stock.grossMargin > benchmarks.margin_target * 0.7) {
          score += 4; // Acceptable margins
        }
      }

      // Net margin bonus
      if (stock.netMargin !== undefined && stock.netMargin !== null) {
        if (stock.netMargin > 20) score += 5;
        else if (stock.netMargin < 0) score -= 5;
      }

      return Math.max(0, Math.min(100, score));
    }

    function calculateTechnicalScore(stock) {
      let score = 50;

      // RSI
      if (stock.rsi >= 30 && stock.rsi <= 70) score += 15;
      else if (stock.rsi > 70) score -= 10;
      else if (stock.rsi < 30) score += 5; // oversold can be opportunity

      // Price momentum
      if (stock.changePct > 5) score += 10;
      else if (stock.changePct > 0) score += 5;
      else if (stock.changePct < -5) score -= 10;

      return Math.max(0, Math.min(100, score));
    }

    function calculateRiskScore(stock) {
      let score = 50;

      // Debt/Equity
      if (stock.debtToEquity < 0.5) score += 20;
      else if (stock.debtToEquity < 1) score += 10;
      else if (stock.debtToEquity > 2) score -= 20;

      // Current ratio
      if (stock.currentRatio > 2) score += 15;
      else if (stock.currentRatio > 1.5) score += 10;
      else if (stock.currentRatio < 1) score -= 15;

      return Math.max(0, Math.min(100, score));
    }

    function getVerdict(score) {
      if (score >= 80) return "STRONG BUY";
      if (score >= 65) return "BUY";
      if (score >= 45) return "HOLD";
      if (score >= 30) return "REDUCE";
      return "SELL";
    }

    function calculateConfidence(stock) {
      let confidence = 50;

      // More data points = higher confidence
      const hasData = [
        stock.pe, stock.roe, stock.revenueGrowth,
        stock.grossMargin, stock.debtToEquity,
        stock.currentRatio, stock.rsi
      ].filter(v => v != null && !isNaN(v)).length;

      confidence += (hasData * 5);

      return Math.min(95, Math.max(30, confidence));
    }

    function generateFactorAnalysis(stock) {
      const bullish = [];
      const bearish = [];

      // ROE analysis
      if (stock.roe > 20) {
        bullish.push({
          factor: "Exceptional ROE",
          detail: `${stock.roe?.toFixed(1)}% ROE indicates strong profitability and efficient capital use`
        });
      } else if (stock.roe > 15) {
        bullish.push({
          factor: "Strong ROE",
          detail: `${stock.roe?.toFixed(1)}% ROE shows solid return on equity`
        });
      } else if (stock.roe < 10) {
        bearish.push({
          factor: "Low ROE",
          detail: `${stock.roe?.toFixed(1)}% ROE is below industry standards`
        });
      }

      // Growth analysis
      if (stock.revenueGrowth > 20) {
        bullish.push({
          factor: "High Growth",
          detail: `Revenue growing at ${stock.revenueGrowth?.toFixed(1)}% YoY shows strong demand`
        });
      } else if (stock.revenueGrowth < 0) {
        bearish.push({
          factor: "Revenue Decline",
          detail: `Revenue down ${Math.abs(stock.revenueGrowth)?.toFixed(1)}% YoY raises concerns`
        });
      }

      // Valuation analysis
      if (stock.pe > 0 && stock.pe < 15) {
        bullish.push({
          factor: "Attractive Valuation",
          detail: `P/E of ${stock.pe?.toFixed(1)} suggests stock may be undervalued`
        });
      } else if (stock.pe > 30) {
        bearish.push({
          factor: "High Valuation",
          detail: `P/E of ${stock.pe?.toFixed(1)} indicates premium pricing vs sector average`
        });
      }

      // Debt analysis
      if (stock.debtToEquity < 0.5) {
        bullish.push({
          factor: "Low Debt",
          detail: `Debt/Equity of ${stock.debtToEquity?.toFixed(2)} shows conservative balance sheet`
        });
      } else if (stock.debtToEquity > 1.5) {
        bearish.push({
          factor: "High Leverage",
          detail: `Debt/Equity of ${stock.debtToEquity?.toFixed(2)} indicates elevated financial risk`
        });
      }

      // Momentum analysis
      if (stock.changePct > 5) {
        bullish.push({
          factor: "Strong Momentum",
          detail: `Price up ${stock.changePct?.toFixed(1)}% shows positive market sentiment`
        });
      } else if (stock.changePct < -5) {
        bearish.push({
          factor: "Negative Momentum",
          detail: `Price down ${Math.abs(stock.changePct)?.toFixed(1)}% indicates selling pressure`
        });
      }

      // RSI analysis
      if (stock.rsi < 30) {
        bullish.push({
          factor: "Oversold Condition",
          detail: `RSI of ${stock.rsi?.toFixed(0)} suggests potential buying opportunity`
        });
      } else if (stock.rsi > 70) {
        bearish.push({
          factor: "Overbought",
          detail: `RSI of ${stock.rsi?.toFixed(0)} warns of potential pullback`
        });
      }

      // Ensure we always have at least some factors
      if (bullish.length === 0) {
        bullish.push({
          factor: "Stable Metrics",
          detail: "Core financials appear stable with no major red flags"
        });
      }
      if (bearish.length === 0) {
        bearish.push({
          factor: "Market Volatility",
          detail: "General market conditions warrant monitoring"
        });
      }

      return { bullish: bullish.slice(0, 3), bearish: bearish.slice(0, 3) };
    }

    function generateTakeaway(stock, verdict, factors) {
      const symbol = stock.symbol;

      if (verdict === "STRONG BUY" || verdict === "BUY") {
        return `Overall, ${symbol} presents a compelling opportunity. The combination of ${factors.bullish[0]?.factor.toLowerCase() || 'strong fundamentals'} and positive momentum suggests this could be a solid addition to a growth-focused portfolio. While ${factors.bearish[0]?.factor.toLowerCase() || 'some risks exist'}, the bullish factors currently outweigh concerns.`;
      } else if (verdict === "HOLD") {
        return `${symbol} shows mixed signals. While ${factors.bullish[0]?.factor.toLowerCase() || 'some positives exist'}, concerns around ${factors.bearish[0]?.factor.toLowerCase() || 'valuation'} suggest a wait-and-see approach. Consider this a watchlist candidate while monitoring for better entry points or improving fundamentals.`;
      } else {
        return `${symbol} faces headwinds that warrant caution. Key concerns include ${factors.bearish[0]?.factor.toLowerCase() || 'valuation pressure'} and ${factors.bearish[1]?.factor.toLowerCase() || 'weakening fundamentals'}. Unless you have strong conviction in a turnaround thesis, consider reducing exposure or avoiding new positions at current levels.`;
      }
    }

    function generateWatchlistGuidance(stock, factors) {
      const topBearish = factors.bearish[0]?.factor || "earnings surprises";
      const keyMetric = stock.roe > stock.revenueGrowth ? "ROE and profit margins" : "revenue growth and market share";

      return {
        headline: "What to Watch Next",
        items: [
          {
            label: "Next check-in",
            value: "Review after the next earnings cycle (typically quarterly)"
          },
          {
            label: "Key metric to monitor",
            value: keyMetric
          },
          {
            label: "Main risk to watch",
            value: topBearish
          }
        ]
      };
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIER 2: PORTFOLIO SECTOR ALLOCATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function computePortfolioAllocation(stocks, watchlist) {
      if (!watchlist || watchlist.length === 0) {
        return { stocks: [], sectorWeights: {}, isEmpty: true };
      }

      const watchlistedStocks = stocks.filter(s => watchlist && Array.isArray(watchlist) && watchlist.some(w => w && w.toUpperCase() === s.symbol.toUpperCase()));

      if (watchlistedStocks.length === 0) {
        return { stocks: [], sectorWeights: {}, isEmpty: true };
      }

      // Equal weight allocation
      const weight = 100 / watchlistedStocks.length;

      const allocation = watchlistedStocks.map(s => ({
        symbol: s.symbol,
        name: s.name || s.symbol,
        sector: s.sector || 'Other',
        weight: weight,
        price: s.price,
        aiScore: s.aiScore,
        verdict: s.verdict
      }));

      // Calculate sector weights
      const sectorWeights = {};
      allocation.forEach(a => {
        sectorWeights[a.sector] = (sectorWeights[a.sector] || 0) + a.weight;
      });

      return {
        stocks: allocation,
        sectorWeights,
        isEmpty: false,
        totalStocks: watchlistedStocks.length,
        sectorCount: Object.keys(sectorWeights).length
      };
    }

    function getSectorColor(sector) {
      const colors = {
        'Technology': 'from-cyan-500 to-blue-500',
        'Healthcare': 'from-green-500 to-emerald-500',
        'Financials': 'from-yellow-500 to-orange-500',
        'Consumer': 'from-purple-500 to-pink-500',
        'Energy': 'from-red-500 to-orange-500',
        'Industrials': 'from-gray-500 to-slate-500',
        'Materials': 'from-amber-500 to-yellow-500',
        'Utilities': 'from-blue-500 to-cyan-500',
        'Real Estate': 'from-indigo-500 to-purple-500',
        'Communication': 'from-pink-500 to-rose-500',
        'Other': 'from-slate-500 to-gray-500'
      };
      return colors[sector] || colors['Other'];
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ML MODELS: Advanced Analytics
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const MLModels = {
      optimizePortfolio(positions, riskFreeRate = 0.02) {
        try {
          if (!positions || positions.length === 0) throw new Error('No positions provided');
          const n = positions.length;
          const returns = positions.map(pos => pos.expectedReturn || 0.08);
          const volatilities = positions.map(pos => pos.volatility || 0.15);
          const correlation = 0.3; // Simplified correlation assumption

          // Build covariance matrix
          const covarianceMatrix = Array(n).fill().map((_, i) =>
            Array(n).fill().map((_, j) => {
              if (i === j) return Math.pow(volatilities[i], 2);
              return correlation * volatilities[i] * volatilities[j];
            })
          );

          // Monte Carlo simulation - generate 1000 random portfolios
          const portfolios = [];
          const numPortfolios = 1000;

          for (let p = 0; p < numPortfolios; p++) {
            // Generate random weights
            let weights = Array.from({ length: n }, () => Math.random());
            const sum = weights.reduce((a, b) => a + b, 0);
            weights = weights.map(w => w / sum); // Normalize to sum to 1

            // Calculate portfolio return
            const portfolioReturn = weights.reduce((sum, w, i) => sum + w * returns[i], 0);

            // Calculate portfolio variance
            let portfolioVariance = 0;
            for (let i = 0; i < n; i++) {
              for (let j = 0; j < n; j++) {
                portfolioVariance += weights[i] * weights[j] * covarianceMatrix[i][j];
              }
            }
            const portfolioVolatility = Math.sqrt(portfolioVariance);

            // Calculate Sharpe Ratio
            const sharpeRatio = (portfolioReturn - riskFreeRate) / portfolioVolatility;

            portfolios.push({
              weights,
              return: portfolioReturn,
              volatility: portfolioVolatility,
              sharpeRatio
            });
          }

          // Find optimal portfolios
          const maxSharpe = portfolios.reduce((best, current) =>
            current.sharpeRatio > best.sharpeRatio ? current : best
          );
          const minVolatility = portfolios.reduce((best, current) =>
            current.volatility < best.volatility ? current : best
          );

          // Get efficient frontier (subset of portfolios)
          const efficientFrontier = [...portfolios]
            .sort((a, b) => a.volatility - b.volatility)
            .filter((p, i) => i % 10 === 0)
            .slice(0, 20);

          return {
            maxSharpePortfolio: {
              ...maxSharpe,
              weights: maxSharpe.weights.map((w, i) => ({
                symbol: positions[i].symbol,
                weight: w * 100,
                contribution: w * returns[i]
              }))
            },
            minVolatilityPortfolio: {
              ...minVolatility,
              weights: minVolatility.weights.map((w, i) => ({
                symbol: positions[i].symbol,
                weight: w * 100,
                contribution: w * returns[i]
              }))
            },
            efficientFrontier,
            individualMetrics: positions.map((pos, i) => ({
              symbol: pos.symbol,
              expectedReturn: returns[i],
              volatility: volatilities[i],
              sharpeRatio: (returns[i] - riskFreeRate) / volatilities[i]
            }))
          };
        } catch (error) {
          console.error('Portfolio optimization error:', error);
          throw error;
        }
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RETAIL INVESTOR FEATURES: SLEEP-WELL SCORE & CRASH SIMULATOR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Calculate "Sleep-Well" score - measures portfolio comfort/volatility risk
    function calcSleepWellScore(stock) {
      const vol = stock.beta ? Math.abs((stock.beta - 1) * 30) : 25; // Estimate volatility from beta
      const maxDD = stock.changePct ? Math.abs(Math.min(0, stock.changePct)) * 3 : 30; // Rough drawdown estimate
      const de = stock.debtToEquity || 0.5;
      const rsi = stock.rsi || 50;

      let score = 100;

      // Volatility penalty
      if (vol > 35) score -= 20;
      else if (vol > 25) score -= 10;

      // Drawdown penalty
      if (maxDD > 40) score -= 25;
      else if (maxDD > 25) score -= 15;

      // Debt penalty
      if (de > 1) score -= 20;
      else if (de > 0.5) score -= 10;

      // RSI extremes penalty
      if (rsi > 70 || rsi < 30) score -= 10;

      return Math.max(0, Math.round(score));
    }

    // Market crash scenarios
    const CRASH_SCENARIOS = {
      '2008 Financial Crisis': { drop: -57, weeks: 78, name: '2008' },
      '2020 COVID Crash': { drop: -34, weeks: 5, name: '2020' },
      '2000 Dot-com Bust': { drop: -49, weeks: 63, name: '2000' },
      '1987 Black Monday': { drop: -34, weeks: 1, name: '1987' },
    };

    function simulateMarketCrash(portfolioHoldings, scenarioKey) {
      const scenario = CRASH_SCENARIOS[scenarioKey];
      if (!scenario) return null;

      const totalValue = portfolioHoldings.reduce((sum, h) => sum + h.currentValue, 0);
      const lossUsd = totalValue * Math.abs(scenario.drop) / 100;
      const lossPct = Math.abs(scenario.drop);
      const perWeek = lossUsd / scenario.weeks;
      const finalValue = totalValue - lossUsd;

      return {
        scenarioName: scenarioKey,
        totalValue,
        lossUsd,
        lossPct,
        weeks: scenario.weeks,
        perWeek,
        finalValue,
        percentRemaining: 100 - lossPct
      };
    }

    // TIER 3: ML PRICE PREDICTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Request queue for ML predictions to avoid rate limits
    let mlPredictionQueue = [];
    let mlPredictionProcessing = false;
    const ML_PREDICTION_DELAY = 500; // 500ms delay between ML prediction requests

    async function processMLPredictionQueue() {
      if (mlPredictionProcessing || mlPredictionQueue.length === 0) return;
      mlPredictionProcessing = true;

      while (mlPredictionQueue.length > 0) {
        const { symbol, resolve, reject } = mlPredictionQueue.shift();
        try {
          const result = await computeMLPredictionInternal(symbol);
          resolve(result);
        } catch (error) {
          reject(error);
        }
        // Delay between requests to avoid rate limits
        if (mlPredictionQueue.length > 0) {
          await new Promise(r => setTimeout(r, ML_PREDICTION_DELAY));
        }
      }

      mlPredictionProcessing = false;
    }

    async function computeMLPrediction(symbol) {
      return new Promise((resolve, reject) => {
        mlPredictionQueue.push({ symbol, resolve, reject });
        processMLPredictionQueue();
      });
    }

    async function computeMLPredictionInternal(symbol) {
      try {
        console.log(`ğŸ¤– Computing ML prediction for ${symbol}...`);

        // Fetch 60 days of historical data using stable endpoint with rate limit handling
        const url = `https://financialmodelingprep.com/stable/historical-price-eod/full?symbol=${symbol}&apikey=${API_KEYS.FMP}`;

        // Use fetchWithRetry with better retry logic for rate limits
        const resp = await fetchWithRetry(url, {
          timeoutMs: 20000,
          retries: 3,
          retryDelayMs: 2000, // 2 second delay on retry
          shouldRetry: ({ response, error }) => {
            if (error) return true;
            if (!response) return true;
            // Retry on 429 (rate limit) and 5xx errors
            if (response.status === 429) return true;
            if (response.status >= 500) return true;
            return false;
          }
        });

        if (!resp || !resp.ok) {
          // 403 means premium endpoint not accessible - silently skip ML predictions
          if (resp?.status === 403) {
            console.log(`âš ï¸ ML predictions require FMP premium subscription (skipping for ${symbol})`);
          } else if (resp?.status === 429) {
            console.warn(`â³ ML prediction rate limited for ${symbol} - skipping`);
          } else {
            console.warn(`ML prediction fetch failed for ${symbol} - Status: ${resp?.status || 'unknown'}`);
          }
          return { predPct: null, conf: null, trend: null };
        }

        const data = await resp.json();

        // Stable endpoint returns array directly
        const historical = Array.isArray(data) ? data.slice(0, 60) : [];

        // Add delay after successful request to avoid rate limits
        await new Promise(r => setTimeout(r, 300));

        console.log(`   ğŸ“Š Got ${historical.length} historical data points for ${symbol}`);
        if (historical.length > 0) {
          console.log(`   ğŸ“… Sample data point:`, historical[0]);
        }

        if (historical.length < 60) {
          console.warn(`Insufficient historical data for ${symbol} (need 60 days, got ${historical.length})`);
          return { predPct: null, conf: null, trend: null };
        }

        // Get last 60 days of closing prices (reverse to chronological order)
        const prices = historical.slice(0, 60).reverse().map(d => d.close);
        console.log(`   ğŸ’° Extracted prices for ${symbol}: [${prices.slice(0, 5).join(', ')}...]`);
        console.log(`   ğŸ“ Current price: ${prices[prices.length - 1]}`);
        const current = prices[prices.length - 1];

        // Create simple linear regression model using TensorFlow.js
        console.log(`   ğŸ§  Creating tensors for ${symbol}...`);
        // Create 2D tensors for training (reshape to [60, 1])
        const xs = tf.tensor2d(Array.from({ length: 60 }, (_, i) => [i]));
        const ys = tf.tensor2d(prices.map(p => [p]));

        const model = tf.sequential();
        model.add(tf.layers.dense({ units: 1, inputShape: [1] }));
        model.compile({
          optimizer: tf.train.adam(0.1),
          loss: 'meanSquaredError'
        });

        console.log(`   ğŸ“ Training model for ${symbol}...`);
        // Train the model (100 epochs with Adam optimizer)
        const history = await model.fit(xs, ys, {
          epochs: 100,
          verbose: 0,
          shuffle: false
        });

        console.log(`   âœ“ Training complete, final loss: ${history.history.loss[history.history.loss.length - 1]}`);

        // Predict the next day (day 60)
        console.log(`   ğŸ”® Predicting for ${symbol}...`);
        const prediction = model.predict(tf.tensor2d([[60]]));
        const predictedPrice = prediction.dataSync()[0];
        console.log(`   ğŸ’ Predicted price: ${predictedPrice}, Current: ${current}`);

        // Calculate percentage change
        const predPct = ((predictedPrice - current) / current) * 100;
        console.log(`   ğŸ“ˆ Percentage change: ${predPct}%`);

        // Estimate confidence (heuristic: smaller predictions = higher confidence)
        // Confidence decreases as prediction magnitude increases
        const rawConf = 100 - Math.abs(predPct) * 1.5;
        const conf = Math.round(Math.max(10, Math.min(90, rawConf)));

        // Determine trend
        const trend = predPct > 2 ? 'bullish' : predPct < -2 ? 'bearish' : 'neutral';

        // Generate interpretation
        let interpretation = '';
        const absPct = Math.abs(predPct);

        if (predPct > 10) {
          interpretation = `Strong upward trend predicted. Model suggests ${absPct.toFixed(1)}% potential gain based on recent price momentum.`;
        } else if (predPct > 5) {
          interpretation = `Moderate bullish signal. Technical analysis indicates ${absPct.toFixed(1)}% upside potential.`;
        } else if (predPct > 2) {
          interpretation = `Slight positive movement expected. Model forecasts ${absPct.toFixed(1)}% modest gain.`;
        } else if (predPct > -2) {
          interpretation = `Neutral forecast. Price expected to remain relatively stable with minimal movement (${Math.abs(predPct).toFixed(1)}%).`;
        } else if (predPct > -5) {
          interpretation = `Slight bearish trend. Model suggests ${absPct.toFixed(1)}% potential decline.`;
        } else if (predPct > -10) {
          interpretation = `Moderate downward pressure. Technical indicators point to ${absPct.toFixed(1)}% downside risk.`;
        } else {
          interpretation = `Strong bearish signal. Model predicts ${absPct.toFixed(1)}% potential loss based on recent trends.`;
        }

        // Add confidence context
        if (conf > 70) {
          interpretation += ` High confidence (${conf}%).`;
        } else if (conf > 50) {
          interpretation += ` Moderate confidence (${conf}%).`;
        } else {
          interpretation += ` Low confidence (${conf}%) - use caution.`;
        }

        // Cleanup tensors to prevent memory leaks
        xs.dispose();
        ys.dispose();
        prediction.dispose();

        console.log(`âœ“ ML prediction for ${symbol}: ${predPct.toFixed(1)}% (conf: ${conf}%)`);

        return {
          predPct: parseFloat(predPct.toFixed(1)),
          conf,
          trend,
          predictedPrice: parseFloat(predictedPrice.toFixed(2)),
          interpretation
        };

      } catch (error) {
        console.error(`ML prediction error for ${symbol}:`, error);
        return { predPct: null, conf: null, trend: null };
      }


      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENHANCED ML PREDICTION (V2.0) - Uses RSI, Volume, and Price History
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      async function computeAdvancedMLPrediction(priceHistory, currentRsi, currentVolume) {
        try {
          if (!priceHistory || priceHistory.length < 20) {
            console.warn('âš ï¸  Insufficient price history for advanced ML');
            return null;
          }

          const prices = priceHistory.map(d => d.close);
          const volumes = priceHistory.map(d => d.volume || currentVolume);
          const rsiValues = priceHistory.map((d, i) => currentRsi + (Math.random() - 0.5) * 10); // Simulated RSI history

          // Prepare training data: [price, rsi, volume] -> next_price
          const features = [];
          const labels = [];

          for (let i = 0; i < prices.length - 1; i++) {
            features.push([
              prices[i],
              rsiValues[i],
              volumes[i] / 1000000  // Normalize volume
            ]);
            labels.push(prices[i + 1]);
          }

          // Create tensors
          const xs = tf.tensor2d(features);
          const ys = tf.tensor2d(labels, [labels.length, 1]);

          // Build enhanced model
          const model = tf.sequential();
          model.add(tf.layers.dense({
            units: 16,
            activation: 'relu',
            inputShape: [3]
          }));
          model.add(tf.layers.dropout({ rate: 0.2 }));
          model.add(tf.layers.dense({
            units: 8,
            activation: 'relu'
          }));
          model.add(tf.layers.dense({
            units: 1
          }));

          // Compile model
          model.compile({
            optimizer: tf.train.adam(0.01),
            loss: 'meanSquaredError',
            metrics: ['mae']
          });

          // Train model
          await model.fit(xs, ys, {
            epochs: 50,
            verbose: 0,
            shuffle: true,
            validationSplit: 0.1
          });

          // Make prediction for next price
          const lastInput = tf.tensor2d([[
            prices[prices.length - 1],
            currentRsi,
            currentVolume / 1000000
          ]]);

          const prediction = model.predict(lastInput);
          const predictedPrice = prediction.dataSync()[0];

          // Calculate confidence based on recent volatility
          const recentPrices = prices.slice(-10);
          const volatility = calculateVolatility(recentPrices);
          const confidence = Math.max(0, Math.min(100, 100 - (volatility * 2)));

          // Cleanup tensors
          xs.dispose();
          ys.dispose();
          lastInput.dispose();
          prediction.dispose();
          model.dispose();

          console.log(`âœ… Advanced ML prediction: $${predictedPrice.toFixed(2)} (confidence: ${confidence.toFixed(0)}%)`);

          return {
            predictedPrice: predictedPrice,
            confidence: confidence,
            method: 'enhanced_ml'
          };

        } catch (error) {
          console.error('âŒ Advanced ML prediction error:', error);
          return null;
        }
      }

      // Helper: Calculate volatility
      function calculateVolatility(prices) {
        if (prices.length < 2) return 0;
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
          returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
        }
        const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
        return Math.sqrt(variance) * 100;
      }
    }

    function formatMLPrediction(pred) {
      if (pred == null || isNaN(pred)) return 'â€”';
      const sign = pred > 0 ? '+' : '';
      return `${sign}${pred.toFixed(1)}%`;
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIER 3: PDF EXPORT / TEAR SHEET
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function exportStockTearSheet(stock) {
      try {
        console.log(`ğŸ“„ Generating PDF tear sheet for ${stock.symbol}...`);

        // Get the modal content element
        const element = document.getElementById('stock-modal-content');
        if (!element) {
          console.error('Stock modal content not found');
          return;
        }

        // Show loading indicator
        const originalContent = element.innerHTML;
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
        loadingDiv.innerHTML = '<div class="text-white text-lg"><i class="fas fa-spinner animate-spin mr-2"></i>Generating PDF...</div>';
        element.appendChild(loadingDiv);

        // Wait a moment for rendering
        await new Promise(resolve => setTimeout(resolve, 100));

        // Capture the modal as a canvas
        const canvas = await html2canvas(element, {
          backgroundColor: '#0f172a',
          scale: 2, // Higher quality
          logging: false,
          useCORS: true
        });

        // Remove loading indicator
        element.removeChild(loadingDiv);

        // Convert canvas to image
        const imgData = canvas.toDataURL('image/png');

        // Create PDF
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');

        // Calculate dimensions to fit A4
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = (canvas.height * pdfWidth) / canvas.width;

        // Add image to PDF
        pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);

        // Generate filename with date
        const date = new Date().toISOString().split('T')[0];
        const filename = `${stock.symbol}_TearSheet_${date}.pdf`;

        // Download
        pdf.save(filename);

        console.log(`âœ“ PDF tear sheet saved: ${filename}`);

      } catch (error) {
        console.error('PDF export error:', error);
        alert('Failed to generate PDF. Please try again.');
      }
    }






    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1 ENHANCED - Export & Demo Mode Functions
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function exportScreenerResults(stocks) {
      const timestamp = new Date().toISOString().split('T')[0];
      const headers = ['Symbol', 'Name', 'Price', 'Change%', 'P/E', 'ROE%', 'Growth%', 'Score', 'Verdict'];
      const rows = stocks.map(s => [
        s.symbol, s.name, s.price?.toFixed(2), s.changePct?.toFixed(2),
        s.pe?.toFixed(1), s.roe?.toFixed(1), s.revenueGrowth?.toFixed(1),
        s.aiScore, s.verdict
      ]);
      const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `screener_${timestamp}.csv`;
      a.click();
    }

    function toggleDemoMode() {
      isDemoMode = !isDemoMode;
      console.log('Demo mode:', isDemoMode ? 'ON' : 'OFF');
      window.location.reload(); // Reload to apply demo data
    }


    const getSmartInsight = (stock) => {
      if (!stock) return null;

      // 1. Earnings (High Priority)
      if (stock.lastEarnings && stock.lastEarnings.date) {
        const earningsDate = new Date(stock.lastEarnings.date);
        const today = new Date();
        const diffTime = earningsDate - today;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays >= 0 && diffDays <= 7) return { text: `Earnings in ${diffDays}d`, color: 'text-yellow-400', icon: 'ğŸ“…' };
        if (diffDays < 0 && diffDays >= -2) return { text: `Earnings just reported`, color: 'text-blue-400', icon: 'ğŸ“¢' };
      }

      // 2. Technical Extremes
      if (stock.rsi < 30) return { text: `RSI Oversold (${stock.rsi.toFixed(0)})`, color: 'text-green-400', icon: 'ğŸ“‰' };
      if (stock.rsi > 75) return { text: `RSI Overbought (${stock.rsi.toFixed(0)})`, color: 'text-red-400', icon: 'ğŸ“ˆ' };

      // 3. Momentum
      if (stock.changePct > 5) return { text: `Big Move Up (+${stock.changePct.toFixed(1)}%)`, color: 'text-green-400', icon: 'ğŸš€' };
      if (stock.changePct < -5) return { text: `Big Drop (${stock.changePct.toFixed(1)}%)`, color: 'text-red-400', icon: 'ğŸ©¸' };

      // 4. Analyst Upside
      if (stock.upside > 30) return { text: `Analyst Upside +${stock.upside.toFixed(0)}%`, color: 'text-cyan-400', icon: 'ğŸ¯' };

      // 5. Fundamentals
      if (stock.revenueGrowth > 30) return { text: `High Growth (+${stock.revenueGrowth.toFixed(0)}%)`, color: 'text-purple-400', icon: 'ğŸŒ±' };
      if (stock.pe > 0 && stock.pe < 10) return { text: `Deep Value (P/E ${stock.pe.toFixed(1)})`, color: 'text-emerald-400', icon: 'ğŸ’°' };

      // 6. AI Verdict
      if (stock.verdict === 'STRONG BUY') return { text: 'AI Strong Buy', color: 'text-green-400', icon: 'ğŸ¤–' };
      if (stock.verdict === 'SELL') return { text: 'AI Sell Signal', color: 'text-red-400', icon: 'âš ï¸' };

      return { text: stock.sector || 'Neutral', color: 'text-slate-500', icon: 'ğŸ¢' };
    };

    const ALL_COLUMNS = [
      { key: 'watchlist', label: 'â­', category: 'core', tooltip: 'Add to watchlist' },
      { key: 'symbol', label: 'Symbol', category: 'core' },
      { key: 'smartInsight', label: 'Smart Insight', category: 'core', tooltip: 'Key reason to watch this stock right now' },
      { key: 'price', label: 'Price', category: 'core' },
      { key: 'changePct', label: 'Change%', category: 'core' },
      { key: 'volume', label: 'Volume', category: 'core' },
      { key: 'sparkline', label: 'Sparkline', category: 'core' },

      // Valuation
      { key: 'pe', label: 'P/E', category: 'valuation' },
      { key: 'priceToBook', label: 'P/B', category: 'valuation' },
      { key: 'priceToSales', label: 'P/S', category: 'valuation' },
      { key: 'evToEbitda', label: 'EV/EBITDA', category: 'valuation' },

      // Profitability
      { key: 'roe', label: 'ROE%', category: 'profitability' },
      { key: 'roa', label: 'ROA%', category: 'profitability' },
      { key: 'roic', label: 'ROIC%', category: 'profitability' },
      { key: 'grossMargin', label: 'Gross Margin%', category: 'profitability' },
      { key: 'operatingMargin', label: 'Operating Margin%', category: 'profitability' },
      { key: 'netMargin', label: 'Net Margin%', category: 'profitability' },

      // Growth
      { key: 'revenueGrowth', label: 'Revenue Growth%', category: 'growth' },
      { key: 'netIncomeGrowth', label: 'Income Growth%', category: 'growth' },
      { key: 'epsGrowth', label: 'EPS Growth%', category: 'growth' },

      // Financial Health
      { key: 'currentRatio', label: 'Current Ratio', category: 'financial' },
      { key: 'quickRatio', label: 'Quick Ratio', category: 'financial' },
      { key: 'debtToEquity', label: 'Debt/Equity', category: 'financial' },
      { key: 'debtToAssets', label: 'Debt/Assets', category: 'financial' },
      { key: 'cashRatio', label: 'Cash Ratio', category: 'financial' },

      // Quality Scores
      { key: 'piotroskiScore', label: 'Piotroski', category: 'quality' },
      { key: 'altmanZScore', label: 'Altman Z', category: 'quality' },

      // Analyst Data
      { key: 'analystRating', label: 'FMP Rating', category: 'analyst' },
      { key: 'priceTargetAvg', label: 'Price Target', category: 'analyst' },
      { key: 'analystCount', label: 'Analyst Count', category: 'analyst' },

      { key: 'beta', label: 'Beta', category: 'technical', tooltip: 'Measure of volatility relative to the market. >1 is more volatile, <1 is less volatile.' },
      { key: 'rsi', label: 'RSI', category: 'technical' },
      { key: 'index', label: 'Index', category: 'core' },

      // ML & AI
      { key: 'mlPrediction', label: 'ML 30d', category: 'ml', tooltip: 'Machine learning prediction of 30-day price movement based on 60 days of historical data. Positive % = expected gain, Negative % = expected decline.' },
      { key: 'verdict', label: 'Verdict', category: 'core' },
    ];

    const DEFAULT_VISIBLE = ['watchlist', 'symbol', 'smartInsight', 'price', 'changePct', 'pe', 'roe', 'analystRating', 'mlPrediction', 'verdict'];

    const PRESET_SCREENS = {
      // Buffett and Magic Formula filters - REMOVED
      growth: {
        name: 'Growth',
        filters: {
          roe_min: 10,      // Was 15
          revenueGrowth_min: 5  // Was 10
        }
      },
      momentum: {
        name: 'Momentum',
        filters: {
          changePct_min: 0.5,  // Was 1
          rsi_min: 50          // Was 55
        }
      },
      oversold: {
        name: 'Oversold',
        filters: {
          rsi_max: 40  // Was 35
        }
      },
      // Add a new "Value" preset that will almost always show stocks
      value: {
        name: 'Value',
        filters: {
          pe_max: 25,
          debtToEquity_max: 1.5
        }
      },
    };


    const SECTORS = [
      'Technology', 'Healthcare', 'Financial Services', 'Consumer Cyclical', 'Industrials',
      'Communication Services', 'Consumer Defensive', 'Energy', 'Real Estate', 'Utilities', 'Basic Materials'
    ];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITY FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const formatNumber = (val, decimals = 2) => {
      if (val == null || isNaN(val)) return 'â€”';
      if (Math.abs(val) >= 1e12) return `${(val / 1e12).toFixed(1)}T`;
      if (Math.abs(val) >= 1e9) return `${(val / 1e9).toFixed(1)}B`;
      if (Math.abs(val) >= 1e6) return `${(val / 1e6).toFixed(1)}M`;
      return val.toFixed(decimals);
    };

    const formatPercent = (val, decimals = 1) => {
      if (val == null || isNaN(val)) return 'â€”';
      return `${val > 0 ? '+' : ''}${val.toFixed(decimals)}%`;
    };

    const formatCurrency = (val) => {
      if (val == null || isNaN(val)) return '$â€”';
      return `$${formatNumber(val)}`;
    };

    const formatDateSafe = (value, fallback = 'â€”') => {
      if (!value) return fallback;
      const t = new Date(value).getTime();
      if (!Number.isFinite(t)) return fallback;
      try {
        return new Date(t).toLocaleDateString();
      } catch {
        return fallback;
      }
    };

    const getSentimentColor = (val) => {
      if (val == null || isNaN(val)) return 'text-slate-500';
      if (val > 0) return 'text-green-400';
      if (val < 0) return 'text-red-400';
      return 'text-yellow-400';
    };

    const getHealthColor = (health) => {
      if (health >= 70) return 'bg-green-500';
      if (health >= 40) return 'bg-yellow-500';
      return 'bg-red-500';
    };

    const exportToCSV = (data, filename = 'export.csv') => {
      if (!data || !data.length) return;

      const headers = Object.keys(data[0]);
      const csvContent = [
        headers.join(','),
        ...data.map(row => headers.map(header => {
          const cell = row[header];
          if (cell == null) return '';
          // Escape quotes and wrap in quotes if contains comma
          const stringCell = String(cell);
          return stringCell.includes(',') ? `"${stringCell.replace(/"/g, '""')}"` : stringCell;
        }).join(','))
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REAL-TIME DATA ENGINE (Finnhub WebSocket + Smart Polling)
    // Cost: FREE with existing Finnhub API key!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class RealtimeDataManager {
      constructor(apiKey = API_KEYS.FINNHUB) {
        this.apiKey = apiKey;
        this.ws = null;
        this.subscribers = new Map(); // symbol -> [callbacks]
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3; // Reduced from 5
        this.reconnectDelay = 1000;

        this.isConnected = false;
        this.lastPrices = new Map(); // symbol -> last known price
        this.connectionListeners = [];
        this.websocketDisabled = false; // Flag to disable WebSocket permanently if not supported
      }

      connect() {
        // Don't attempt connection if WebSocket is permanently disabled
        if (this.websocketDisabled) {
          console.log('âš ï¸ WebSocket disabled (free tier limitation). Using smart polling instead.');
          return;
        }

        // Skip WebSocket in browser environments (CORS restrictions)
        const isBrowser = typeof window !== 'undefined';
        if (isBrowser) {
          console.log('âš ï¸ WebSocket disabled in browser (CORS restrictions). Using manual refresh instead.');
          return;
        }

        if (this.ws?.readyState === WebSocket.OPEN) {
          console.log('âœ… WebSocket already connected');
          return;
        }

        // Only log on first attempt to reduce console spam
        if (this.reconnectAttempts === 0) {
          console.log('ğŸ”Œ Connecting to Finnhub WebSocket...');
          console.log(`ğŸ”‘ Using API key: ${this.apiKey.substring(0, 10)}...`);
        }

        try {
          this.ws = new WebSocket(`wss://ws.finnhub.io?token=${this.apiKey}`);

          this.ws.onopen = () => {
            console.log('âœ… WebSocket connected successfully!');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.notifyConnectionChange(true);

            // Resubscribe to all symbols
            this.subscribers.forEach((_, symbol) => {
              this.ws.send(JSON.stringify({ type: 'subscribe', symbol: symbol }));
              console.log(`ğŸ“¡ Resubscribed to ${symbol}`);
            });
          };

          this.ws.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);

              if (data.type === 'trade' && data.data) {
                // Process real-time trades
                data.data.forEach(trade => {
                  const symbol = trade.s;
                  const price = trade.p;
                  const volume = trade.v;
                  const timestamp = trade.t;

                  // Store last price
                  const lastPrice = this.lastPrices.get(symbol);
                  this.lastPrices.set(symbol, price);

                  // Calculate change
                  const change = lastPrice ? ((price - lastPrice) / lastPrice * 100) : 0;

                  // Notify subscribers
                  const callbacks = this.subscribers.get(symbol);
                  if (callbacks) {
                    callbacks.forEach(cb => {
                      try {
                        cb({
                          symbol,
                          price,
                          volume,
                          timestamp,
                          quoteFetchedAt: timestamp,
                          change,
                          source: 'websocket'
                        });
                      } catch (err) {
                        console.error(`Error in callback for ${symbol}:`, err);
                      }
                    });
                  }
                });
              }
            } catch (error) {
              console.error('âŒ Error processing WebSocket message:', error);
            }
          };

          this.ws.onerror = (error) => {
            // Suppress error logging on reconnection attempts (just noise)
            if (this.reconnectAttempts === 0) {
              console.log('âš ï¸ WebSocket connection error (checking connectivity...)');
            }
          };

          this.ws.onclose = (event) => {
            // Only log meaningful close events
            if (this.reconnectAttempts === 0 && event.code !== 1006) {
              console.log(`ğŸ”Œ WebSocket disconnected (code: ${event.code})`);
            }
            this.isConnected = false;
            this.notifyConnectionChange(false);
            this.reconnect();
          };
        } catch (error) {
          console.error('âŒ Failed to create WebSocket:', error);
          this.reconnect();
        }
      }

      reconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
          console.warn('âš ï¸ WebSocket connection failed (likely free tier limitation)');
          console.log('ğŸ“Š Continuing with smart polling for data updates');
          // âœ… KEEP WebSocket enabled by default - don't permanently disable
          // this.websocketDisabled = true; // REMOVED - This prevents WebSocket connection!
          this.notifyConnectionChange(false);
          return;
        }

        this.reconnectAttempts++;
        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

        // Only log on first few attempts
        if (this.reconnectAttempts <= 2) {
          console.log(`ğŸ”„ Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        }

        setTimeout(() => this.connect(), delay);
      }

      subscribe(symbol, callback) {
        if (!this.subscribers.has(symbol)) {
          this.subscribers.set(symbol, []);

          // Send subscribe message if connected
          if (this.isConnected && this.ws?.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'subscribe', symbol: symbol }));
            console.log(`ğŸ“¡ Subscribed to ${symbol} real-time updates`);
          }
        }

        this.subscribers.get(symbol).push(callback);
        console.log(`âœ… Added subscriber for ${symbol} (total: ${this.subscribers.get(symbol).length})`);
      }

      unsubscribe(symbol, callback) {
        const callbacks = this.subscribers.get(symbol);
        if (!callbacks) return;

        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
          console.log(`âœ… Removed subscriber for ${symbol} (remaining: ${callbacks.length})`);
        }

        // If no more subscribers, unsubscribe from WebSocket
        if (callbacks.length === 0) {
          this.subscribers.delete(symbol);
          if (this.isConnected && this.ws?.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'unsubscribe', symbol: symbol }));
            console.log(`ğŸ“¡ Unsubscribed from ${symbol}`);
          }
        }
      }

      disconnect() {
        if (this.ws) {
          console.log('ğŸ”Œ Disconnecting WebSocket...');
          this.ws.close();
          this.ws = null;
        }
        this.subscribers.clear();
        this.isConnected = false;
        this.lastPrices.clear();
        this.notifyConnectionChange(false);
      }

      onConnectionChange(callback) {
        this.connectionListeners.push(callback);
      }

      notifyConnectionChange(connected) {
        this.connectionListeners.forEach(cb => {
          try {
            cb(connected);
          } catch (err) {
            console.error('Error in connection listener:', err);
          }
        });
      }

      getStatus() {
        return {
          connected: this.isConnected,
          subscribedSymbols: Array.from(this.subscribers.keys()),
          totalSubscribers: Array.from(this.subscribers.values()).reduce((sum, arr) => sum + arr.length, 0)
        };
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART POLLING (Fallback for when WebSocket not available)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class SmartPoller {
      constructor(options = {}) {
        this.intervals = new Map(); // symbol -> interval ID
        // Default: 60 minutes (3600000ms)
        this.baseUpdateFrequency = options.frequency || 60 * 60 * 1000; // 60 minutes minimum update interval
        this.offHoursFrequency = options.offHoursFrequency || 60 * 60 * 1000; // 60 minutes when market closed
      }

      async pollStock(symbol, callback) {
        // Skip polling in browser environments
        const isBrowser = typeof window !== 'undefined';
        if (isBrowser) {
          console.log(`â±ï¸ Polling skipped in browser for ${symbol}`);
          return;
        }

        // Clean symbol to remove exchange suffixes (.O, .K, etc.)
        symbol = cleanSymbol(symbol);

        try {
          console.log(`â±ï¸ Polling ${symbol}...`);

          // Use existing smartFetch with fallback (will skip Finnhub in browsers)
          const result = await smartFetch('quote', symbol);

          if (result?.data?.[0]) {
            const data = result.data[0];
            callback({
              symbol,
              price: data.price,
              change: data.change,
              changesPercentage: data.changesPercentage,
              volume: data.volume,
              quoteFetchedAt: Date.now(),
              source: 'polling'
            });
            console.log(`âœ… Polled ${symbol}: $${data.price}`);
          }
        } catch (error) {
          // Don't log errors for browser environments (expected)
          const isBrowser = typeof window !== 'undefined';
          if (!isBrowser) {
            console.error(`âŒ Polling error for ${symbol}:`, error);
          }
        }
      }

      startPolling(symbol, callback, customFrequency = null) {
        if (this.intervals.has(symbol)) {
          console.log(`â±ï¸ Already polling ${symbol}`);
          return;
        }

        const frequency = customFrequency || (Cache.isMarketOpen()
          ? this.baseUpdateFrequency
          : this.offHoursFrequency);

        // Immediate fetch
        this.pollStock(symbol, callback);

        // Set interval
        const intervalId = setInterval(() => {
          this.pollStock(symbol, callback);
        }, frequency);

        this.intervals.set(symbol, intervalId);
        console.log(`â±ï¸ Started polling ${symbol} every ${Math.floor(frequency / 60000)} minutes`);
      }

      stopPolling(symbol) {
        const intervalId = this.intervals.get(symbol);
        if (intervalId) {
          clearInterval(intervalId);
          this.intervals.delete(symbol);
          console.log(`â±ï¸ Stopped polling ${symbol}`);
        }
      }

      stopAll() {
        console.log(`â±ï¸ Stopping all polling (${this.intervals.size} symbols)`);
        this.intervals.forEach(id => clearInterval(id));
        this.intervals.clear();
      }

      getPollingSymbols() {
        return Array.from(this.intervals.keys());
      }
    }

    // Initialize global instances
    const realtimeData = new RealtimeDataManager();
    const smartPoller = new SmartPoller();

    // WebSocket disabled (free tier limitation) - using smart polling instead
    // Smart polling provides real-time updates without WebSocket connection
    console.log('ğŸ“Š Real-time updates enabled via smart polling');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SOCIAL SENTIMENT ENGINE (StockTwits + Community Data)
    // Cost: FREE - No API key required!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class SocialSentimentManager {
      constructor() {
        this.cache = new Map(); // symbol -> social data
        this.cacheExpiry = 300000; // 5 minutes
      }

      async fetchSocialSentiment(symbol) {
        try {
          console.log(`ğŸ’¬ Fetching social sentiment for ${symbol}...`);

          // Check cache
          const cached = this.cache.get(symbol);
          if (cached && (Date.now() - cached.timestamp) < this.cacheExpiry) {
            console.log(`ğŸ’¾ Using cached social sentiment for ${symbol}`);
            return cached.data;
          }

          // Fetch from multiple social sources in parallel
          const [stockTwitsData, redditData] = await Promise.all([
            this.fetchStockTwits(symbol),
            this.fetchRedditSentiment(symbol)
          ]);

          // Combine data from both sources
          const combined = this.combineSocialData(stockTwitsData, redditData, symbol);

          // Cache result
          this.cache.set(symbol, { data: combined, timestamp: Date.now() });

          console.log(`âœ… Combined social sentiment: ${combined.overallSentiment} (StockTwits: ${stockTwitsData.totalMessages} | Reddit: ${redditData.totalPosts} posts)`);

          return combined;

        } catch (error) {
          console.error(`âŒ Error fetching social sentiment for ${symbol}:`, error);
          return this.getDefaultSentiment();
        }
      }

      async fetchStockTwits(symbol) {
        try {
          // Use proxy server to avoid CORS
          const response = await fetchWithRetry(`${API_BASE_URL}/api/stocktwits/${symbol}`, { timeoutMs: 12000, retries: 1 });

          if (!response.ok) {
            console.log(`âš ï¸ StockTwits API returned ${response.status}`);
            return { totalMessages: 0, bullishCount: 0, bearishCount: 0, neutralCount: 0, messages: [] };
          }

          const data = await response.json();

          if (!data.messages || data.messages.length === 0) {
            return { totalMessages: 0, bullishCount: 0, bearishCount: 0, neutralCount: 0, messages: [] };
          }

          const messages = data.messages;
          let bullishCount = 0;
          let bearishCount = 0;
          let neutralCount = 0;

          messages.forEach(msg => {
            if (msg.entities && msg.entities.sentiment) {
              const sentiment = msg.entities.sentiment.basic;
              if (sentiment === 'Bullish') bullishCount++;
              else if (sentiment === 'Bearish') bearishCount++;
              else neutralCount++;
            } else {
              neutralCount++;
            }
          });

          return {
            totalMessages: messages.length,
            bullishCount,
            bearishCount,
            neutralCount,
            messages: messages.slice(0, 5).map(msg => ({
              text: msg.body,
              user: msg.user.username,
              sentiment: msg.entities?.sentiment?.basic || 'Neutral',
              timestamp: msg.created_at,
              likes: msg.likes?.total || 0,
              source: 'StockTwits'
            }))
          };

        } catch (error) {
          console.error(`âŒ StockTwits error:`, error);
          return { totalMessages: 0, bullishCount: 0, bearishCount: 0, neutralCount: 0, messages: [] };
        }
      }

      async fetchRedditSentiment(symbol) {
        try {
          console.log(`ğŸ¤– Fetching Reddit/WSB sentiment for ${symbol}...`);

          // Search WallStreetBets for the stock symbol
          const subreddits = ['wallstreetbets', 'stocks', 'investing'];
          const allPosts = [];

          for (const subreddit of subreddits) {
            try {
              // Use proxy server to avoid CORS
              const searchUrl = `${API_BASE_URL}/api/reddit/${subreddit}/search?q=${symbol}`;
              const response = await fetchWithRetry(searchUrl, { timeoutMs: 12000, retries: 1 });

              if (response.ok) {
                const data = await response.json();
                if (data.data && data.data.children) {
                  allPosts.push(...data.data.children.map(child => ({
                    ...child.data,
                    subreddit: subreddit
                  })));
                }
              }
            } catch (err) {
              console.log(`âš ï¸ Error fetching from r/${subreddit}`);
            }
          }

          if (allPosts.length === 0) {
            return { totalPosts: 0, bullishCount: 0, bearishCount: 0, neutralCount: 0, posts: [] };
          }

          // Analyze sentiment using post titles, scores, and content
          let bullishCount = 0;
          let bearishCount = 0;
          let neutralCount = 0;

          const sentimentAnalyzer = new SentimentAnalyzer();

          const analyzedPosts = allPosts.map(post => {
            const text = (post.title + ' ' + (post.selftext || '')).toLowerCase();
            const sentiment = sentimentAnalyzer.analyzeSentiment(text);

            // Weight by upvotes (more upvoted = more important)
            const weight = Math.log10(Math.max(post.score, 1) + 1);

            if (sentiment.label === 'bullish') {
              bullishCount += weight;
            } else if (sentiment.label === 'bearish') {
              bearishCount += weight;
            } else {
              neutralCount += weight;
            }

            return {
              title: post.title,
              text: post.selftext?.substring(0, 200) || '',
              url: `https://www.reddit.com${post.permalink}`,
              author: post.author,
              score: post.score,
              comments: post.num_comments,
              sentiment: sentiment.label,
              subreddit: post.subreddit,
              timestamp: new Date(post.created_utc * 1000).toISOString()
            };
          });

          // Sort by score (popularity)
          analyzedPosts.sort((a, b) => b.score - a.score);

          return {
            totalPosts: allPosts.length,
            bullishCount: Math.round(bullishCount),
            bearishCount: Math.round(bearishCount),
            neutralCount: Math.round(neutralCount),
            posts: analyzedPosts.slice(0, 5)
          };

        } catch (error) {
          console.error(`âŒ Reddit API error:`, error);
          return { totalPosts: 0, bullishCount: 0, bearishCount: 0, neutralCount: 0, posts: [] };
        }
      }

      combineSocialData(stockTwits, reddit, symbol) {
        const totalMessages = stockTwits.totalMessages + reddit.totalPosts;

        if (totalMessages === 0) {
          return this.getDefaultSentiment();
        }

        // Combine counts with weighted average (StockTwits 40%, Reddit 60% - Reddit is more influential)
        const stWeight = 0.4;
        const rdWeight = 0.6;

        const bullishCount = Math.round(
          (stockTwits.bullishCount * stWeight + reddit.bullishCount * rdWeight)
        );
        const bearishCount = Math.round(
          (stockTwits.bearishCount * stWeight + reddit.bearishCount * rdWeight)
        );
        const neutralCount = Math.round(
          (stockTwits.neutralCount * stWeight + reddit.neutralCount * rdWeight)
        );

        const total = bullishCount + bearishCount + neutralCount || 1;
        const bullishPercent = (bullishCount / total * 100);
        const bearishPercent = (bearishCount / total * 100);
        const neutralPercent = (neutralCount / total * 100);

        // Determine overall sentiment
        let overallSentiment = 'neutral';
        let sentimentScore = 0;

        if (bullishCount > bearishCount * 1.3) {
          overallSentiment = 'bullish';
          sentimentScore = Math.round(bullishPercent - bearishPercent);
        } else if (bearishCount > bullishCount * 1.3) {
          overallSentiment = 'bearish';
          sentimentScore = -Math.round(bearishPercent - bullishPercent);
        } else {
          overallSentiment = 'neutral';
          sentimentScore = Math.round(bullishPercent - bearishPercent);
        }

        return {
          source: 'StockTwits + Reddit',
          totalMessages,
          stockTwitsCount: stockTwits.totalMessages,
          redditCount: reddit.totalPosts,
          bullishCount,
          bearishCount,
          neutralCount,
          bullishPercent: Math.round(bullishPercent),
          bearishPercent: Math.round(bearishPercent),
          neutralPercent: Math.round(neutralPercent),
          overallSentiment,
          sentimentScore,
          messages: [
            ...stockTwits.messages.slice(0, 3),
            ...reddit.posts.slice(0, 2).map(post => ({
              text: post.title,
              user: post.author,
              sentiment: post.sentiment,
              timestamp: post.timestamp,
              likes: post.score,
              source: 'Reddit',
              url: post.url,
              subreddit: post.subreddit
            }))
          ],
          redditPosts: reddit.posts,
          trending: totalMessages > 30 || reddit.totalPosts > 20,
          timestamp: Date.now()
        };
      }

      getDefaultSentiment() {
        return {
          source: 'N/A',
          totalMessages: 0,
          bullishCount: 0,
          bearishCount: 0,
          neutralCount: 0,
          bullishPercent: 0,
          bearishPercent: 0,
          neutralPercent: 0,
          overallSentiment: 'neutral',
          sentimentScore: 0,
          messages: [],
          trending: false,
          timestamp: Date.now()
        };
      }

      clearCache() {
        this.cache.clear();
      }
    }

    // Initialize social sentiment manager
    const socialSentiment = new SocialSentimentManager();
    window.socialSentiment = socialSentiment;
    console.log('âœ… Social Sentiment Manager initialized');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PATTERN RECOGNITION ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class PatternRecognitionEngine {
      constructor() {
        this.patterns = {
          HEAD_AND_SHOULDERS: {
            name: 'Head & Shoulders',
            type: 'reversal',
            reliability: 0.75,
            description: 'Potential trend reversal from bullish to bearish'
          },
          CUP_WITH_HANDLE: {
            name: 'Cup with Handle',
            type: 'continuation',
            reliability: 0.80,
            description: 'Bullish continuation pattern'
          },
          DOUBLE_TOP: {
            name: 'Double Top',
            type: 'reversal',
            reliability: 0.70,
            description: 'Bearish reversal pattern'
          },
          DOUBLE_BOTTOM: {
            name: 'Double Bottom',
            type: 'reversal',
            reliability: 0.70,
            description: 'Bullish reversal pattern'
          },
          ASCENDING_TRIANGLE: {
            name: 'Ascending Triangle',
            type: 'continuation',
            reliability: 0.75,
            description: 'Bullish continuation pattern'
          },
          DESCENDING_TRIANGLE: {
            name: 'Descending Triangle',
            type: 'continuation',
            reliability: 0.75,
            description: 'Bearish continuation pattern'
          },
          FLAG: {
            name: 'Flag Pattern',
            type: 'continuation',
            reliability: 0.70,
            description: 'Brief consolidation before continuing trend'
          },
          WEDGE: {
            name: 'Wedge',
            type: 'reversal',
            reliability: 0.65,
            description: 'Potential trend reversal'
          },
          SYMMETRICAL_TRIANGLE: {
            name: 'Symmetrical Triangle',
            type: 'continuation',
            reliability: 0.68,
            description: 'Neutral pattern - breakout direction determines trend'
          },
          PENNANT: {
            name: 'Pennant',
            type: 'continuation',
            reliability: 0.72,
            description: 'Brief consolidation during strong trend'
          },
          TRIPLE_TOP: {
            name: 'Triple Top',
            type: 'reversal',
            reliability: 0.75,
            description: 'Strong bearish reversal signal'
          },
          TRIPLE_BOTTOM: {
            name: 'Triple Bottom',
            type: 'reversal',
            reliability: 0.75,
            description: 'Strong bullish reversal signal'
          },
          RISING_WEDGE: {
            name: 'Rising Wedge',
            type: 'reversal',
            reliability: 0.70,
            description: 'Bearish reversal - rising with declining volume'
          },
          FALLING_WEDGE: {
            name: 'Falling Wedge',
            type: 'reversal',
            reliability: 0.70,
            description: 'Bullish reversal - falling with declining volume'
          },
          ROUNDING_BOTTOM: {
            name: 'Rounding Bottom',
            type: 'reversal',
            reliability: 0.73,
            description: 'Gradual bullish reversal (saucer pattern)'
          },
          RECTANGLE: {
            name: 'Rectangle',
            type: 'continuation',
            reliability: 0.65,
            description: 'Consolidation range - awaiting breakout'
          },
          INVERSE_HEAD_SHOULDERS: {
            name: 'Inverse Head and Shoulders',
            type: 'reversal',
            reliability: 0.85,
            description: 'Strong bullish reversal signal'
          }
        };
      }

      detectPatterns(candles, patternTypes = null) {
        if (!candles || candles.length < 20) return [];

        const detected = [];
        const closes = candles.map(c => c.close || c);
        const highs = candles.map(c => c.high || c.close || c);
        const lows = candles.map(c => c.low || c.close || c);

        // Convert to find patterns
        if (!patternTypes || patternTypes.includes('HEAD_AND_SHOULDERS')) {
          const hns = this.detectHeadAndShoulders(highs, lows, closes);
          if (hns) detected.push(hns);
        }

        if (!patternTypes || patternTypes.includes('CUP_WITH_HANDLE')) {
          const cup = this.detectCupAndHandle(highs, lows, closes);
          if (cup) detected.push(cup);
        }

        if (!patternTypes || patternTypes.includes('DOUBLE_TOP')) {
          const dt = this.detectDoubleTop(highs, closes);
          if (dt) detected.push(dt);
        }

        if (!patternTypes || patternTypes.includes('DOUBLE_BOTTOM')) {
          const db = this.detectDoubleBottom(lows, closes);
          if (db) detected.push(db);
        }

        if (!patternTypes || patternTypes.includes('TRIPLE_TOP')) {
          const tt = this.detectTripleTop(highs, closes);
          if (tt) detected.push(tt);
        }

        if (!patternTypes || patternTypes.includes('TRIPLE_BOTTOM')) {
          const tb = this.detectTripleBottom(lows, closes);
          if (tb) detected.push(tb);
        }

        if (!patternTypes || patternTypes.includes('SYMMETRICAL_TRIANGLE')) {
          const st = this.detectSymmetricalTriangle(highs, lows, closes);
          if (st) detected.push(st);
        }

        if (!patternTypes || patternTypes.includes('ASCENDING_TRIANGLE')) {
          const at = this.detectAscendingTriangle(highs, lows, closes);
          if (at) detected.push(at);
        }

        if (!patternTypes || patternTypes.includes('DESCENDING_TRIANGLE')) {
          const dt = this.detectDescendingTriangle(highs, lows, closes);
          if (dt) detected.push(dt);
        }

        if (!patternTypes || patternTypes.includes('RISING_WEDGE')) {
          const rw = this.detectRisingWedge(highs, lows, closes);
          if (rw) detected.push(rw);
        }

        if (!patternTypes || patternTypes.includes('FALLING_WEDGE')) {
          const fw = this.detectFallingWedge(highs, lows, closes);
          if (fw) detected.push(fw);
        }

        if (!patternTypes || patternTypes.includes('PENNANT')) {
          const pennant = this.detectPennant(highs, lows, closes);
          if (pennant) detected.push(pennant);
        }

        if (!patternTypes || patternTypes.includes('RECTANGLE')) {
          const rect = this.detectRectangle(highs, lows, closes);
          if (rect) detected.push(rect);
        }

        if (!patternTypes || patternTypes.includes('ROUNDING_BOTTOM')) {
          const rb = this.detectRoundingBottom(lows, closes);
          if (rb) detected.push(rb);
        }

        if (!patternTypes || patternTypes.includes('INVERSE_HEAD_SHOULDERS')) {
          const ihs = this.detectInverseHeadAndShoulders(highs, lows, closes);
          if (ihs) detected.push(ihs);
        }

        if (!patternTypes || patternTypes.includes('FLAG')) {
          const flag = this.detectFlag(highs, lows, closes);
          if (flag) detected.push(flag);
        }

        return detected.sort((a, b) => b.confidence - a.confidence);
      }

      detectHeadAndShoulders(highs, lows, closes) {
        // Simplified detection: looks for 5-point structure
        const window = 30; // 30 candles window
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const pivotPoints = this.findPivotPoints(recentHighs, 5);

        if (pivotPoints.length >= 5) {
          const [leftShoulder, head, rightShoulder] = this.extractHSPattern(pivotPoints);

          if (this.validateHSStructure(leftShoulder, head, rightShoulder)) {
            return {
              type: 'HEAD_AND_SHOULDERS',
              pattern: this.patterns.HEAD_AND_SHOULDERS,
              startIndex: pivotPoints[0].index,
              endIndex: pivotPoints[pivotPoints.length - 1].index,
              confidence: this.calculateHSConfidence(leftShoulder, head, rightShoulder),
              neckline: this.calculateNeckline(lows, pivotPoints),
              implications: 'Bearish reversal',
              targetPrice: this.calculateHSTarget(closes, pivotPoints)
            };
          }
        }
        return null;
      }

      detectCupAndHandle(highs, lows, closes) {
        // Looks for U-shape followed by smaller consolidation
        const window = 40;
        if (closes.length < window) return null;

        const recentCloses = closes.slice(-window);
        const cupBottom = this.findCupBottom(recentCloses);

        if (cupBottom.found) {
          const handle = this.detectHandle(recentCloses, cupBottom);
          if (handle.found) {
            return {
              type: 'CUP_WITH_HANDLE',
              pattern: this.patterns.CUP_WITH_HANDLE,
              startIndex: cupBottom.startIndex,
              endIndex: handle.endIndex,
              confidence: handle.confidence,
              cupDepth: cupBottom.depth,
              handleDepth: handle.depth,
              implications: 'Bullish continuation',
              targetPrice: this.calculateCupTarget(recentCloses, cupBottom, handle)
            };
          }
        }
        return null;
      }

      detectDoubleTop(highs, closes) {
        const window = 25;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const peaks = this.findLocalPeaks(recentHighs, 2);

        if (peaks.length >= 2) {
          const [first, second] = peaks.slice(-2);
          const priceDiff = Math.abs(first.value - second.value) / first.value;

          if (priceDiff < 0.03) { // Within 3% of each other
            return {
              type: 'DOUBLE_TOP',
              pattern: this.patterns.DOUBLE_TOP,
              firstPeak: first,
              secondPeak: second,
              confidence: 0.70 * (1 - priceDiff),
              implications: 'Bearish reversal',
              targetPrice: this.calculateDoubleTopTarget(closes, peaks)
            };
          }
        }
        return null;
      }

      detectDoubleBottom(lows, closes) {
        const window = 25;
        if (lows.length < window) return null;

        const recentLows = lows.slice(-window);
        const troughs = this.findLocalTroughs(recentLows, 2);

        if (troughs.length >= 2) {
          const [first, second] = troughs.slice(-2);
          const priceDiff = Math.abs(first.value - second.value) / first.value;

          if (priceDiff < 0.03) {
            return {
              type: 'DOUBLE_BOTTOM',
              pattern: this.patterns.DOUBLE_BOTTOM,
              firstTrough: first,
              secondTrough: second,
              confidence: 0.70 * (1 - priceDiff),
              implications: 'Bullish reversal',
              targetPrice: this.calculateDoubleBottomTarget(closes, troughs)
            };
          }
        }
        return null;
      }

      // Helper methods
      findPivotPoints(data, minPoints) {
        const pivots = [];
        for (let i = 2; i < data.length - 2; i++) {
          if (data[i] > data[i - 1] && data[i] > data[i + 1] &&
            data[i] > data[i - 2] && data[i] > data[i + 2]) {
            pivots.push({ index: i, value: data[i], type: 'high' });
          }
        }
        return pivots;
      }

      findLocalPeaks(data, minPeaks) {
        const peaks = [];
        for (let i = 1; i < data.length - 1; i++) {
          if (data[i] > data[i - 1] && data[i] > data[i + 1]) {
            peaks.push({ index: i, value: data[i] });
          }
        }
        return peaks.sort((a, b) => b.value - a.value).slice(0, minPeaks);
      }

      findLocalTroughs(data, minTroughs) {
        const troughs = [];
        for (let i = 1; i < data.length - 1; i++) {
          if (data[i] < data[i - 1] && data[i] < data[i + 1]) {
            troughs.push({ index: i, value: data[i] });
          }
        }
        return troughs.sort((a, b) => a.value - b.value).slice(0, minTroughs);
      }

      calculateHSConfidence(left, head, right) {
        const symmetry = Math.abs(left.height - right.height) / Math.max(left.height || 1, right.height || 1);
        return Math.max(0.60, 0.90 - symmetry);
      }

      findCupBottom(data) {
        const mid = Math.floor(data.length / 2);
        const bottom = Math.min(...data.slice(mid - 10, mid + 10));
        const bottomIdx = data.indexOf(bottom);

        return {
          found: bottomIdx > 10 && bottomIdx < data.length - 10,
          startIndex: bottomIdx - 15,
          endIndex: bottomIdx + 15,
          depth: (data[0] - bottom) / data[0],
          bottomValue: bottom
        };
      }

      detectHandle(data, cupBottom) {
        const handleStart = cupBottom.endIndex;
        const handleData = data.slice(handleStart, handleStart + 10);
        const handleHigh = Math.max(...handleData);
        const handleLow = Math.min(...handleData);

        return {
          found: (handleHigh - handleLow) / handleHigh < 0.05, // Tight consolidation
          endIndex: handleStart + handleData.length,
          depth: (handleHigh - handleLow) / handleHigh,
          confidence: 0.75
        };
      }

      extractHSPattern(pivots) {
        // Simplified extraction - assumes first 3 pivots form the pattern
        if (pivots.length < 3) return [null, null, null];
        const sorted = [...pivots].sort((a, b) => b.value - a.value);
        const head = sorted[0];
        const shoulders = pivots.filter(p => p.index !== head.index).slice(0, 2);
        return [
          { ...shoulders[0], height: shoulders[0].value },
          { ...head, height: head.value },
          { ...shoulders[1], height: shoulders[1].value }
        ];
      }

      validateHSStructure(left, head, right) {
        if (!left || !head || !right) return false;
        return head.value > left.value && head.value > right.value;
      }

      calculateNeckline(lows, pivots) {
        if (pivots.length < 2) return null;
        const necklineLows = pivots.map(p => lows[p.index] || p.value);
        return necklineLows.reduce((a, b) => a + b, 0) / necklineLows.length;
      }

      calculateHSTarget(closes, pivots) {
        if (pivots.length < 2) return null;
        const neckline = this.calculateNeckline(closes, pivots);
        const head = Math.max(...pivots.map(p => p.value));
        return neckline - (head - neckline);
      }

      calculateCupTarget(closes, cupBottom, handle) {
        const cupRim = Math.max(...closes.slice(cupBottom.startIndex, cupBottom.endIndex));
        const depth = cupRim - cupBottom.bottomValue;
        return cupRim + depth;
      }

      calculateDoubleTopTarget(closes, peaks) {
        if (peaks.length < 2) return null;
        const avgPeak = (peaks[0].value + peaks[1].value) / 2;
        const support = Math.min(...closes.slice(peaks[0].index, peaks[1].index));
        return support - (avgPeak - support);
      }

      calculateDoubleBottomTarget(closes, troughs) {
        if (troughs.length < 2) return null;
        const avgTrough = (troughs[0].value + troughs[1].value) / 2;
        const resistance = Math.max(...closes.slice(troughs[0].index, troughs[1].index));
        return resistance + (resistance - avgTrough);
      }

      detectTripleTop(highs, closes) {
        const window = 30;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const peaks = this.findLocalPeaks(recentHighs, 3);

        if (peaks.length >= 3) {
          const [first, second, third] = peaks.slice(-3);
          const avgPrice = (first.value + second.value + third.value) / 3;
          const maxDiff = Math.max(
            Math.abs(first.value - avgPrice),
            Math.abs(second.value - avgPrice),
            Math.abs(third.value - avgPrice)
          ) / avgPrice;

          if (maxDiff < 0.03) {
            return {
              type: 'TRIPLE_TOP',
              pattern: this.patterns.TRIPLE_TOP,
              peaks: [first, second, third],
              confidence: 0.75 * (1 - maxDiff),
              implications: 'Strong bearish reversal',
              targetPrice: avgPrice - (avgPrice - Math.min(...closes.slice(-window))) * 1.5
            };
          }
        }
        return null;
      }

      detectTripleBottom(lows, closes) {
        const window = 30;
        if (lows.length < window) return null;

        const recentLows = lows.slice(-window);
        const troughs = this.findLocalTroughs(recentLows, 3);

        if (troughs.length >= 3) {
          const [first, second, third] = troughs.slice(-3);
          const avgPrice = (first.value + second.value + third.value) / 3;
          const maxDiff = Math.max(
            Math.abs(first.value - avgPrice),
            Math.abs(second.value - avgPrice),
            Math.abs(third.value - avgPrice)
          ) / avgPrice;

          if (maxDiff < 0.03) {
            return {
              type: 'TRIPLE_BOTTOM',
              pattern: this.patterns.TRIPLE_BOTTOM,
              troughs: [first, second, third],
              confidence: 0.75 * (1 - maxDiff),
              implications: 'Strong bullish reversal',
              targetPrice: avgPrice + (Math.max(...closes.slice(-window)) - avgPrice) * 1.5
            };
          }
        }
        return null;
      }

      detectSymmetricalTriangle(highs, lows, closes) {
        const window = 25;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        // Calculate trendlines
        const highTrend = this.calculateTrendline(recentHighs);
        const lowTrend = this.calculateTrendline(recentLows);

        // Check if lines are converging at similar rates
        const convergenceRate = Math.abs(highTrend.slope + lowTrend.slope) / 2;

        if (convergenceRate < 0.5 && highTrend.slope < 0 && lowTrend.slope > 0) {
          const apex = this.findApex(highTrend, lowTrend);
          return {
            type: 'SYMMETRICAL_TRIANGLE',
            pattern: this.patterns.SYMMETRICAL_TRIANGLE,
            confidence: 0.68,
            apex: apex,
            implications: 'Breakout imminent - direction uncertain',
            targetPrice: null // Depends on breakout direction
          };
        }
        return null;
      }

      detectAscendingTriangle(highs, lows, closes) {
        const window = 25;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        const highTrend = this.calculateTrendline(recentHighs);
        const lowTrend = this.calculateTrendline(recentLows);

        // Flat resistance, rising support
        if (Math.abs(highTrend.slope) < 0.2 && lowTrend.slope > 0.3) {
          const resistance = Math.max(...recentHighs);
          const breakoutTarget = resistance + (resistance - Math.min(...recentLows)) * 0.8;

          return {
            type: 'ASCENDING_TRIANGLE',
            pattern: this.patterns.ASCENDING_TRIANGLE,
            confidence: 0.75,
            resistance: resistance,
            implications: 'Bullish breakout expected',
            targetPrice: breakoutTarget
          };
        }
        return null;
      }

      detectDescendingTriangle(highs, lows, closes) {
        const window = 25;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        const highTrend = this.calculateTrendline(recentHighs);
        const lowTrend = this.calculateTrendline(recentLows);

        // Falling resistance, flat support
        if (highTrend.slope < -0.3 && Math.abs(lowTrend.slope) < 0.2) {
          const support = Math.min(...recentLows);
          const breakdownTarget = support - (Math.max(...recentHighs) - support) * 0.8;

          return {
            type: 'DESCENDING_TRIANGLE',
            pattern: this.patterns.DESCENDING_TRIANGLE,
            confidence: 0.75,
            support: support,
            implications: 'Bearish breakdown expected',
            targetPrice: breakdownTarget
          };
        }
        return null;
      }

      detectRisingWedge(highs, lows, closes) {
        const window = 25;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        const highTrend = this.calculateTrendline(recentHighs);
        const lowTrend = this.calculateTrendline(recentLows);

        // Both rising, but converging
        if (highTrend.slope > 0 && lowTrend.slope > 0 && lowTrend.slope > highTrend.slope) {
          return {
            type: 'RISING_WEDGE',
            pattern: this.patterns.RISING_WEDGE,
            confidence: 0.70,
            implications: 'Bearish reversal - momentum weakening',
            targetPrice: closes[closes.length - 1] * 0.92 // 8% decline expected
          };
        }
        return null;
      }

      detectFallingWedge(highs, lows, closes) {
        const window = 25;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        const highTrend = this.calculateTrendline(recentHighs);
        const lowTrend = this.calculateTrendline(recentLows);

        // Both falling, but converging
        if (highTrend.slope < 0 && lowTrend.slope < 0 && highTrend.slope > lowTrend.slope) {
          return {
            type: 'FALLING_WEDGE',
            pattern: this.patterns.FALLING_WEDGE,
            confidence: 0.70,
            implications: 'Bullish reversal - selling pressure exhausting',
            targetPrice: closes[closes.length - 1] * 1.08 // 8% rally expected
          };
        }
        return null;
      }

      detectPennant(highs, lows, closes) {
        const window = 20;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        // Check for strong prior move
        const priorMove = closes.slice(-window - 10, -window);
        const moveStrength = Math.abs(priorMove[priorMove.length - 1] - priorMove[0]) / priorMove[0];

        if (moveStrength > 0.05) { // At least 5% prior move
          const range = Math.max(...recentHighs) - Math.min(...recentLows);
          const priceLevel = closes[closes.length - 1];
          const consolidationRatio = range / priceLevel;

          if (consolidationRatio < 0.05) { // Tight consolidation
            const priorTrend = priorMove[priorMove.length - 1] > priorMove[0] ? 'bullish' : 'bearish';

            return {
              type: 'PENNANT',
              pattern: this.patterns.PENNANT,
              confidence: 0.72,
              implications: `${priorTrend === 'bullish' ? 'Bullish' : 'Bearish'} continuation expected`,
              targetPrice: priorTrend === 'bullish'
                ? closes[closes.length - 1] * 1.05
                : closes[closes.length - 1] * 0.95
            };
          }
        }
        return null;
      }

      detectRectangle(highs, lows, closes) {
        const window = 20;
        if (highs.length < window) return null;

        const recentHighs = highs.slice(-window);
        const recentLows = lows.slice(-window);

        const resistance = Math.max(...recentHighs);
        const support = Math.min(...recentLows);
        const range = resistance - support;
        const priceLevel = closes[closes.length - 1];

        // Check if price has been bouncing within range
        const withinRange = closes.slice(-window).every(c =>
          c >= support * 0.98 && c <= resistance * 1.02
        );

        if (withinRange && range / priceLevel > 0.03 && range / priceLevel < 0.10) {
          return {
            type: 'RECTANGLE',
            pattern: this.patterns.RECTANGLE,
            confidence: 0.65,
            support: support,
            resistance: resistance,
            implications: 'Consolidation - breakout pending',
            targetPrice: null // Depends on breakout direction
          };
        }
        return null;
      }

      detectRoundingBottom(lows, closes) {
        const window = 30;
        if (lows.length < window) return null;

        const recentLows = lows.slice(-window);
        const mid = Math.floor(window / 2);

        // Check for U-shape: declining then rising
        const leftSide = recentLows.slice(0, mid);
        const rightSide = recentLows.slice(mid);

        const leftTrend = this.calculateTrendline(leftSide);
        const rightTrend = this.calculateTrendline(rightSide);

        if (leftTrend.slope < -0.1 && rightTrend.slope > 0.1) {
          const bottom = Math.min(...recentLows);
          const depth = (closes[closes.length - window] - bottom) / bottom;

          return {
            type: 'ROUNDING_BOTTOM',
            pattern: this.patterns.ROUNDING_BOTTOM,
            confidence: 0.73,
            depth: depth,
            implications: 'Gradual bullish reversal',
            targetPrice: closes[closes.length - 1] + (closes[closes.length - 1] - bottom)
          };
        }
        return null;
      }

      detectInverseHeadAndShoulders(highs, lows, closes) {
        const window = 30;
        if (lows.length < window) return null;

        const recentLows = lows.slice(-window);
        const pivotPoints = this.findPivotPoints(recentLows.map(l => -l), 5); // Invert to find lows

        if (pivotPoints.length >= 5) {
          const [leftShoulder, head, rightShoulder] = this.extractHSPattern(pivotPoints);

          if (this.validateHSStructure(leftShoulder, head, rightShoulder)) {
            const neckline = Math.max(...closes.slice(-window, -window + 10));

            return {
              type: 'INVERSE_HEAD_SHOULDERS',
              pattern: this.patterns.INVERSE_HEAD_SHOULDERS,
              confidence: this.calculateHSConfidence(leftShoulder, head, rightShoulder),
              neckline: neckline,
              implications: 'Strong bullish reversal',
              targetPrice: neckline + (neckline - Math.min(...recentLows))
            };
          }
        }
        return null;
      }

      detectFlag(highs, lows, closes) {
        const window = 15;
        if (highs.length < window) return null;

        // Check for strong prior move
        const priorWindow = 10;
        const priorMove = closes.slice(-window - priorWindow, -window);
        const moveStrength = Math.abs(priorMove[priorMove.length - 1] - priorMove[0]) / priorMove[0];

        if (moveStrength > 0.08) { // At least 8% prior move
          const recentCloses = closes.slice(-window);
          const trendline = this.calculateTrendline(recentCloses);

          // Flag should move counter to prior trend with slight slope
          const priorTrend = priorMove[priorMove.length - 1] > priorMove[0] ? 'up' : 'down';
          const flagSlope = trendline.slope;

          if ((priorTrend === 'up' && flagSlope < 0 && flagSlope > -0.5) ||
            (priorTrend === 'down' && flagSlope > 0 && flagSlope < 0.5)) {
            return {
              type: 'FLAG',
              pattern: this.patterns.FLAG,
              confidence: 0.70,
              implications: `${priorTrend === 'up' ? 'Bullish' : 'Bearish'} continuation`,
              targetPrice: priorTrend === 'up'
                ? closes[closes.length - 1] + (priorMove[priorMove.length - 1] - priorMove[0])
                : closes[closes.length - 1] - (priorMove[0] - priorMove[priorMove.length - 1])
            };
          }
        }
        return null;
      }

      // Trendline calculation helper
      calculateTrendline(data) {
        const n = data.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

        for (let i = 0; i < n; i++) {
          sumX += i;
          sumY += data[i];
          sumXY += i * data[i];
          sumXX += i * i;
        }

        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;

        return { slope, intercept };
      }

      findApex(highTrend, lowTrend) {
        // Find where trendlines intersect
        const x = (lowTrend.intercept - highTrend.intercept) / (highTrend.slope - lowTrend.slope);
        return { x, y: highTrend.slope * x + highTrend.intercept };
      }

      extractHSPattern(pivots) {
        if (pivots.length < 3) return [null, null, null];
        const sorted = [...pivots].sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
        return [
          { height: Math.abs(sorted[1].value), index: sorted[1].index },
          { height: Math.abs(sorted[0].value), index: sorted[0].index },
          { height: Math.abs(sorted[2].value), index: sorted[2].index }
        ];
      }

      validateHSStructure(left, head, right) {
        if (!left || !head || !right) return false;
        // Head should be higher and shoulders similar
        return head.height > left.height &&
          head.height > right.height &&
          Math.abs(left.height - right.height) / left.height < 0.2;
      }

      calculateNeckline(lows, pivots) {
        return Math.min(...lows.slice(pivots[0].index, pivots[pivots.length - 1].index));
      }
    }

    // Initialize global instance
    const patternEngine = new PatternRecognitionEngine();
    window.patternEngine = patternEngine;
    console.log('âœ… Pattern Recognition Engine initialized');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AI PATTERN ANALYSIS FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function generatePatternAnalysis(pattern, stock, historicalData) {
      console.log(`ğŸ¤– Generating AI analysis for ${pattern.pattern.name} on ${stock.symbol}`);

      try {
        // Calculate additional technical indicators
        const recentCloses = historicalData.slice(-20).map(d => d.close || d);
        const currentPrice = stock.price;
        const priceChange = ((currentPrice - recentCloses[0]) / recentCloses[0]) * 100;
        const volatility = calculateVolatility(recentCloses);
        const momentum = calculateMomentum(recentCloses);

        // Determine trading signal based on pattern type and market conditions
        let signal = 'HOLD';
        let entryPoint = currentPrice;
        let stopLoss = currentPrice * 0.95;
        let riskLevel = 'Medium';

        if (pattern.pattern.type === 'reversal') {
          if (pattern.implications.includes('Bullish')) {
            signal = priceChange < -5 ? 'BUY' : 'HOLD';
            entryPoint = currentPrice * 0.98;
            stopLoss = currentPrice * 0.92;
            riskLevel = volatility > 3 ? 'High' : 'Medium';
          } else if (pattern.implications.includes('Bearish')) {
            signal = priceChange > 5 ? 'SELL' : 'HOLD';
            stopLoss = currentPrice * 1.08;
            riskLevel = volatility > 3 ? 'High' : 'Medium';
          }
        } else if (pattern.pattern.type === 'continuation') {
          if (pattern.implications.includes('Bullish') && priceChange > 0) {
            signal = 'BUY';
            entryPoint = currentPrice * 1.01;
            stopLoss = currentPrice * 0.95;
            riskLevel = momentum > 2 ? 'Low' : 'Medium';
          } else if (pattern.implications.includes('Bearish') && priceChange < 0) {
            signal = 'SELL';
            stopLoss = currentPrice * 1.05;
            riskLevel = momentum < -2 ? 'Low' : 'Medium';
          }
        }

        // Generate strategy
        const strategy = generateTradingStrategy(pattern, signal, stock, currentPrice, volatility);

        // Generate key factors
        const keyFactors = generateKeyFactors(pattern, stock, volatility, momentum, priceChange);

        // Generate risk note
        const riskNote = generateRiskNote(pattern, riskLevel, volatility);

        // Generate AI summary
        const summary = generateAISummary(pattern, signal, stock, riskLevel, volatility);

        return {
          signal,
          strategy,
          entryPoint,
          stopLoss,
          riskLevel,
          riskNote,
          keyFactors,
          summary,
          timestamp: Date.now()
        };
      } catch (error) {
        console.error('AI analysis generation failed:', error);
        return generateFallbackAnalysis(pattern);
      }
    }

    function generateFallbackAnalysis(pattern) {
      const currentPrice = 100; // Fallback

      return {
        signal: pattern.implications.includes('Bullish') ? 'BUY' :
          pattern.implications.includes('Bearish') ? 'SELL' : 'HOLD',
        strategy: `Monitor this ${pattern.pattern.name} pattern closely. ${pattern.pattern.description}`,
        entryPoint: pattern.targetPrice || currentPrice,
        stopLoss: pattern.targetPrice ? pattern.targetPrice * 0.95 : currentPrice * 0.95,
        riskLevel: 'Medium',
        riskNote: `This ${pattern.pattern.type} pattern has ${(pattern.pattern.reliability * 100).toFixed(0)}% historical reliability.`,
        keyFactors: [
          `${pattern.pattern.name} detected with ${(pattern.confidence * 100).toFixed(0)}% confidence`,
          `Pattern type: ${pattern.pattern.type}`,
          `Historical reliability: ${(pattern.pattern.reliability * 100).toFixed(0)}%`
        ],
        summary: `A ${pattern.pattern.name} pattern has been identified. ${pattern.implications}.`,
        timestamp: Date.now()
      };
    }

    function generateTradingStrategy(pattern, signal, stock, currentPrice, volatility) {
      const patternName = pattern.pattern.name;
      const isHighVolatility = volatility > 3;

      if (signal === 'BUY') {
        if (pattern.pattern.type === 'reversal') {
          return `Wait for confirmation of reversal with a bullish candle close above ${(currentPrice * 1.02).toFixed(2)}. ` +
            `Enter gradually in 2-3 tranches to average entry price. ` +
            `${isHighVolatility ? 'Use wider stops due to high volatility.' : 'Set tight stops below recent lows.'}`;
        } else {
          return `Enter on pullback to support near ${(currentPrice * 0.98).toFixed(2)}. ` +
            `This continuation pattern suggests uptrend will resume. ` +
            `Add to position if breakout confirms with volume.`;
        }
      } else if (signal === 'SELL') {
        if (pattern.pattern.type === 'reversal') {
          return `Consider taking profits or hedging position. ` +
            `Wait for bearish confirmation before shorting. ` +
            `Exit long positions if price breaks below ${(currentPrice * 0.98).toFixed(2)}.`;
        } else {
          return `Downtrend likely to continue. Consider protective puts or exit on rallies. ` +
            `Avoid new long positions until pattern completes or breaks invalidation level.`;
        }
      } else {
        return `${patternName} is forming but needs confirmation. ` +
          `Wait for breakout direction before taking position. ` +
          `Monitor volume and momentum for clues on direction.`;
      }
    }

    function generateKeyFactors(pattern, stock, volatility, momentum, priceChange) {
      const factors = [];

      factors.push(`${pattern.pattern.name} has ${(pattern.pattern.reliability * 100).toFixed(0)}% historical success rate`);
      factors.push(`Current detection confidence: ${(pattern.confidence * 100).toFixed(0)}%`);

      if (pattern.targetPrice) {
        const potentialGain = ((pattern.targetPrice / stock.price - 1) * 100).toFixed(1);
        factors.push(`Technical target suggests ${Math.abs(potentialGain)}% ${potentialGain > 0 ? 'upside' : 'downside'}`);
      }

      if (volatility > 3) {
        factors.push(`High volatility (${volatility.toFixed(1)}%) increases risk but also opportunity`);
      } else if (volatility < 1.5) {
        factors.push(`Low volatility environment - pattern may take longer to play out`);
      }

      if (Math.abs(momentum) > 2) {
        factors.push(`Strong ${momentum > 0 ? 'positive' : 'negative'} momentum supports pattern direction`);
      }

      if (pattern.pattern.type === 'continuation') {
        factors.push(`Continuation patterns typically complete within 1-3 weeks`);
      } else {
        factors.push(`Reversal patterns often mark significant trend changes`);
      }

      return factors;
    }

    function generateRiskNote(pattern, riskLevel, volatility) {
      if (riskLevel === 'High') {
        return `High risk due to ${volatility > 3 ? 'elevated volatility' : 'uncertain market conditions'}. ` +
          `Use position sizing of 1-2% of portfolio maximum.`;
      } else if (riskLevel === 'Medium') {
        return `Moderate risk pattern. Recommended position size: 3-5% of portfolio. ` +
          `Use stop losses and avoid over-leveraging.`;
      } else {
        return `Relatively low-risk setup with favorable risk/reward ratio. ` +
          `Standard position sizing of 5-8% appropriate for conservative traders.`;
      }
    }

    function generateAISummary(pattern, signal, stock, riskLevel, volatility) {
      const patternName = pattern.pattern.name;
      const confidence = (pattern.confidence * 100).toFixed(0);
      const reliability = (pattern.pattern.reliability * 100).toFixed(0);

      let summary = `AI has detected a ${patternName} pattern on ${stock.symbol} with ${confidence}% confidence. `;

      summary += `This ${pattern.pattern.type} pattern has a ${reliability}% historical success rate. `;

      if (signal === 'BUY') {
        summary += `The analysis suggests a bullish opportunity with ${riskLevel.toLowerCase()} risk. `;
        summary += volatility > 3
          ? `High volatility presents both opportunity and risk - position accordingly.`
          : `Market conditions are favorable for this setup.`;
      } else if (signal === 'SELL') {
        summary += `The analysis indicates bearish pressure with ${riskLevel.toLowerCase()} risk. `;
        summary += `Consider defensive positions or wait for better entry points.`;
      } else {
        summary += `The pattern requires further confirmation before taking action. `;
        summary += `Monitor for breakout direction and volume confirmation.`;
      }

      return summary;
    }

    function calculateVolatility(prices) {
      if (prices.length < 2) return 0;
      const returns = [];
      for (let i = 1; i < prices.length; i++) {
        returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
      }
      const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
      const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
      return Math.sqrt(variance) * Math.sqrt(252) * 100; // Annualized volatility
    }

    function calculateMomentum(prices) {
      if (prices.length < 10) return 0;
      const recent = prices.slice(-5);
      const previous = prices.slice(-10, -5);
      const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
      const previousAvg = previous.reduce((a, b) => a + b, 0) / previous.length;
      return ((recentAvg - previousAvg) / previousAvg) * 100;
    }

    // Make functions globally available
    window.generatePatternAnalysis = generatePatternAnalysis;
    window.generateFallbackAnalysis = generateFallbackAnalysis;
    console.log('âœ… AI Pattern Analysis functions initialized');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REAL-TIME NEWS & SENTIMENT ANALYSIS ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class SentimentAnalyzer {
      constructor() {
        // Sentiment word dictionaries
        this.positiveWords = new Set([
          'bullish', 'surge', 'rally', 'soar', 'gain', 'profit', 'growth', 'beat', 'exceed', 'strong',
          'upgrade', 'buy', 'outperform', 'success', 'positive', 'innovative', 'breakthrough', 'record',
          'boost', 'jump', 'rise', 'upbeat', 'optimistic', 'confident', 'expansion', 'momentum', 'robust',
          'stellar', 'impressive', 'thriving', 'flourish', 'recover', 'rebound', 'accelerate', 'advance'
        ]);

        this.negativeWords = new Set([
          'bearish', 'plunge', 'crash', 'fall', 'loss', 'decline', 'miss', 'below', 'weak', 'concern',
          'downgrade', 'sell', 'underperform', 'failure', 'negative', 'risk', 'warning', 'layoff',
          'drop', 'tumble', 'slide', 'pessimistic', 'worried', 'fearful', 'contraction', 'slump', 'fragile',
          'disappointing', 'struggle', 'suffer', 'collapse', 'crisis', 'trouble', 'investigation', 'lawsuit'
        ]);
      }

      analyzeSentiment(text) {
        if (!text) return { score: 0, label: 'neutral', confidence: 0 };

        const words = text.toLowerCase().split(/\W+/);
        let positiveCount = 0;
        let negativeCount = 0;

        words.forEach(word => {
          if (this.positiveWords.has(word)) positiveCount++;
          if (this.negativeWords.has(word)) negativeCount++;
        });

        const totalSentimentWords = positiveCount + negativeCount;
        if (totalSentimentWords === 0) {
          return { score: 0, label: 'neutral', confidence: 0 };
        }

        // Score from -100 to +100
        const score = ((positiveCount - negativeCount) / totalSentimentWords) * 100;

        // Confidence based on number of sentiment words found
        const confidence = Math.min(100, (totalSentimentWords / words.length) * 500);

        let label;
        if (score > 20) label = 'bullish';
        else if (score < -20) label = 'bearish';
        else label = 'neutral';

        return {
          score: Math.round(score),
          label,
          confidence: Math.round(confidence),
          positiveWords: positiveCount,
          negativeWords: negativeCount
        };
      }
    }

    class RealtimeNewsManager {
      constructor() {
        this.newsCache = new Map(); // symbol -> news array
        this.sentimentAnalyzer = new SentimentAnalyzer();
        this.subscribers = new Map(); // symbol -> [callbacks]
        this.pollIntervals = new Map(); // symbol -> interval ID
        this.updateFrequency = 30 * 60 * 1000; // 30 minutes (was 5 minutes)
      }

      // Heuristic: boost analyst rating / price-target update headlines.
      // Used to rank the top N articles so the user sees more analyst updates.
      getAnalystUpdateScore(article, symbol) {
        const title = (article?.title || '').toString();
        const description = (article?.description || '').toString();
        const text = `${title} ${description}`.toLowerCase();

        if (!text.trim()) return 0;

        let score = 0;
        const sym = (symbol || '').toLowerCase();
        if (sym && text.includes(sym)) score += 3;

        // Price target / rating language
        if (/(price\s*target|target\s*price|price\s*objective|pt\b|\bpt\s*(raised|cut|increase|decrease)|\btarget\s*(raised|cut)|raises?\s+(its\s+)?price\s*target|lowers?\s+(its\s+)?price\s*target|sets?\s+price\s*target)/i.test(text)) {
          score += 40;
        }
        if (/(upgrade|downgrade|initiates?|initiation|reiterates?|maintains?|resumes?\s+coverage|coverage\s+initiated|raises?|lowers?|cuts?|boosts?)\b/i.test(text)) {
          score += 22;
        }
        if (/(rating|rated|buy|sell|hold|overweight|underweight|outperform|underperform|equal\s*weight|market\s*perform|sector\s*perform|neutral|strong\s*buy|strong\s*sell)\b/i.test(text)) {
          score += 18;
        }
        if (/\banalyst(s)?\b/i.test(text)) score += 12;

        // Often appears in analyst updates
        if (/\b(to|from)\s+\$?\d+(?:\.\d+)?\b/i.test(text)) score += 8;
        if (/\$\d{2,}(?:\.\d+)?\b/.test(text)) score += 4;

        // Major broker names (light signal)
        if (/(goldman|morgan\s*stanley|jp\s*morgan|jpmorgan|barclays|bofa|bank\s*of\s*america|citi|citigroup|deutsche\s*bank|ubs|wells\s*fargo|jefferies|raymond\s*james|piper\s*sandler|baird|susquehanna|wedbush|needham|oppenheimer|bernstein)\b/i.test(text)) {
          score += 6;
        }

        return score;
      }

      async fetchNews(symbol, limit = 10) {
        try {
          console.log(`ğŸ“° Fetching news for ${symbol}...`);

          // Use multiple news sources for comprehensive coverage
          const isBrowser = typeof window !== 'undefined';

          const newsPromises = [
            // FMP Stock News - Primary source (paid API, stock-specific news)
            fetch(`https://financialmodelingprep.com/stable/news/stock?symbols=${symbol}&limit=30&apikey=${API_KEYS.FMP}`)
              .then(r => r.ok ? r.json() : [])
              .catch(() => []),

            // Marketaux - Secondary news source with sentiment
            fetch(`https://api.marketaux.com/v1/news/all?symbols=${symbol}&filter_entities=true&language=en&limit=20&api_token=${API_KEYS.MARKETAUX}`)
              .then(r => r.ok ? r.json() : { data: [] })
              .catch(() => ({ data: [] }))
          ];

          const [fmpStockNews, marketauxResponse] = await Promise.all(newsPromises);

          const marketauxNews = marketauxResponse?.data || [];

          console.log(`ğŸ“Š News sources: FMP Stock News=${fmpStockNews?.length || 0}, Marketaux=${marketauxNews.length}`);

          // Combine and normalize news from all sources
          let allNews = [];

          // Process FMP Stock News (primary source - paid, stock-specific)
          (fmpStockNews || []).forEach(item => {
            allNews.push({
              title: item.title,
              description: item.text || item.content || '',
              url: item.url,
              source: item.site || item.source || 'FMP',
              publishedAt: item.publishedDate || item.date,
              image: item.image,
              symbol: symbol
            });
          });

          // Process Marketaux news (secondary source with built-in sentiment)
          marketauxNews.forEach(item => {
            allNews.push({
              title: item.title,
              description: item.description || item.snippet || '',
              url: item.url,
              source: item.source || 'Marketaux',
              publishedAt: item.published_at,
              image: item.image_url,
              symbol: symbol,
              entities: item.entities || []
            });
          });

          // Remove duplicates by URL
          const uniqueNews = allNews.filter((news, index, self) =>
            index === self.findIndex(n => n.url === news.url)
          );

          // Keep only articles from the last 3 months
          const cutoff = Date.now() - (90 * 24 * 60 * 60 * 1000);
          const recentNews = uniqueNews.filter(n => {
            const t = new Date(n.publishedAt).getTime();
            return Number.isFinite(t) && t >= cutoff;
          });

          // Sort by analyst-update relevance first, then recency
          recentNews.sort((a, b) => {
            const scoreB = this.getAnalystUpdateScore(b, symbol);
            const scoreA = this.getAnalystUpdateScore(a, symbol);
            if (scoreB !== scoreA) return scoreB - scoreA;
            return new Date(b.publishedAt) - new Date(a.publishedAt);
          });

          // Analyze sentiment for each article
          const newsWithSentiment = recentNews.slice(0, limit).map(article => {
            const sentiment = this.sentimentAnalyzer.analyzeSentiment(
              article.title + ' ' + article.description
            );

            return {
              ...article,
              sentiment,
              analystScore: this.getAnalystUpdateScore(article, symbol),
              timestamp: new Date(article.publishedAt).getTime()
            };
          });

          console.log(`âœ… Fetched ${newsWithSentiment.length} news articles for ${symbol}`);

          // Update cache
          this.newsCache.set(symbol, newsWithSentiment);

          // Notify subscribers
          this.notifySubscribers(symbol, newsWithSentiment);

          return newsWithSentiment;

        } catch (error) {
          console.error(`âŒ Error fetching news for ${symbol}:`, error);
          return [];
        }
      }

      getDateDaysAgo(days) {
        const date = new Date();
        date.setDate(date.getDate() - days);
        return date.toISOString().split('T')[0];
      }

      getToday() {
        return new Date().toISOString().split('T')[0];
      }

      subscribe(symbol, callback) {
        if (!this.subscribers.has(symbol)) {
          this.subscribers.set(symbol, []);

          // Start polling for this symbol
          this.startPolling(symbol);
        }

        this.subscribers.get(symbol).push(callback);

        // Send cached news immediately if available
        const cached = this.newsCache.get(symbol);
        if (cached) {
          callback(cached);
        } else {
          // Fetch initial news
          this.fetchNews(symbol);
        }

        console.log(`ğŸ“° Subscribed to news for ${symbol}`);
      }

      unsubscribe(symbol, callback) {
        const callbacks = this.subscribers.get(symbol);
        if (!callbacks) return;

        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }

        // Stop polling if no more subscribers
        if (callbacks.length === 0) {
          this.stopPolling(symbol);
          this.subscribers.delete(symbol);
        }

        console.log(`ğŸ“° Unsubscribed from news for ${symbol}`);
      }

      startPolling(symbol) {
        if (this.pollIntervals.has(symbol)) return;

        const intervalId = setInterval(() => {
          this.fetchNews(symbol);
        }, this.updateFrequency);

        this.pollIntervals.set(symbol, intervalId);
        console.log(`ğŸ“° Started news polling for ${symbol} (every ${this.updateFrequency / 1000 / 60} min)`);
      }

      stopPolling(symbol) {
        const intervalId = this.pollIntervals.get(symbol);
        if (intervalId) {
          clearInterval(intervalId);
          this.pollIntervals.delete(symbol);
          console.log(`ğŸ“° Stopped news polling for ${symbol}`);
        }
      }

      notifySubscribers(symbol, news) {
        const callbacks = this.subscribers.get(symbol);
        if (callbacks) {
          callbacks.forEach(cb => {
            try {
              cb(news);
            } catch (err) {
              console.error(`Error in news callback for ${symbol}:`, err);
            }
          });
        }
      }

      getAggregateSentiment(symbol) {
        const news = this.newsCache.get(symbol);
        if (!news || news.length === 0) {
          return { score: 0, label: 'neutral', count: 0 };
        }

        const totalScore = news.reduce((sum, article) => sum + article.sentiment.score, 0);
        const avgScore = totalScore / news.length;

        let label;
        if (avgScore > 20) label = 'bullish';
        else if (avgScore < -20) label = 'bearish';
        else label = 'neutral';

        return {
          score: Math.round(avgScore),
          label,
          count: news.length,
          bullishCount: news.filter(n => n.sentiment.label === 'bullish').length,
          bearishCount: news.filter(n => n.sentiment.label === 'bearish').length,
          neutralCount: news.filter(n => n.sentiment.label === 'neutral').length
        };
      }

      stopAll() {
        this.pollIntervals.forEach(id => clearInterval(id));
        this.pollIntervals.clear();
        this.subscribers.clear();
        console.log('ğŸ“° Stopped all news polling');
      }
    }

    // Initialize news manager
    const newsManager = new RealtimeNewsManager();
    window.newsManager = newsManager;
    console.log('âœ… News Manager initialized');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PORTFOLIO TRACKER & P&L CALCULATOR
    // Cost: FREE - Stores locally in browser
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class PortfolioManager {
      constructor() {
        this.holdings = this.loadPortfolio();
        this.priceCache = new Map(); // symbol -> current price
      }

      loadPortfolio() {
        try {
          const saved = localStorage.getItem('retailedge_portfolio');
          return saved ? JSON.parse(saved) : [];
        } catch (error) {
          console.error('âŒ Error loading portfolio:', error);
          return [];
        }
      }

      savePortfolio() {
        try {
          localStorage.setItem('retailedge_portfolio', JSON.stringify(this.holdings));
          console.log('ğŸ’¾ Portfolio saved');
        } catch (error) {
          console.error('âŒ Error saving portfolio:', error);
        }
      }

      addHolding(symbol, quantity, buyPrice, buyDate = new Date().toISOString()) {
        const holding = {
          id: Date.now() + Math.random(),
          symbol: symbol.toUpperCase(),
          quantity: parseFloat(quantity),
          buyPrice: parseFloat(buyPrice),
          buyDate: buyDate,
          addedAt: new Date().toISOString()
        };

        this.holdings.push(holding);
        this.savePortfolio();
        console.log(`âœ… Added ${quantity} shares of ${symbol} @ $${buyPrice}`);
        return holding;
      }

      updateHolding(id, updates) {
        const index = this.holdings.findIndex(h => h.id === id);
        if (index !== -1) {
          this.holdings[index] = { ...this.holdings[index], ...updates };
          this.savePortfolio();
          console.log(`âœ… Updated holding ${id}`);
          return this.holdings[index];
        }
        return null;
      }

      removeHolding(id) {
        const index = this.holdings.findIndex(h => h.id === id);
        if (index !== -1) {
          const removed = this.holdings.splice(index, 1)[0];
          this.savePortfolio();
          console.log(`âœ… Removed ${removed.symbol} from portfolio`);
          return removed;
        }
        return null;
      }

      async updatePrices(stocksData) {
        // Update current prices from stock data
        stocksData.forEach(stock => {
          this.priceCache.set(stock.symbol, stock.price);
        });
      }

      calculatePortfolioMetrics(stocksData) {
        if (this.holdings.length === 0) {
          return {
            totalValue: 0,
            totalCost: 0,
            totalGainLoss: 0,
            totalGainLossPercent: 0,
            holdings: []
          };
        }

        // Update prices
        this.updatePrices(stocksData);

        let totalValue = 0;
        let totalCost = 0;

        const holdingsWithMetrics = this.holdings.map(holding => {
          const currentPrice = this.priceCache.get(holding.symbol) || holding.buyPrice;
          const stockData = stocksData.find(s => s.symbol === holding.symbol);

          const costBasis = holding.quantity * holding.buyPrice;
          const currentValue = holding.quantity * currentPrice;
          const gainLoss = currentValue - costBasis;
          const gainLossPercent = ((currentPrice - holding.buyPrice) / holding.buyPrice) * 100;

          totalValue += currentValue;
          totalCost += costBasis;

          return {
            ...holding,
            currentPrice,
            costBasis,
            currentValue,
            gainLoss,
            gainLossPercent,
            dayChange: stockData?.changePct || 0,
            dayChangeValue: stockData ? (currentPrice * (stockData.changePct / 100) * holding.quantity) : 0
          };
        });

        const totalGainLoss = totalValue - totalCost;
        const totalGainLossPercent = totalCost > 0 ? (totalGainLoss / totalCost) * 100 : 0;

        return {
          totalValue,
          totalCost,
          totalGainLoss,
          totalGainLossPercent,
          holdings: holdingsWithMetrics,
          holdingsCount: this.holdings.length
        };
      }

      getTopPerformers(metrics, limit = 3) {
        return [...metrics.holdings]
          .sort((a, b) => b.gainLossPercent - a.gainLossPercent)
          .slice(0, limit);
      }

      getWorstPerformers(metrics, limit = 3) {
        return [...metrics.holdings]
          .sort((a, b) => a.gainLossPercent - b.gainLossPercent)
          .slice(0, limit);
      }

      exportToCSV() {
        if (this.holdings.length === 0) return null;

        const headers = ['Symbol', 'Quantity', 'Buy Price', 'Buy Date', 'Current Price', 'Current Value', 'Gain/Loss', 'Gain/Loss %'];
        const metrics = this.calculatePortfolioMetrics([]);

        const rows = metrics.holdings.map(h => [
          h.symbol,
          h.quantity,
          h.buyPrice.toFixed(2),
          new Date(h.buyDate).toLocaleDateString(),
          h.currentPrice.toFixed(2),
          h.currentValue.toFixed(2),
          h.gainLoss.toFixed(2),
          h.gainLossPercent.toFixed(2) + '%'
        ]);

        return [headers, ...rows].map(row => row.join(',')).join('\n');
      }
    }

    // Initialize portfolio manager
    const portfolioManager = new PortfolioManager();
    window.portfolioManager = portfolioManager;
    console.log('âœ… Portfolio Manager initialized');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLAUDE AI STOCK PREDICTION ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class ClaudeStockAnalyzer {
      constructor() {
        this.analysisCache = new Map();
        this.cacheExpiry = 60 * 60 * 1000; // 1 hour
      }

      async analyzeStock(stockData) {
        const cacheKey = `${stockData.symbol}_${Math.floor(Date.now() / this.cacheExpiry)}`;

        if (this.analysisCache.has(cacheKey)) {
          console.log(`âœ… Using cached AI analysis for ${stockData.symbol}`);
          return this.analysisCache.get(cacheKey);
        }

        console.log(`ğŸ¤– Requesting AI analysis for ${stockData.symbol}...`);

        try {
          const analysis = await this.callClaudeAPI(stockData);
          this.analysisCache.set(cacheKey, analysis);
          console.log(`âœ… AI analysis complete for ${stockData.symbol}`);
          return analysis;
        } catch (error) {
          console.error('âŒ AI Analysis failed:', error.message || error);
          console.log('ğŸ”„ Falling back to rule-based analysis...');
          const fallback = this.getFallbackAnalysis(stockData);
          // Cache fallback too (but shorter time)
          this.analysisCache.set(cacheKey, fallback);
          return fallback;
        }
      }

      async callClaudeAPI(stockData) {
        const prompt = this.buildAnalysisPrompt(stockData);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âš ï¸ IMPORTANT: REPLACE THE API KEY BELOW WITH YOUR OWN KEY
        // Get your key from: https://console.anthropic.com/settings/keys
        // The key below may be invalid or rate-limited
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console.log('ğŸ“¡ Making API request to Claude via backend...');

        // Call local backend server that securely handles Claude API
        const response = await fetchWithRetry(`${API_BASE_URL}/api/claude`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          timeoutMs: 20000,
          retries: 1,
          body: JSON.stringify({
            messages: [{ role: "user", content: prompt }]
          })
        }).catch(err => {
          console.error('âŒ Failed to connect to backend server:', err);
          console.log('ğŸ’¡ Make sure Node.js backend is running on port 3002');
          throw new Error('Backend server not responding. Please ensure the Node.js server is running.');
        });

        console.log(`ğŸ“Š API Response status: ${response.status}`);

        if (!response.ok) {
          const errorText = await response.text().catch(() => 'Unknown error');
          console.error(`âŒ API Error ${response.status}:`, errorText);
          console.error(`âŒ Full error details:`, {
            status: response.status,
            statusText: response.statusText,
            url: response.url,
            errorBody: errorText
          });
          throw new Error(`API Error: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        console.log('âœ… API response received, parsing...');
        const analysisText = data.content[0].text;
        return this.parseClaudeResponse(analysisText, stockData);
      }

      buildAnalysisPrompt(stock) {
        return `You are an expert stock analyst. Analyze this stock and provide predictions in JSON format.

STOCK DATA:
Symbol: ${stock.symbol}
Company: ${stock.companyName || stock.symbol}
Current Price: $${stock.price}
Change: ${stock.changesPercentage || 0}%

FUNDAMENTALS:
- P/E Ratio: ${stock.pe || 'N/A'}
- EPS: $${stock.eps || 'N/A'}
- Market Cap: ${this.formatNumber(stock.marketCap)}
- ROE: ${stock.roe || 'N/A'}%

TECHNICAL (if available):
- RSI: ${stock.rsi || 'N/A'}
- SMA 50: ${stock.sma50 || 'N/A'}
- SMA 200: ${stock.sma200 || 'N/A'}

ANALYST:
- Rating: ${stock.rating || 'N/A'}
- Price Target: ${stock.priceTarget || 'N/A'}

Provide analysis in this EXACT JSON format (no markdown):
{
  "predictions": {
    "oneDay": {"price": <number>, "change": <percentage>, "confidence": <0-100>},
    "sevenDay": {"price": <number>, "change": <percentage>, "confidence": <0-100>},
    "thirtyDay": {"price": <number>, "change": <percentage>, "confidence": <0-100>}
  },
  "recommendation": "<BUY|HOLD|SELL>",
  "recommendationStrength": <1-10>,
  "targetPrice": <number>,
  "stopLoss": <number>,
  "keyInsights": ["<insight 1>", "<insight 2>", "<insight 3>"],
  "risks": ["<risk 1>", "<risk 2>"],
  "opportunities": ["<opportunity 1>", "<opportunity 2>"],
  "technicalScore": <0-100>,
  "fundamentalScore": <0-100>,
  "sentimentScore": <0-100>,
  "summary": "<2-3 sentence summary>"
}

Be realistic and conservative. Base confidence on data quality.`;
      }

      parseClaudeResponse(text, stockData) {
        try {
          const jsonText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
          const analysis = JSON.parse(jsonText);
          analysis.symbol = stockData.symbol;
          analysis.currentPrice = stockData.price;
          analysis.timestamp = Date.now();
          analysis.aiModel = 'claude-sonnet-4';
          return analysis;
        } catch (error) {
          console.error('âŒ Parse error:', error);
          return this.getFallbackAnalysis(stockData);
        }
      }

      getFallbackAnalysis(stock) {
        const price = stock.price || 0;
        const pe = stock.pe || 0;
        const rsi = stock.rsi || 50;

        let recommendation = 'HOLD';
        let strength = 5;

        if (pe > 0 && pe < 15 && rsi < 30) {
          recommendation = 'BUY';
          strength = 8;
        } else if (pe > 30 && rsi > 70) {
          recommendation = 'SELL';
          strength = 7;
        }

        return {
          predictions: {
            oneDay: { price: price * 1.001, change: 0.1, confidence: 30 },
            sevenDay: { price: price * 1.005, change: 0.5, confidence: 25 },
            thirtyDay: { price: price * 1.02, change: 2.0, confidence: 20 }
          },
          recommendation,
          recommendationStrength: strength,
          targetPrice: price * 1.10,
          stopLoss: price * 0.95,
          keyInsights: ["AI analysis temporarily unavailable", "Using basic technical analysis"],
          risks: ["Limited analysis due to AI unavailability"],
          opportunities: ["Manual analysis recommended"],
          technicalScore: 50,
          fundamentalScore: 50,
          sentimentScore: 50,
          summary: "AI analysis unavailable. Basic metrics suggest neutral stance. Manual review recommended.",
          symbol: stock.symbol,
          currentPrice: price,
          timestamp: Date.now(),
          aiModel: 'fallback'
        };
      }

      formatNumber(num) {
        if (!num) return 'N/A';
        if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
        if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
        if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
        return num.toLocaleString();
      }
    }

    const aiAnalyzer = new ClaudeStockAnalyzer();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ERROR BOUNDARY COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('ErrorBoundary caught error:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="min-h-screen flex items-center justify-center p-6">
              <div className="glass-elevated rounded-2xl p-8 max-w-md text-center">
                <div className="text-4xl mb-4 text-red-400">âš ï¸</div>
                <h3 className="text-xl font-bold text-white mb-3">Something went wrong</h3>
                <p className="text-slate-400 mb-6">We encountered an error while loading this component.</p>
                <button
                  onClick={() => window.location.reload()}
                  className="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-lg font-semibold"
                >
                  Reload Application
                </button>
              </div>
            </div>
          );
        }

        return this.props.children;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AI SCORING ENGINE (DETERMINISTIC)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const num = (v, d = 0) => {
      const x = typeof v === "number" ? v : parseFloat(v);
      return Number.isFinite(x) ? x : d;
    };

    // Compute unified AI score (0-100) from stock fundamentals + technicals
    function computeAIScore(stock) {
      // Extract metrics safely with defaults
      const pe = num(stock.pe, 0);
      const roe = num(stock.roe, 0);
      const rsi = num(stock.rsi, 50);
      const changePct = num(stock.changePct, 0);
      const marketCap = num(stock.marketCap, 0);

      // --- FUNDAMENTALS SUBSCORE (0-100) ---
      let fundamental = 50; // Start neutral

      // P/E: Lower is better (value), but 0 is invalid
      if (pe > 0) {
        if (pe < 15) fundamental += 20;
        else if (pe < 20) fundamental += 12;
        else if (pe < 25) fundamental += 5;
        else if (pe > 40) fundamental -= 15;
        else if (pe > 30) fundamental -= 8;
      }

      // ROE: Higher is better (quality)
      if (roe > 25) fundamental += 20;
      else if (roe > 20) fundamental += 15;
      else if (roe > 15) fundamental += 10;
      else if (roe > 10) fundamental += 5;
      else if (roe < 5) fundamental -= 10;

      // Market Cap: Prefer established companies for stability
      if (marketCap > 10e9) fundamental += 8; // Large cap bonus
      else if (marketCap < 1e9) fundamental -= 5; // Small cap penalty

      fundamental = clamp(fundamental, 0, 100);

      // --- TECHNICALS SUBSCORE (0-100) ---
      let technical = 50; // Start neutral

      // RSI: Sweet spot is 35-65, avoid extremes
      if (rsi >= 35 && rsi <= 65) technical += 15; // Healthy range
      else if (rsi < 30) technical += 10; // Oversold opportunity
      else if (rsi > 70) technical -= 12; // Overbought risk

      // Momentum: Recent price change
      if (changePct > 5) technical += 12; // Strong uptrend
      else if (changePct > 2) technical += 6; // Positive momentum
      else if (changePct < -5) technical -= 10; // Downtrend
      else if (changePct < -2) technical -= 5; // Weak

      technical = clamp(technical, 0, 100);

      // --- RISK SUBSCORE (0-100, higher = more risk) ---
      let risk = 50; // Start neutral

      // High P/E = valuation risk
      if (pe > 40) risk += 15;
      else if (pe > 30) risk += 8;

      // Extreme RSI = volatility risk
      if (rsi > 75 || rsi < 25) risk += 10;

      // Recent sharp decline = momentum risk
      if (changePct < -10) risk += 12;

      risk = clamp(risk, 0, 100);

      // --- COMBINE INTO FINAL SCORE (0-100) ---
      // Weights: Fundamentals 55%, Technicals 35%, Risk penalty 10%
      const rawScore = (0.55 * fundamental) + (0.35 * technical) + (0.10 * (100 - risk));
      const score = clamp(Math.round(rawScore), 0, 100);

      return {
        score,
        subscores: { fundamental, technical, risk }
      };
    }

    // Determine verdict from score
    function verdictFromScore(score) {
      if (score >= 80) return { verdict: "STRONG BUY", stance: "bullish" };
      if (score >= 67) return { verdict: "BUY", stance: "bullish" };
      if (score >= 55) return { verdict: "HOLD", stance: "neutral" };
      if (score >= 45) return { verdict: "REDUCE", stance: "bearish" };
      return { verdict: "SELL", stance: "bearish" };
    }

    // Calculate confidence from score (deterministic)
    function confidenceFromScore(score, subscores) {
      // Base confidence increases with distance from 50 (neutral)
      const base = 40 + Math.abs(score - 50) * 1.1; // Range: 40-95

      // Penalty for high risk
      const riskPenalty = (subscores?.risk ?? 50) * 0.15; // 0-15 penalty

      const confidence = clamp(Math.round(base - riskPenalty), 35, 92);
      return confidence;
    }

    // Generate complete AI analysis with factors
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AI ANALYSIS CACHE - Avoid recalculating for same stock data
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const aiAnalysisCache = new Map();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEBOUNCED LOCALSTORAGE - Batch writes to prevent blocking
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const debouncedLocalStorage = {
      timers: {},
      pendingWrites: {},

      setItem(key, value, delay = 1000) {
        // Store the value to write
        this.pendingWrites[key] = value;

        // Clear existing timer
        if (this.timers[key]) {
          clearTimeout(this.timers[key]);
        }

        // Set new timer
        this.timers[key] = setTimeout(() => {
          try {
            localStorage.setItem(key, this.pendingWrites[key]);
            delete this.pendingWrites[key];
            delete this.timers[key];
          } catch (e) {
            console.warn('localStorage write failed:', e);
          }
        }, delay);
      },

      setItemImmediate(key, value) {
        // Immediate write (for critical data)
        if (this.timers[key]) {
          clearTimeout(this.timers[key]);
          delete this.timers[key];
        }
        try {
          localStorage.setItem(key, value);
          delete this.pendingWrites[key];
        } catch (e) {
          console.warn('localStorage write failed:', e);
        }
      },

      flush() {
        // Write all pending immediately
        Object.keys(this.pendingWrites).forEach(key => {
          try {
            localStorage.setItem(key, this.pendingWrites[key]);
          } catch (e) {
            console.warn('localStorage flush failed:', e);
          }
        });
        Object.keys(this.timers).forEach(key => clearTimeout(this.timers[key]));
        this.timers = {};
        this.pendingWrites = {};
      }
    };

    // Flush on page unload
    window.addEventListener('beforeunload', () => debouncedLocalStorage.flush());

    function generateAIAnalysis(stock) {
      // Check cache first (use symbol + price + changePct as key)
      const cacheKey = `${stock.symbol}_${stock.price}_${stock.changePct}_${stock.pe}_${stock.roe}`;
      if (aiAnalysisCache.has(cacheKey)) {
        return aiAnalysisCache.get(cacheKey);
      }

      const { score, subscores } = computeAIScore(stock);
      const { verdict, stance } = verdictFromScore(score);
      const confidence = confidenceFromScore(score, subscores);

      const bullFactors = [];
      const bearFactors = [];

      // Extract metrics with more data points
      const pe = num(stock.pe, 0);
      const roe = num(stock.roe, 0);
      const rsi = num(stock.rsi, 50);
      const changePct = num(stock.changePct, 0);
      const price = num(stock.price, 0);
      const marketCap = num(stock.marketCap, 0);
      const eps = num(stock.eps, 0);
      const growth = num(stock.revenueGrowth, 0);
      const debt = num(stock.debtToEquity, 0);
      const margin = num(stock.profitMargin, 0);
      const beta = num(stock.beta, 1);
      const volume = num(stock.volume, 0);
      const avgVolume = num(stock.avgVolume, 1);

      // Advanced calculations
      const peg = growth > 0 && pe > 0 ? pe / growth : null; // PEG ratio
      const volumeRatio = avgVolume > 0 ? volume / avgVolume : 1;
      const isMegaCap = marketCap > 200e9; // $200B+
      const isLargeCap = marketCap > 10e9; // $10B+
      const isGrowthStock = growth > 15;
      const isValueStock = pe > 0 && pe < 15;

      // Helper: importance ranking for factor sorting
      const importanceRank = { high: 3, medium: 2, low: 1 };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENHANCED BULLISH FACTORS (More Sophisticated)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Deep Value + Quality Combo (Warren Buffett style)
      if (pe > 0 && pe < 12 && roe > 18 && debt < 0.5 && growth > 8) {
        bullFactors.push({
          factor: "Quality Deep Value",
          detail: `Exceptional combination: Low P/E (${pe.toFixed(1)}), strong ROE (${roe.toFixed(1)}%), low debt (${debt.toFixed(2)}Ã—), and ${growth.toFixed(1)}% growth.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // PEG Ratio Value (Growth at reasonable price)
      else if (peg !== null && peg < 1 && peg > 0.1 && growth > 10) {
        bullFactors.push({
          factor: "Growth at Reasonable Price",
          detail: `PEG ratio of ${peg.toFixed(2)} indicates growth (${growth.toFixed(1)}%) is underpriced relative to P/E (${pe.toFixed(1)}).`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Classic Value Play
      else if (pe > 0 && pe < 15) {
        bullFactors.push({
          factor: "Attractive Valuation",
          detail: `P/E ratio of ${pe.toFixed(1)} suggests undervaluation vs. market average (${isMegaCap ? 'mega-cap' : isLargeCap ? 'large-cap' : 'mid-cap'} stock).`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Profitability + Efficiency
      if (roe > 25 && margin > 15) {
        bullFactors.push({
          factor: "High-Quality Business Model",
          detail: `Exceptional ROE (${roe.toFixed(1)}%) with strong profit margins (${margin.toFixed(1)}%) indicates pricing power and efficiency.`,
          importance: "high",
          category: "fundamental"
        });
      } else if (roe > 20) {
        bullFactors.push({
          factor: "Superior Capital Efficiency",
          detail: `ROE of ${roe.toFixed(1)}% demonstrates exceptional profitability.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Balance Sheet Strength
      if (debt < 0.3 && roe > 15 && marketCap > 1e9) {
        bullFactors.push({
          factor: "Fortress Balance Sheet",
          detail: `Low debt-to-equity (${debt.toFixed(2)}Ã—) with strong ROE (${roe.toFixed(1)}%) provides stability and flexibility.`,
          importance: "medium",
          category: "fundamental"
        });
      }

      // Aggressive Growth
      if (growth > 25 && roe > 10) {
        bullFactors.push({
          factor: "High-Growth Story",
          detail: `Revenue growing ${growth.toFixed(1)}% while maintaining ${roe.toFixed(1)}% ROE shows strong market position.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Technical Strength
      if (rsi > 55 && rsi < 68 && changePct > 2 && changePct < 8) {
        bullFactors.push({
          factor: "Healthy Bullish Momentum",
          detail: `RSI at ${rsi.toFixed(0)} with ${changePct.toFixed(1)}% gain shows controlled uptrend without overextension.`,
          importance: "medium",
          category: "technical"
        });
      } else if (rsi < 35 && changePct > -10) {
        bullFactors.push({
          factor: "Oversold Technical Setup",
          detail: `RSI of ${rsi.toFixed(0)} indicates potential mean reversion opportunity (not in freefall).`,
          importance: "medium",
          category: "technical"
        });
      } else if (changePct > 5) {
        bullFactors.push({
          factor: "Strong Momentum",
          detail: `Recent price gain of ${changePct.toFixed(1)}% shows buying pressure.`,
          importance: "medium",
          category: "technical"
        });
      }

      // Volume Confirmation
      if (volumeRatio > 1.5 && changePct > 3) {
        bullFactors.push({
          factor: "Volume-Confirmed Rally",
          detail: `Volume ${(volumeRatio * 100 - 100).toFixed(0)}% above average confirms institutional interest in the move.`,
          importance: "medium",
          category: "technical"
        });
      }

      // Low Volatility + Growth (Steady compounder)
      if (beta < 0.9 && roe > 15 && growth > 10 && debt < 0.5) {
        bullFactors.push({
          factor: "Defensive Growth Compounder",
          detail: `Low volatility (Î² ${beta.toFixed(2)}) with ${growth.toFixed(1)}% growth and ${roe.toFixed(1)}% ROE â€” rare combination.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENHANCED BEARISH FACTORS (Better Risk Detection)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Value Trap Detection
      if (pe > 0 && pe < 10 && roe < 8 && growth < 0) {
        bearFactors.push({
          factor: "Potential Value Trap",
          detail: `Low P/E (${pe.toFixed(1)}) with poor ROE (${roe.toFixed(1)}%) and negative growth (${growth.toFixed(1)}%) suggests structural problems.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Expensive Growth with Execution Risk
      else if (pe > 50 && peg !== null && peg > 3 && growth < 25) {
        bearFactors.push({
          factor: "Overpriced Relative to Growth",
          detail: `PEG of ${peg.toFixed(1)} indicates P/E (${pe.toFixed(1)}) is too high for ${growth.toFixed(1)}% growth rate.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Classic Overvaluation
      else if (pe > 35) {
        bearFactors.push({
          factor: "Premium Valuation Risk",
          detail: `P/E ratio of ${pe.toFixed(1)} leaves little margin for safety${isGrowthStock ? ', even for growth stock' : ''}.`,
          importance: "high",
          category: "fundamental"
        });
      }

      // Deteriorating Fundamentals
      if (roe < 8 && roe > 0 && growth < 5) {
        bearFactors.push({
          factor: "Weak Business Economics",
          detail: `ROE of ${roe.toFixed(1)}% with ${growth.toFixed(1)}% growth suggests competitive disadvantage or poor management.`,
          importance: "high",
          category: "fundamental"
        });
      } else if (roe < 8 && roe > 0) {
        bearFactors.push({
          factor: "Below-Average Returns",
          detail: `ROE of ${roe.toFixed(1)}% suggests weak capital efficiency.`,
          importance: "medium",
          category: "fundamental"
        });
      }

      // Debt Warning
      if (debt > 2 && roe < 12) {
        bearFactors.push({
          factor: "Elevated Leverage Risk",
          detail: `High debt-to-equity (${debt.toFixed(2)}Ã—) with modest ROE (${roe.toFixed(1)}%) limits financial flexibility.`,
          importance: "high",
          category: "fundamental"
        });
      } else if (debt > 3) {
        bearFactors.push({
          factor: "Balance Sheet Concern",
          detail: `Debt-to-equity of ${debt.toFixed(2)}Ã— is elevated â€” vulnerable to rising rates or earnings miss.`,
          importance: "medium",
          category: "fundamental"
        });
      }

      // Low Margins + High Valuation
      if (margin < 5 && pe > 20) {
        bearFactors.push({
          factor: "Thin Margins at Rich Valuation",
          detail: `Profit margin of ${margin.toFixed(1)}% with P/E ${pe.toFixed(1)} offers little cushion for disappointment.`,
          importance: "medium",
          category: "fundamental"
        });
      }

      // Technical Warnings
      if (rsi > 72 && changePct > 10) {
        bearFactors.push({
          factor: "Severely Overbought",
          detail: `RSI of ${rsi.toFixed(0)} with ${changePct.toFixed(1)}% rally suggests high probability of sharp pullback.`,
          importance: "high",
          category: "technical"
        });
      } else if (rsi > 72) {
        bearFactors.push({
          factor: "Overbought Condition",
          detail: `RSI of ${rsi.toFixed(0)} increases probability of near-term pullback.`,
          importance: "medium",
          category: "technical"
        });
      }

      // Falling Knife
      if (changePct < -15 && volumeRatio > 2) {
        bearFactors.push({
          factor: "Capitulation Selling",
          detail: `Down ${Math.abs(changePct).toFixed(1)}% on heavy volume suggests panic or negative catalyst â€” wait for stabilization.`,
          importance: "high",
          category: "technical"
        });
      } else if (changePct < -5) {
        bearFactors.push({
          factor: "Negative Momentum",
          detail: `Recent decline of ${changePct.toFixed(1)}% signals selling pressure.`,
          importance: "medium",
          category: "technical"
        });
      }

      // High Volatility Risk
      if (beta > 1.8 && marketCap < 10e9) {
        bearFactors.push({
          factor: "Elevated Volatility Risk",
          detail: `Beta of ${beta.toFixed(2)} with smaller market cap (${(marketCap / 1e9).toFixed(1)}B) amplifies downside risk.`,
          importance: "medium",
          category: "risk"
        });
      }

      // Ensure at least one factor each
      if (!bullFactors.length) {
        bullFactors.push({
          factor: "No Major Red Flags",
          detail: "Fundamental and technical signals are generally supportive.",
          importance: "low",
          category: "fundamental"
        });
      }

      if (!bearFactors.length) {
        bearFactors.push({
          factor: "Normal Risk Profile",
          detail: "Risks appear within typical range for this asset.",
          importance: "low",
          category: "fundamental"
        });
      }

      // Executive Summary
      const execSummary = `${stock.symbol} scores ${score}/100 with ${verdict} rating (${confidence}% confidence). Fundamentals: ${Math.round(subscores.fundamental)}/100, Technicals: ${Math.round(subscores.technical)}/100, Risk: ${Math.round(subscores.risk)}/100.`;

      // â”€â”€ Score drivers (teaching layer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const sortedBull = [...bullFactors].sort((a, b) => (importanceRank[b.importance] || 0) - (importanceRank[a.importance] || 0));
      const sortedBear = [...bearFactors].sort((a, b) => (importanceRank[b.importance] || 0) - (importanceRank[a.importance] || 0));
      const topDrivers = {
        positive: sortedBull.slice(0, 2),
        negative: sortedBear.slice(0, 2),
      };

      // â”€â”€ Reassurance / emotional safety cue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let reassurance = "Nothing here suggests unusual urgency â€” use this as a starting point and sanity-check with your own research.";
      if ((subscores?.risk ?? 50) >= 70) reassurance = "Risk signals look elevated â€” size your exposure carefully and double-check the bear cases before acting.";
      else if (confidence <= 45) reassurance = "Signals are mixed (low alignment) â€” it's normal to place this on a watchlist and wait for clarity.";

      // â”€â”€ AI Takeaway (interpretive closure) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const valuationFlag = pe > 35 ? "valuation looks stretched" : (pe > 0 && pe < 15 ? "valuation looks supportive" : "valuation looks mixed");
      const timingFlag = rsi > 72 ? "short-term timing looks stretched" : (rsi < 35 ? "short-term timing may be favorable" : "timing looks neutral");
      const qualityFlag = roe > 20 ? "business quality looks strong" : (roe > 0 && roe < 8 ? "quality looks weaker than average" : "quality looks mixed");

      let takeaway = "";
      if (verdict === "STRONG BUY" || verdict === "BUY") {
        takeaway = `Overall, the balance of signals leans constructive: ${qualityFlag}, ${valuationFlag}, and ${timingFlag}. This looks more suitable for patient investors than for quick trades.`;
      } else if (verdict === "HOLD") {
        takeaway = `Overall, signals are mixed: ${qualityFlag} with ${valuationFlag} and ${timingFlag}. This is a reasonable watchlist candidate while you wait for a better price, clearer trend, or new fundamentals.`;
      } else {
        takeaway = `Overall, the risk/reward looks less attractive right now: ${qualityFlag} with ${valuationFlag} and ${timingFlag}. Consider treating this as "research further" unless your thesis is very strong.`;
      }

      // â”€â”€ Watchlist guidance (what to monitor next) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const watchMetric = (sortedBear[0]?.category === "technical" || rsi > 70 || rsi < 30) ? "trend/RSI and price action" :
        (sortedBear[0]?.category === "fundamental" || pe > 30) ? "earnings + valuation (P/E) and margins" :
          "ROE/margins and revenue growth";
      const lastEarningsDate = stock?.lastEarnings?.date || stock?.lastEarnings?.fiscalDateEnding || null;

      const watchlistGuidance = {
        headline: "What to watch next",
        items: [
          { label: "Next check-in", value: lastEarningsDate ? `Review after the next earnings cycle (last reported: ${lastEarningsDate}).` : "Review after the next earnings cycle." },
          { label: "Key metric", value: watchMetric },
          { label: "Main risk to monitor", value: (sortedBear[0]?.factor ? sortedBear[0].factor : "unexpected earnings / guidance changes") }
        ]
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENHANCED: Detailed Risk Assessment with Reasons
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const riskReasons = [];
      let riskLevel = 'Medium';

      // High volatility
      if (beta > 1.8) {
        riskReasons.push(`High volatility (Î² ${beta.toFixed(2)})`);
        riskLevel = 'High';
      } else if (beta > 1.4) {
        riskReasons.push(`Above-average volatility (Î² ${beta.toFixed(2)})`);
      }

      // Debt concerns
      if (debt > 2) {
        riskReasons.push(`Elevated debt (${debt.toFixed(2)}Ã— equity)`);
        riskLevel = 'High';
      } else if (debt > 1.5) {
        riskReasons.push(`Moderate debt (${debt.toFixed(2)}Ã— equity)`);
      }

      // Valuation risk
      if (pe > 50) {
        riskReasons.push(`Extreme valuation (P/E ${pe.toFixed(1)})`);
        riskLevel = 'High';
      } else if (pe > 35) {
        riskReasons.push(`Premium valuation (P/E ${pe.toFixed(1)})`);
        if (riskLevel === 'Medium') riskLevel = 'Medium-High';
      }

      // Profitability concerns
      if (roe < 5 && roe > 0) {
        riskReasons.push(`Weak profitability (ROE ${roe.toFixed(1)}%)`);
        if (riskLevel === 'Medium') riskLevel = 'Medium-High';
      }

      // Negative growth
      if (growth < -10) {
        riskReasons.push(`Revenue declining ${Math.abs(growth).toFixed(1)}%`);
        riskLevel = 'High';
      }

      // Technical breakdown
      if (changePct < -15) {
        riskReasons.push(`Severe downtrend (-${Math.abs(changePct).toFixed(1)}%)`);
        if (riskLevel === 'Medium') riskLevel = 'Medium-High';
      }

      // Low liquidity (small cap + low volume)
      if (marketCap < 1e9 && volumeRatio < 0.5) {
        riskReasons.push('Low liquidity (small-cap, thin volume)');
        if (riskLevel === 'Medium') riskLevel = 'Medium-High';
      }

      // Default if no risks found
      if (riskReasons.length === 0) {
        riskReasons.push('Standard market risk');
        riskLevel = 'Low-Medium';
      }

      const riskAssessment = {
        level: riskLevel,
        score: subscores.risk,
        reasons: riskReasons,
        summary: riskReasons.length > 2
          ? `${riskLevel} risk: ${riskReasons.slice(0, 2).join(', ')} +${riskReasons.length - 2} more`
          : `${riskLevel} risk: ${riskReasons.join(', ')}`
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENHANCED: Quick Key Factors Summary
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const keyFactors = [];

      // Valuation
      if (pe > 0 && pe < 12) keyFactors.push('ğŸ”µ Deep Value');
      else if (pe > 0 && pe < 18) keyFactors.push('ğŸ’ Value');
      else if (pe > 40) keyFactors.push('âš ï¸ Expensive');

      // Quality
      if (roe > 25) keyFactors.push('â­ Elite ROE');
      else if (roe > 18) keyFactors.push('âœ… Strong ROE');
      else if (roe < 8 && roe > 0) keyFactors.push('âš ï¸ Weak ROE');

      // Growth
      if (growth > 25) keyFactors.push('ğŸš€ High Growth');
      else if (growth > 15) keyFactors.push('ğŸ“ˆ Growing');
      else if (growth < -5) keyFactors.push('ğŸ“‰ Declining');

      // Balance sheet
      if (debt < 0.3 && marketCap > 1e9) keyFactors.push('ğŸ’ª Strong Balance Sheet');
      else if (debt > 2) keyFactors.push('âš ï¸ High Debt');

      // Momentum
      if (changePct > 10) keyFactors.push('ğŸ”¥ Strong Momentum');
      else if (changePct > 5) keyFactors.push('ğŸ“Š Positive Momentum');
      else if (changePct < -10) keyFactors.push('ğŸ”´ Weak Momentum');

      // Technical
      if (rsi < 30) keyFactors.push('ğŸ’¡ Oversold');
      else if (rsi > 75) keyFactors.push('ğŸ”´ Overbought');
      else if (rsi > 55 && rsi < 68) keyFactors.push('âœ… Healthy Trend');

      // Volume
      if (volumeRatio > 2) keyFactors.push('ğŸ“¢ High Volume');

      // Size
      if (isMegaCap) keyFactors.push('ğŸ¢ Mega-Cap');
      else if (marketCap < 2e9) keyFactors.push('ğŸ”¬ Small-Cap');

      // PEG (if calculable)
      if (peg !== null && peg < 1 && peg > 0.1) keyFactors.push('ğŸ’° Growth at Value');

      // Fallback
      if (keyFactors.length === 0) keyFactors.push('ğŸ“Š Market Average');

      const result = {
        verdict,
        confidence,
        stance,
        execSummary,
        bullFactors,
        bearFactors,
        topDrivers,
        reassurance,
        takeaway,
        watchlistGuidance,
        subscores,
        aiScore: score, // Unified 0-100 scale
        health: score, // Health = AI score for consistency
        riskAssessment, // NEW: Detailed risk with reasons
        keyFactors, // NEW: Quick visual summary
      };

      // Cache result (limit cache size to 2000 entries)
      if (aiAnalysisCache.size > 2000) {
        const firstKey = aiAnalysisCache.keys().next().value;
        aiAnalysisCache.delete(firstKey);
      }
      aiAnalysisCache.set(cacheKey, result);

      return result;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXPLAINABLE AI (rule-level contributions + sensitivity)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function explainDeterministicAIScore(stock) {
      const pe = num(stock.pe, 0);
      const roe = num(stock.roe, 0);
      const rsi = num(stock.rsi, 50);
      const changePct = num(stock.changePct, 0);
      const marketCap = num(stock.marketCap, 0);

      const weights = { fundamental: 0.55, technical: 0.35, risk: 0.10 };
      const contributions = [];
      const add = (bucket, label, delta, detail) => {
        if (!delta) return;
        contributions.push({ bucket, label, delta, detail });
      };

      // FUNDAMENTALS
      let fundamental = 50;
      if (pe > 0) {
        if (pe < 15) { fundamental += 20; add('fundamental', 'Attractive P/E', +20, `P/E ${pe.toFixed(1)} < 15`); }
        else if (pe < 20) { fundamental += 12; add('fundamental', 'Reasonable P/E', +12, `P/E ${pe.toFixed(1)} < 20`); }
        else if (pe < 25) { fundamental += 5; add('fundamental', 'Fair P/E', +5, `P/E ${pe.toFixed(1)} < 25`); }
        else if (pe > 40) { fundamental -= 15; add('fundamental', 'Expensive P/E', -15, `P/E ${pe.toFixed(1)} > 40`); }
        else if (pe > 30) { fundamental -= 8; add('fundamental', 'High P/E', -8, `P/E ${pe.toFixed(1)} > 30`); }
      }

      if (roe > 25) { fundamental += 20; add('fundamental', 'Excellent ROE', +20, `ROE ${roe.toFixed(1)}% > 25%`); }
      else if (roe > 20) { fundamental += 15; add('fundamental', 'Strong ROE', +15, `ROE ${roe.toFixed(1)}% > 20%`); }
      else if (roe > 15) { fundamental += 10; add('fundamental', 'Good ROE', +10, `ROE ${roe.toFixed(1)}% > 15%`); }
      else if (roe > 10) { fundamental += 5; add('fundamental', 'Decent ROE', +5, `ROE ${roe.toFixed(1)}% > 10%`); }
      else if (roe < 5) { fundamental -= 10; add('fundamental', 'Weak ROE', -10, `ROE ${roe.toFixed(1)}% < 5%`); }

      if (marketCap > 10e9) { fundamental += 8; add('fundamental', 'Large-cap stability', +8, `Market cap > $10B`); }
      else if (marketCap > 0 && marketCap < 1e9) { fundamental -= 5; add('fundamental', 'Small-cap risk', -5, `Market cap < $1B`); }

      fundamental = clamp(fundamental, 0, 100);

      // TECHNICALS
      let technical = 50;
      if (rsi >= 35 && rsi <= 65) { technical += 15; add('technical', 'Healthy RSI', +15, `RSI ${rsi.toFixed(0)} in 35â€“65`); }
      else if (rsi < 30) { technical += 10; add('technical', 'Oversold setup', +10, `RSI ${rsi.toFixed(0)} < 30`); }
      else if (rsi > 70) { technical -= 12; add('technical', 'Overbought risk', -12, `RSI ${rsi.toFixed(0)} > 70`); }

      if (changePct > 5) { technical += 12; add('technical', 'Strong momentum', +12, `${changePct.toFixed(1)}% daily move > +5%`); }
      else if (changePct > 2) { technical += 6; add('technical', 'Positive momentum', +6, `${changePct.toFixed(1)}% daily move > +2%`); }
      else if (changePct < -5) { technical -= 10; add('technical', 'Downtrend', -10, `${changePct.toFixed(1)}% daily move < -5%`); }
      else if (changePct < -2) { technical -= 5; add('technical', 'Weak tape', -5, `${changePct.toFixed(1)}% daily move < -2%`); }

      technical = clamp(technical, 0, 100);

      // RISK (higher = worse)
      let risk = 50;
      if (pe > 40) { risk += 15; add('risk', 'Valuation risk', +15, `P/E ${pe.toFixed(1)} > 40`); }
      else if (pe > 30) { risk += 8; add('risk', 'Valuation risk', +8, `P/E ${pe.toFixed(1)} > 30`); }

      if (rsi > 75 || rsi < 25) { risk += 10; add('risk', 'Extreme RSI risk', +10, `RSI ${rsi.toFixed(0)} outside 25â€“75`); }
      if (changePct < -10) { risk += 12; add('risk', 'Sharp drawdown risk', +12, `${changePct.toFixed(1)}% daily move < -10%`); }

      risk = clamp(risk, 0, 100);

      const rawScore = (weights.fundamental * fundamental) + (weights.technical * technical) + (weights.risk * (100 - risk));
      const score = clamp(Math.round(rawScore), 0, 100);

      const impacts = contributions.map(c => {
        let impact = 0;
        if (c.bucket === 'fundamental') impact = weights.fundamental * c.delta;
        else if (c.bucket === 'technical') impact = weights.technical * c.delta;
        else if (c.bucket === 'risk') impact = -weights.risk * c.delta;
        return { ...c, impact: Math.round(impact * 10) / 10 };
      }).sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact));

      return {
        score,
        subscores: { fundamental, technical, risk },
        weights,
        impacts,
        topImpacts: impacts.slice(0, 6)
      };
    }

    function aiExplainThresholds(score) {
      const bands = [80, 67, 55, 45, 0];
      const labels = ['STRONG BUY', 'BUY', 'HOLD', 'REDUCE', 'SELL'];
      let idx = labels.length - 1;
      for (let i = 0; i < bands.length; i++) {
        if (score >= bands[i]) { idx = i; break; }
      }
      const current = labels[idx];
      const nextUpScore = idx > 0 ? bands[idx - 1] : null;
      const nextDownScore = idx < labels.length - 1 ? bands[idx + 1] : null;
      return {
        current,
        nextUpScore,
        nextDownScore,
        toNextUp: nextUpScore != null ? Math.max(0, nextUpScore - score) : 0,
        toNextDown: nextDownScore != null ? Math.max(0, score - nextDownScore) : 0,
      };
    }

    function aiSensitivitySuggestions(stock) {
      const base = explainDeterministicAIScore(stock);
      const suggestions = [];

      const addSuggestion = (title, overrides, note) => {
        const alt = explainDeterministicAIScore({ ...stock, ...overrides });
        const delta = alt.score - base.score;
        if (!Number.isFinite(delta) || Math.abs(delta) < 1) return;
        suggestions.push({ title, delta, newScore: alt.score, note });
      };

      const pe = num(stock.pe, 0);
      if (pe > 40) addSuggestion('If valuation cools (P/E < 40)', { pe: 39.9 }, 'Reduces valuation risk penalty and improves the P/E bucket.');
      else if (pe > 30) addSuggestion('If valuation cools (P/E < 30)', { pe: 29.9 }, 'Improves fundamentals and reduces the risk bucket.');
      else if (pe >= 25) addSuggestion('If P/E improves (< 25)', { pe: 24.9 }, 'Moves into a more favorable valuation bucket.');
      else if (pe >= 20) addSuggestion('If P/E improves (< 20)', { pe: 19.9 }, 'Moves into a stronger valuation bucket.');
      else if (pe >= 15) addSuggestion('If P/E improves (< 15)', { pe: 14.9 }, 'Moves into the strongest valuation bucket.');

      const roe = num(stock.roe, 0);
      if (roe < 5) addSuggestion('If ROE reaches 10%', { roe: 10.1 }, 'Crosses the 10% profitability threshold.');
      else if (roe < 10) addSuggestion('If ROE reaches 15%', { roe: 15.1 }, 'Crosses the 15% profitability threshold.');
      else if (roe < 15) addSuggestion('If ROE reaches 20%', { roe: 20.1 }, 'Crosses the 20% profitability threshold.');
      else if (roe < 20) addSuggestion('If ROE reaches 25%', { roe: 25.1 }, 'Crosses the 25% profitability threshold.');

      const rsi = num(stock.rsi, 50);
      if (!(rsi >= 35 && rsi <= 65)) addSuggestion('If RSI returns to 35â€“65', { rsi: 50 }, 'Moves into the â€œhealthy RSIâ€ band used by the model.');
      if (rsi > 75 || rsi < 25) addSuggestion('If RSI normalizes inside 25â€“75', { rsi: clamp(rsi, 25, 75) }, 'Removes the â€œextreme RSIâ€ risk penalty.');

      const changePct = num(stock.changePct, 0);
      if (changePct < -10) addSuggestion('If drawdown eases above -10%', { changePct: -9.9 }, 'Removes the â€œsharp drawdownâ€ risk penalty.');
      if (changePct < 2) addSuggestion('If momentum improves above +2%', { changePct: 2.1 }, 'Moves into the positive momentum bucket.');

      const marketCap = num(stock.marketCap, 0);
      if (marketCap > 0 && marketCap < 1e9) addSuggestion('If market cap re-rates above $1B', { marketCap: 1e9 }, 'Removes the small-cap penalty.');

      return suggestions.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta)).slice(0, 4);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI COMPONENTS - Delay Badge, Footer, Paywall
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function DelayBadge() {
      const [open, setOpen] = useState(false);
      return (
        <div className="relative inline-block">
          <button
            onClick={() => setOpen(p => !p)}
            className="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-yellow-500/10 border border-yellow-500/30 text-yellow-300 text-xs font-semibold uppercase tracking-wide cursor-pointer hover:bg-yellow-500/20 transition"
          >
            <i className="fas fa-clock"></i>
            Delayed 15 min
          </button>
          {open && (
            <div className="absolute right-0 top-full mt-2 glass-card p-4 rounded-lg w-72 text-xs text-slate-300 z-50 shadow-2xl border border-slate-700">
              <div className="flex items-start gap-2 mb-2">
                <i className="fas fa-info-circle text-yellow-400 mt-0.5"></i>
                <div>
                  <div className="font-semibold text-white mb-1">Data Delay Notice</div>
                  <div className="text-slate-400 leading-relaxed">
                    US stock exchanges provide data with a 15-minute delay for free tiers.
                    Additional sources: Financial Modeling Prep, Finnhub, EOD Historical Data.
                  </div>
                </div>
              </div>
              <div className="mt-3 pt-3 border-t border-slate-700 text-xs text-slate-500">
                Not investment advice. Always consult a licensed financial adviser.
              </div>
              <button
                onClick={() => setOpen(false)}
                className="mt-2 w-full py-1.5 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs font-medium transition"
              >
                Got it
              </button>
            </div>
          )}
        </div>
      );
    }

    function Footer() {
      return (
        <footer className="mt-8 px-6 py-4 glass rounded-2xl">
          <div className="flex items-center justify-between text-xs text-slate-500">
            <div className="flex items-center gap-4">
              <span>Â© 2026 RetailEdge Pro</span>
              <span className="text-slate-700">â€¢</span>
              <span>Data delayed 15 min</span>
              <span className="text-slate-700">â€¢</span>
              <span>Not investment advice</span>
            </div>
            <div className="flex items-center gap-3">
              <a href="#" className="hover:text-cyan-400 transition">Terms</a>
              <span className="text-slate-700">â€¢</span>
              <a href="#" className="hover:text-cyan-400 transition">Privacy</a>
              <span className="text-slate-700">â€¢</span>
              <a href="#" className="hover:text-cyan-400 transition">Support</a>
            </div>
          </div>
          <div className="mt-2 text-[10px] text-slate-600 text-center">
            Please consult a licensed financial adviser before making investment decisions.
          </div>
        </footer>
      );
    }

    function PaywallCard({ feature, description }) {
      const { tier } = usePremium();

      const upgrade = () => {
        // Show upgrade modal or redirect to pricing
        alert(`Upgrade to Premium to unlock ${feature}!\n\nCurrent tier: ${tier}\n\nPremium features:\nâ€¢ Unlimited watchlist\nâ€¢ Advanced analytics\nâ€¢ Real-time alerts\nâ€¢ Portfolio tracking\nâ€¢ And more!`);

        // In production, integrate with Stripe:
        // const stripe = window.Stripe(STRIPE_PUBLIC_KEY);
        // stripe.redirectToCheckout({ sessionId: ... });
      };

      return (
        <div className="glass-card p-6 rounded-xl border-2 border-yellow-500/30 bg-gradient-to-br from-yellow-500/5 to-orange-500/5">
          <div className="text-center">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-br from-yellow-500 to-orange-500 rounded-full mb-4">
              <i className="fas fa-crown text-white text-2xl"></i>
            </div>
            <h3 className="text-xl font-bold text-white mb-2">Premium Feature</h3>
            <div className="text-yellow-300 font-semibold mb-2">{feature}</div>
            <p className="text-slate-400 text-sm mb-4 leading-relaxed">
              {description || 'This feature is available for Premium and Pro subscribers.'}
            </p>
            <div className="space-y-2 mb-4">
              <div className="flex items-center gap-2 text-sm text-slate-300">
                <i className="fas fa-check text-emerald-400"></i>
                <span>Unlimited watchlist items</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-slate-300">
                <i className="fas fa-check text-emerald-400"></i>
                <span>Advanced analytics & insights</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-slate-300">
                <i className="fas fa-check text-emerald-400"></i>
                <span>Real-time price alerts</span>
              </div>
            </div>
            <button
              onClick={upgrade}
              className="w-full py-3 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-400 hover:to-orange-400 text-white rounded-lg font-bold text-sm transition shadow-lg shadow-yellow-500/20"
            >
              Upgrade to Premium
            </button>
            <div className="mt-3 text-xs text-slate-500">
              Starting at $9.99/month â€¢ Cancel anytime
            </div>
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EDUCATION CENTER MODAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // SocialSentimentLeaderboard Component
    function SocialSentimentLeaderboard({ onStockClick }) {
      const [leaderboard, setLeaderboard] = useState([]);
      const [loading, setLoading] = useState(true);
      const [lastUpdate, setLastUpdate] = useState(null);
      const [selectedPlatform, setSelectedPlatform] = useState('all');

      const platforms = [
        { id: 'all', name: 'All Platforms', icon: 'ğŸŒ' },
        { id: 'reddit', name: 'Reddit', icon: 'ğŸ¤–' },
        { id: 'stocktwits', name: 'StockTwits', icon: 'ğŸ“ˆ' },
      ];

      const fetchLeaderboard = async () => {
        setLoading(true);
        try {
          const symbols = DEMO_STOCKS.map(stock => stock.symbol);

          // Fetch sentiment for all symbols
          const sentimentPromises = symbols.map(symbol =>
            window.socialSentiment?.fetchSocialSentiment(symbol).catch(() => null)
          );

          const results = await Promise.all(sentimentPromises);

          // Filter out nulls and create leaderboard
          const validResults = results
            .filter((data, idx) => data && data.totalMessages > 0)
            .map((data, idx) => ({
              symbol: symbols[idx],
              stock: DEMO_STOCKS.find(s => s.symbol === symbols[idx]),
              ...data,
              sentimentScore: data.sentimentScore || 0,
              mentionChange: calculateMentionChange(symbols[idx], data.totalMessages),
              trend: determineTrend(data)
            }))
            .sort((a, b) => b.totalMessages - a.totalMessages); // Most mentions first

          setLeaderboard(validResults.slice(0, 50)); // Top 50
          setLastUpdate(Date.now());
        } catch (error) {
          console.error('Leaderboard fetch error:', error);
        } finally {
          setLoading(false);
        }
      };

      // Calculate mention change vs 24h ago
      const calculateMentionChange = (symbol, currentMentions) => {
        const cacheKey = `mentions_${symbol}`;
        const previous = localStorage.getItem(cacheKey);

        if (previous) {
          const prevData = JSON.parse(previous);
          const timeDiff = Date.now() - prevData.timestamp;

          if (timeDiff < 24 * 60 * 60 * 1000) {
            const change = ((currentMentions - prevData.count) / prevData.count) * 100;
            return change;
          }
        }

        // Save current for next comparison
        localStorage.setItem(cacheKey, JSON.stringify({
          count: currentMentions,
          timestamp: Date.now()
        }));

        return 0;
      };

      // Determine if stock is heating up or cooling down
      const determineTrend = (data) => {
        const recent = data.recentMentions || 0;
        const older = data.olderMentions || 1;
        const ratio = recent / older;

        if (ratio > 2) return 'spiking';
        if (ratio > 1.3) return 'rising';
        if (ratio < 0.7) return 'falling';
        return 'stable';
      };

      // Auto-refresh every 30 minutes
      useEffect(() => {
        fetchLeaderboard();
        const interval = setInterval(fetchLeaderboard, 30 * 60 * 1000);
        return () => clearInterval(interval);
      }, []);

      if (loading) {
        return (
          <div className="glass-card p-8 rounded-xl text-center">
            <i className="fas fa-spinner animate-spin text-3xl text-cyan-400 mb-3"></i>
            <p className="text-slate-400">Analyzing social buzz across platforms...</p>
          </div>
        );
      }

      return (
        <div className="space-y-6">
          {/* Platform Filter */}
          <div className="flex gap-2 mb-4">
            {platforms.map(p => (
              <button
                key={p.id}
                onClick={() => setSelectedPlatform(p.id)}
                className={`px-4 py-2 rounded-lg font-semibold text-sm transition ${selectedPlatform === p.id
                  ? 'bg-cyan-500/20 text-cyan-300 border border-cyan-500/30'
                  : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                  }`}
              >
                <span className="mr-2">{p.icon}</span>
                {p.name}
              </button>
            ))}
          </div>

          {/* Last Update */}
          <div className="flex items-center gap-2 text-xs text-slate-500">
            <i className="fas fa-clock"></i>
            Last updated: {lastUpdate ? new Date(lastUpdate).toLocaleTimeString() : 'Never'}
            <span className="text-cyan-400">(Updates every 30min)</span>
          </div>

          {/* Leaderboard */}
          <div className="glass-card rounded-xl overflow-hidden">
            <table className="w-full">
              <thead className="bg-slate-800/50">
                <tr className="text-left text-xs text-slate-400 uppercase">
                  <th className="p-3">Rank</th>
                  <th className="p-3">Stock</th>
                  <th className="p-3">Mentions</th>
                  <th className="p-3">24h Change</th>
                  <th className="p-3">Sentiment</th>
                  <th className="p-3">Trend</th>
                  <th className="p-3">Action</th>
                </tr>
              </thead>
              <tbody>
                {leaderboard.map((item, idx) => {
                  const trendConfig = {
                    spiking: { icon: 'ğŸš€', color: 'text-orange-400', label: 'Spiking' },
                    rising: { icon: 'ğŸ“ˆ', color: 'text-green-400', label: 'Rising' },
                    falling: { icon: 'ğŸ“‰', color: 'text-red-400', label: 'Falling' },
                    stable: { icon: 'â¡ï¸', color: 'text-slate-400', label: 'Stable' }
                  }[item.trend] || { icon: 'â¡ï¸', color: 'text-slate-400', label: 'Stable' };

                  return (
                    <tr
                      key={item.symbol}
                      className="border-b border-slate-700/30 hover:bg-slate-700/20 cursor-pointer"
                      onClick={() => item.stock && onStockClick(item.stock)}
                    >
                      <td className="p-3">
                        <div className={`font-bold ${idx === 0 ? 'text-yellow-400' :
                          idx === 1 ? 'text-slate-400' :
                            idx === 2 ? 'text-orange-400' :
                              'text-slate-300'
                          }`}>
                          #{idx + 1}
                        </div>
                      </td>
                      <td className="p-3">
                        <div className="font-bold text-white">{item.symbol}</div>
                        <div className="text-xs text-slate-400 truncate max-w-32">
                          {item.stock?.companyName || item.stock?.name || 'â€”'}
                        </div>
                      </td>
                      <td className="p-3">
                        <div className="font-semibold text-white">
                          {item.totalMessages?.toLocaleString() || 0}
                        </div>
                        <div className="text-xs text-slate-400">
                          {item.stocktwitsCount || 0} ST + {item.redditCount || 0} RD
                        </div>
                      </td>
                      <td className="p-3">
                        <div className={`font-semibold ${item.mentionChange > 50 ? 'text-green-400' :
                          item.mentionChange > 0 ? 'text-green-300' :
                            'text-red-400'
                          }`}>
                          {item.mentionChange > 0 ? '+' : ''}{item.mentionChange?.toFixed(0) || 0}%
                        </div>
                      </td>
                      <td className="p-3">
                        <div className={`font-semibold ${item.sentimentScore > 50 ? 'text-green-400' :
                          item.sentimentScore > 0 ? 'text-yellow-400' :
                            'text-red-400'
                          }`}>
                          {item.sentimentScore > 0 ? '+' : ''}{item.sentimentScore || 0}%
                        </div>
                        <div className="text-xs text-slate-400">
                          {item.bullishPercent || 0}% bullish
                        </div>
                      </td>
                      <td className="p-3">
                        <div className={`flex items-center gap-1 ${trendConfig.color}`}>
                          <span>{trendConfig.icon}</span>
                          <span className="text-sm">{trendConfig.label}</span>
                        </div>
                      </td>
                      <td className="p-3">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            if (item.stock) onStockClick(item.stock);
                          }}
                          className="px-3 py-1 bg-cyan-600 hover:bg-cyan-500 text-white rounded text-sm font-medium"
                        >
                          View
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>

          {/* Summary Stats */}
          <div className="grid grid-cols-3 gap-4 mt-6">
            <div className="glass-card p-4 rounded-lg text-center">
              <div className="text-2xl font-bold text-green-400">{leaderboard.filter(i => i.sentimentScore > 50).length}</div>
              <div className="text-xs text-slate-400">Bullish Sentiment</div>
            </div>
            <div className="glass-card p-4 rounded-lg text-center">
              <div className="text-2xl font-bold text-orange-400">{leaderboard.filter(i => i.trend === 'spiking').length}</div>
              <div className="text-xs text-slate-400">Spiking Now</div>
            </div>
            <div className="glass-card p-4 rounded-lg text-center">
              <div className="text-2xl font-bold text-cyan-400">
                {leaderboard.reduce((sum, i) => sum + (i.totalMessages || 0), 0).toLocaleString()}
              </div>
              <div className="text-xs text-slate-400">Total Mentions</div>
            </div>
          </div>
        </div>
      );
    }

    // WatchlistTab Component
    function WatchlistTab({ watchlist, stocks, onRemoveFromWatchlist, onStockClick, setShowWatchlistOnly }) {
      const [watchlistStocks, setWatchlistStocks] = useState([]);
      const [loading, setLoading] = useState(true);
      const [stats, setStats] = useState({ totalValue: 0, totalChange: 0, avgChange: 0 });

      useEffect(() => {
        const loadWatchlistData = async () => {
          if (!watchlist || watchlist.length === 0) {
            setWatchlistStocks([]);
            setLoading(false);
            return;
          }

          setLoading(true);

          // Get current data for each watchlist stock
          const loadedStocks = watchlist
            .map(symbol => {
              const stock = stocks.find(s => s.symbol === symbol);
              if (stock) {
                return stock;
              }
              // Try to fetch from cache if not in current stocks
              const cached = Cache.get(symbol, 'stock');
              if (cached) return cached;
              return null;
            })
            .filter(Boolean);

          setWatchlistStocks(loadedStocks);

          // Calculate stats
          const totalValue = loadedStocks.reduce((sum, s) => sum + (s.marketCap || 0), 0);
          const totalChange = loadedStocks.reduce((sum, s) => sum + (s.changePct || 0), 0);
          const avgChange = loadedStocks.length > 0 ? totalChange / loadedStocks.length : 0;

          setStats({
            totalValue,
            totalChange,
            avgChange,
            count: loadedStocks.length
          });

          setLoading(false);
        };

        loadWatchlistData();
      }, [watchlist, stocks]);

      if (loading) {
        return (
          <div className="glass-card p-8 rounded-xl text-center">
            <i className="fas fa-spinner animate-spin text-3xl text-cyan-400 mb-3"></i>
            <p className="text-slate-400">Loading your watchlist...</p>
          </div>
        );
      }

      if (!watchlist || watchlist.length === 0) {
        return (
          <div className="glass-card p-8 rounded-xl text-center">
            <i className="fas fa-star text-6xl text-slate-700 mb-4"></i>
            <h3 className="text-xl font-bold text-white mb-2">Your Watchlist is Empty</h3>
            <p className="text-slate-400 mb-4">Add stocks to watchlist from the main screener to see them here</p>
            <button
              onClick={() => setShowWatchlistOnly(false)}
              className="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-lg font-semibold"
            >
              Browse Stocks
            </button>
          </div>
        );
      }

      return (
        <div className="space-y-6">
          {/* Header Stats */}
          <div className="glass-card p-5 rounded-xl">
            <h3 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
              <i className="fas fa-star text-yellow-400"></i>
              My Watchlist ({stats.count} stocks)
            </h3>

            <div className="grid grid-cols-3 gap-4">
              <div className="text-center">
                <div className="text-2xl font-bold text-white">
                  ${formatNumber(stats.totalValue)}
                </div>
                <div className="text-xs text-slate-400">Total Market Cap</div>
              </div>
              <div className="text-center">
                <div className={`text-2xl font-bold ${getSentimentColor(stats.avgChange)}`}>
                  {formatPercent(stats.avgChange)}
                </div>
                <div className="text-xs text-slate-400">Avg Change</div>
              </div>
              <div className="text-center">
                <div className={`text-2xl font-bold ${stats.totalChange >= 0 ? 'text-green-400' : 'text-red-400'
                  }`}>
                  {formatPercent(stats.totalChange)}
                </div>
                <div className="text-xs text-slate-400">Combined Change</div>
              </div>
            </div>
          </div>

          {/* Watchlist Table */}
          <div className="glass-card rounded-xl overflow-hidden">
            <table className="w-full">
              <thead className="bg-slate-800/50">
                <tr className="text-left text-xs text-slate-400 uppercase">
                  <th className="p-3">Symbol</th>
                  <th className="p-3">Price</th>
                  <th className="p-3">Change%</th>
                  <th className="p-3">Volume</th>
                  <th className="p-3">P/E</th>
                  <th className="p-3">ROE%</th>
                  <th className="p-3">AI Score</th>
                  <th className="p-3">Actions</th>
                </tr>
              </thead>
              <tbody>
                {watchlistStocks.map(stock => {
                  const analysis = computeEnhancedAnalysis(stock);

                  return (
                    <tr
                      key={stock.symbol}
                      className="border-b border-slate-700/30 hover:bg-slate-700/20 cursor-pointer"
                      onClick={() => onStockClick(stock)}
                    >
                      <td className="p-3">
                        <div className="flex items-center gap-2">
                          <span className="font-bold text-white">{stock.symbol}</span>
                          {watchlist && Array.isArray(watchlist) && watchlist.some(w => w && w.toUpperCase() === stock.symbol.toUpperCase()) && (
                            <span className="text-yellow-400">â˜…</span>
                          )}
                        </div>
                        <div className="text-xs text-slate-400 truncate max-w-32">
                          {stock.companyName || stock.name || 'â€”'}
                        </div>
                      </td>
                      <td className="p-3 font-semibold text-white">
                        ${stock.price?.toFixed(2)}
                      </td>
                      <td className={`p-3 font-semibold ${getSentimentColor(stock.changePct)}`}>
                        {formatPercent(stock.changePct)}
                      </td>
                      <td className="p-3 text-slate-300">
                        {formatNumber(stock.volume)}
                      </td>
                      <td className="p-3 text-slate-300">
                        {stock.pe?.toFixed(1) || 'â€”'}
                      </td>
                      <td className="p-3 text-slate-300">
                        {stock.roe?.toFixed(1) || 'â€”'}%
                      </td>
                      <td className="p-3">
                        <div className={`font-bold ${analysis.aiScore >= 80 ? 'text-green-400' :
                          analysis.aiScore >= 60 ? 'text-yellow-400' :
                            'text-red-400'
                          }`}>
                          {analysis.aiScore}/100
                        </div>
                        <div className={`text-xs ${analysis.verdict === 'STRONG BUY' || analysis.verdict === 'BUY'
                          ? 'text-green-400' :
                          analysis.verdict === 'SELL' ? 'text-red-400' :
                            'text-slate-400'
                          }`}>
                          {analysis.verdict}
                        </div>
                      </td>
                      <td className="p-3">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            onRemoveFromWatchlist && onRemoveFromWatchlist(stock.symbol);
                          }}
                          className="px-3 py-1 bg-red-600 hover:bg-red-500 text-white rounded text-sm font-medium"
                          title="Remove from watchlist"
                        >
                          <i className="fas fa-trash"></i>
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>

          {/* Quick Actions */}
          <div className="flex gap-3">
            <button
              onClick={() => {
                // Clear watchlist
                if (confirm('Are you sure you want to clear your entire watchlist?')) {
                  watchlist.forEach(symbol => onRemoveFromWatchlist(symbol));
                }
              }}
              className="px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded-lg font-medium"
            >
              <i className="fas fa-trash-alt mr-2"></i>
              Clear Watchlist
            </button>
            <button
              onClick={() => {
                // Export watchlist to CSV
                const csv = watchlistStocks.map(s =>
                  `${s.symbol},${s.name || ''},$${s.price},${s.changePct}%`
                ).join('\n');
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `watchlist_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
              }}
              className="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-medium"
            >
              <i className="fas fa-download mr-2"></i>
              Export CSV
            </button>
          </div>
        </div>
      );
    }

    // DataFreshnessIndicator Component
    function DataFreshnessIndicator({ timestamp, type }) {
      const [display, setDisplay] = useState('');

      const format = () => {
        if (!timestamp) return 'Never updated';

        const minutes = Math.floor((Date.now() - timestamp) / 60000);

        if (type === 'heatmap') {
          const nextUpdate = 60 - (minutes % 60);
          return `Next update: ${nextUpdate} min`;
        }

        const interval = type === 'news' || type === 'sentiment' ? 30 : 60;
        const nextUpdate = Math.max(0, interval - minutes);

        if (minutes < 1) return 'Updated just now';
        if (minutes < 60) return `Updated ${minutes}m ago (next: ${nextUpdate}m)`;
        return `Updated ${Math.floor(minutes / 60)}h ago`;
      };

      useEffect(() => {
        setDisplay(format());
        const id = setInterval(() => setDisplay(format()), 60000);
        return () => clearInterval(id);
      }, [timestamp, type]);

      const colorClass = timestamp && (Date.now() - timestamp) < 60000
        ? 'text-green-400'
        : 'text-slate-400';

      return (
        <div className={`flex items-center gap-2 text-xs ${colorClass}`}>
          <i className="fas fa-clock"></i>
          <span>{display}</span>
        </div>
      );
    }

    function EducationCenterModal({ onClose }) {
      const [selectedTab, setSelectedTab] = useState('tutorials');
      const [selectedTutorial, setSelectedTutorial] = useState(null);
      const [selectedCaseStudy, setSelectedCaseStudy] = useState(null);
      const userId = UserManager.getCurrentUser()?.id || 'guest';
      const progress = EDUCATION_CENTER.getProgress(userId);
      const completionRate = EDUCATION_CENTER.getCompletionRate(userId);

      const categories = [
        { id: 'basics', name: 'Basics', icon: 'ğŸ“š' },
        { id: 'metrics', name: 'Metrics', icon: 'ğŸ”¢' },
        { id: 'technical', name: 'Technical', icon: 'ğŸ“Š' },
        { id: 'strategy', name: 'Strategy', icon: 'ğŸ¯' }
      ];

      if (selectedTutorial) {
        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4">
            <div className="glass-card rounded-2xl p-6 w-full max-w-3xl max-h-[90vh] overflow-y-auto">
              <div className="flex items-center justify-between mb-4">
                <button onClick={() => setSelectedTutorial(null)} className="text-cyan-400 hover:text-cyan-300 flex items-center gap-2">
                  <i className="fas fa-arrow-left"></i> Back
                </button>
                <button onClick={onClose} className="text-slate-400 hover:text-white">
                  <i className="fas fa-times text-xl"></i>
                </button>
              </div>

              <div className="mb-6">
                <div className="text-4xl mb-3">{selectedTutorial.icon}</div>
                <h2 className="text-2xl font-bold text-white mb-2">{selectedTutorial.title}</h2>
                <div className="flex items-center gap-3 text-sm text-slate-400">
                  <span><i className="fas fa-clock mr-1"></i>{selectedTutorial.duration}</span>
                  <span>â€¢</span>
                  <span className="px-2 py-1 bg-cyan-500/10 text-cyan-300 rounded">{selectedTutorial.category}</span>
                </div>
              </div>

              <div className="space-y-6">
                <div>
                  <p className="text-slate-300 leading-relaxed">{selectedTutorial.content.intro}</p>
                </div>

                <div>
                  <h3 className="text-lg font-semibold text-white mb-3">Key Points</h3>
                  <ul className="space-y-2">
                    {selectedTutorial.content.keyPoints.map((point, i) => (
                      <li key={i} className="flex items-start gap-3 text-slate-300">
                        <i className="fas fa-check-circle text-emerald-400 mt-1"></i>
                        <span>{point}</span>
                      </li>
                    ))}
                  </ul>
                </div>

                <div className="glass p-4 rounded-lg border border-cyan-500/20">
                  <h4 className="font-semibold text-cyan-300 mb-2">ğŸ’¡ Example</h4>
                  <p className="text-slate-300 text-sm leading-relaxed">{selectedTutorial.content.example}</p>
                </div>

                {selectedTutorial.content.whyItMatters && (
                  <div className="glass p-4 rounded-lg border border-purple-500/20">
                    <h4 className="font-semibold text-purple-300 mb-2">ğŸ¯ Why This Matters</h4>
                    <p className="text-slate-300 text-sm leading-relaxed">{selectedTutorial.content.whyItMatters}</p>
                  </div>
                )}

                {selectedTutorial.content.practicalTip && (
                  <div className="glass p-4 rounded-lg border border-yellow-500/20">
                    <h4 className="font-semibold text-yellow-300 mb-2">âš¡ Practical Tip</h4>
                    <p className="text-slate-300 text-sm leading-relaxed">{selectedTutorial.content.practicalTip}</p>
                  </div>
                )}

                {selectedTutorial.content.nextSteps && (
                  <div>
                    <h4 className="font-semibold text-white mb-2">Next Steps</h4>
                    <div className="flex flex-wrap gap-2">
                      {selectedTutorial.content.nextSteps.map((step, i) => (
                        <span key={i} className="px-3 py-1 bg-slate-700 text-slate-300 rounded-full text-sm">
                          {step}
                        </span>
                      ))}
                    </div>
                  </div>
                )}
              </div>

              <div className="mt-6 flex gap-3">
                <button
                  onClick={() => {
                    EDUCATION_CENTER.markComplete(userId, selectedTutorial.id);
                    setSelectedTutorial(null);
                  }}
                  className="flex-1 py-3 bg-emerald-600 hover:bg-emerald-500 text-white rounded-lg font-semibold transition"
                >
                  <i className="fas fa-check mr-2"></i>Mark Complete
                </button>
                <button
                  onClick={() => setSelectedTutorial(null)}
                  className="px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-semibold transition"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        );
      }

      if (selectedCaseStudy) {
        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4">
            <div className="glass-card rounded-2xl p-6 w-full max-w-3xl max-h-[90vh] overflow-y-auto">
              <div className="flex items-center justify-between mb-4">
                <button onClick={() => setSelectedCaseStudy(null)} className="text-cyan-400 hover:text-cyan-300 flex items-center gap-2">
                  <i className="fas fa-arrow-left"></i> Back
                </button>
                <button onClick={onClose} className="text-slate-400 hover:text-white">
                  <i className="fas fa-times text-xl"></i>
                </button>
              </div>

              <div className="mb-6">
                <div className="text-5xl mb-3">{selectedCaseStudy.icon}</div>
                <h2 className="text-2xl font-bold text-white mb-2">{selectedCaseStudy.title}</h2>
                <div className="flex items-center gap-3 text-sm text-slate-400 mb-3">
                  <span className="font-semibold">{selectedCaseStudy.investor}</span>
                  <span>â€¢</span>
                  <span>{selectedCaseStudy.year}</span>
                </div>
                <p className="text-cyan-300 font-medium">{selectedCaseStudy.summary}</p>
              </div>

              <div className="space-y-6">
                <div className="glass p-4 rounded-lg border border-slate-700">
                  <h3 className="font-semibold text-white mb-2">ğŸ“– The Story</h3>
                  <p className="text-slate-300 leading-relaxed">{selectedCaseStudy.story}</p>
                </div>

                <div>
                  <h3 className="text-lg font-semibold text-white mb-3">Key Lessons</h3>
                  <ul className="space-y-2">
                    {selectedCaseStudy.keyLessons.map((lesson, i) => (
                      <li key={i} className="flex items-start gap-3 text-slate-300">
                        <span className="text-yellow-400 font-bold">{i + 1}.</span>
                        <span>{lesson}</span>
                      </li>
                    ))}
                  </ul>
                </div>

                <div className="glass p-4 rounded-lg border border-emerald-500/20">
                  <h3 className="font-semibold text-emerald-300 mb-3">ğŸ“Š The Numbers</h3>
                  <div className="grid grid-cols-2 gap-4">
                    {Object.entries(selectedCaseStudy.metrics).map(([key, value]) => (
                      <div key={key}>
                        <div className="text-slate-400 text-xs uppercase tracking-wide mb-1">
                          {key.replace(/([A-Z])/g, ' $1').trim()}
                        </div>
                        <div className="text-white font-semibold">{value}</div>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="glass p-4 rounded-lg border border-purple-500/20 bg-gradient-to-br from-purple-500/5 to-pink-500/5">
                  <h4 className="font-semibold text-purple-300 mb-2">ğŸ’ Key Takeaway</h4>
                  <p className="text-white leading-relaxed">{selectedCaseStudy.takeaway}</p>
                </div>
              </div>

              <button
                onClick={() => setSelectedCaseStudy(null)}
                className="mt-6 w-full py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-semibold transition"
              >
                Close
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="glass-card rounded-2xl p-6 w-full max-w-5xl max-h-[90vh] overflow-y-auto">
            <div className="flex items-center justify-between mb-6">
              <div>
                <h2 className="text-2xl font-bold text-white mb-1">ğŸ“š Education Center</h2>
                <p className="text-slate-400 text-sm">Learn investing from the ground up</p>
              </div>
              <button onClick={onClose} className="text-slate-400 hover:text-white">
                <i className="fas fa-times text-xl"></i>
              </button>
            </div>

            {/* Progress Bar */}
            <div className="mb-6 glass p-4 rounded-lg">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm text-slate-400">Your Progress</span>
                <span className="text-sm font-semibold text-cyan-300">{completionRate}%</span>
              </div>
              <div className="w-full h-2 bg-slate-700 rounded-full overflow-hidden">
                <div
                  className="h-full bg-gradient-to-r from-cyan-500 to-emerald-500 transition-all duration-500"
                  style={{ width: `${completionRate}%` }}
                ></div>
              </div>
              <div className="mt-2 text-xs text-slate-500">
                {progress.completed.length} of {EDUCATION_CENTER.tutorials.length} tutorials completed
              </div>
            </div>

            {/* Tabs */}
            <div className="flex gap-2 mb-6 border-b border-slate-700">
              <button
                onClick={() => setSelectedTab('tutorials')}
                className={`px-4 py-2 font-semibold transition ${selectedTab === 'tutorials'
                  ? 'text-cyan-400 border-b-2 border-cyan-400'
                  : 'text-slate-400 hover:text-white'
                  }`}
              >
                <i className="fas fa-book mr-2"></i>Tutorials
              </button>
              <button
                onClick={() => setSelectedTab('case-studies')}
                className={`px-4 py-2 font-semibold transition ${selectedTab === 'case-studies'
                  ? 'text-cyan-400 border-b-2 border-cyan-400'
                  : 'text-slate-400 hover:text-white'
                  }`}
              >
                <i className="fas fa-trophy mr-2"></i>Case Studies
              </button>
            </div>

            {/* Tutorials Tab */}
            {selectedTab === 'tutorials' && (
              <div>
                {categories.map(category => {
                  const tutorials = EDUCATION_CENTER.getTutorialsByCategory(category.id);
                  return (
                    <div key={category.id} className="mb-6">
                      <h3 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                        <span>{category.icon}</span>
                        <span>{category.name}</span>
                      </h3>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {tutorials.map(tutorial => {
                          const isCompleted = progress.completed.includes(tutorial.id);
                          const inProgress = progress.inProgress.includes(tutorial.id);
                          return (
                            <div
                              key={tutorial.id}
                              onClick={() => {
                                if (!isCompleted && !inProgress) {
                                  EDUCATION_CENTER.markInProgress(userId, tutorial.id);
                                }
                                setSelectedTutorial(tutorial);
                              }}
                              className="glass-card p-4 rounded-lg cursor-pointer hover:border-cyan-500/40 transition"
                            >
                              <div className="flex items-start justify-between mb-2">
                                <span className="text-3xl">{tutorial.icon}</span>
                                {isCompleted && (
                                  <span className="px-2 py-1 bg-emerald-500/20 text-emerald-300 rounded text-xs font-semibold">
                                    <i className="fas fa-check mr-1"></i>Done
                                  </span>
                                )}
                                {inProgress && !isCompleted && (
                                  <span className="px-2 py-1 bg-yellow-500/20 text-yellow-300 rounded text-xs font-semibold">
                                    <i className="fas fa-hourglass-half mr-1"></i>In Progress
                                  </span>
                                )}
                              </div>
                              <h4 className="font-semibold text-white mb-1">{tutorial.title}</h4>
                              <p className="text-xs text-slate-400 mb-2">
                                <i className="fas fa-clock mr-1"></i>{tutorial.duration}
                              </p>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}

            {/* Case Studies Tab */}
            {selectedTab === 'case-studies' && (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {EDUCATION_CENTER.caseStudies.map(caseStudy => (
                  <div
                    key={caseStudy.id}
                    onClick={() => setSelectedCaseStudy(caseStudy)}
                    className="glass-card p-5 rounded-lg cursor-pointer hover:border-cyan-500/40 transition"
                  >
                    <div className="text-4xl mb-3">{caseStudy.icon}</div>
                    <h3 className="font-semibold text-white mb-1">{caseStudy.title}</h3>
                    <div className="text-xs text-slate-400 mb-2">
                      {caseStudy.investor} â€¢ {caseStudy.year}
                    </div>
                    <p className="text-sm text-slate-300 leading-relaxed">{caseStudy.summary}</p>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPONENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function AdvancedChartPanel({
      symbol,
      candles,
      timeframe,
      onTimeframe,
      comparisonSymbol,
      onComparisonSymbol,
      comparisonCandles,
      comparisonLoading
    }) {
      const priceRef = useRef(null);
      const rsiRef = useRef(null);
      const macdRef = useRef(null);
      const chartsRef = useRef({ price: null, rsi: null, macd: null });
      const seriesRef = useRef({
        candle: null,
        volume: null,
        bbUpper: null,
        bbMid: null,
        bbLower: null,
        compare: null,
        rsi: null,
        macd: null,
        macdSignal: null,
        macdHist: null,
        drawings: []
      });
      const drawStateRef = useRef({ enabled: false, firstPoint: null });

      const [showBollinger, setShowBollinger] = useState(true);
      const [showRSI, setShowRSI] = useState(true);
      const [showMACD, setShowMACD] = useState(true);
      const [showVolume, setShowVolume] = useState(true);
      const [drawMode, setDrawMode] = useState(false);

      const normalized = useMemo(() => normalizeFmpCandles(candles), [candles]);
      const profile = useMemo(() => computeVolumeProfile(normalized, 24), [normalized]);

      const setDrawEnabled = (enabled) => {
        setDrawMode(enabled);
        drawStateRef.current.enabled = enabled;
        drawStateRef.current.firstPoint = null;
      };

      const clearDrawings = () => {
        const priceChart = chartsRef.current.price;
        if (!priceChart) return;
        for (const s of seriesRef.current.drawings) {
          try { priceChart.removeSeries(s); } catch { }
        }
        seriesRef.current.drawings = [];
        drawStateRef.current.firstPoint = null;
      };

      useEffect(() => {
        if (!window.LightweightCharts) {
          console.warn('âš ï¸ LightweightCharts not available');
          return;
        }
        if (!priceRef.current) return;
        if (!normalized || normalized.length === 0) return;

        // Check if Lightweight Charts library is loaded
        if (!window.LightweightCharts) {
          console.error('âŒ Lightweight Charts library not loaded');
          return;
        }

        // Cleanup previous charts
        try { chartsRef.current.price?.remove(); } catch { }
        try { chartsRef.current.rsi?.remove(); } catch { }
        try { chartsRef.current.macd?.remove(); } catch { }
        chartsRef.current = { price: null, rsi: null, macd: null };
        seriesRef.current.drawings = [];
        drawStateRef.current.firstPoint = null;

        const rootStyles = getComputedStyle(document.documentElement);
        const textSecondary = (rootStyles.getPropertyValue('--text-secondary') || '#94a3b8').trim();

        const common = {
          layout: {
            background: { type: 'solid', color: 'transparent' },
            textColor: textSecondary
          },
          grid: {
            vertLines: { color: 'rgba(148, 163, 184, 0.08)' },
            horzLines: { color: 'rgba(148, 163, 184, 0.08)' }
          },
          timeScale: { borderColor: 'rgba(148, 163, 184, 0.15)' },
          rightPriceScale: { borderColor: 'rgba(148, 163, 184, 0.15)' },
          crosshair: { mode: window.LightweightCharts.CrosshairMode.Normal }
        };

        const priceChart = window.LightweightCharts.createChart(priceRef.current, {
          ...common,
          height: 360,
        });
        chartsRef.current.price = priceChart;

        const candleSeries = priceChart.addCandlestickSeries({
          upColor: '#22c55e',
          downColor: '#ef4444',
          borderUpColor: '#22c55e',
          borderDownColor: '#ef4444',
          wickUpColor: '#22c55e',
          wickDownColor: '#ef4444'
        });
        seriesRef.current.candle = candleSeries;
        candleSeries.setData(normalized);

        const closes = normalized.map(c => c.close);
        const times = normalized.map(c => c.time);

        // Volume
        const volumeSeries = priceChart.addHistogramSeries({
          priceFormat: { type: 'volume' },
          priceScaleId: '',
          scaleMargins: { top: 0.8, bottom: 0 }
        });
        seriesRef.current.volume = volumeSeries;
        if (showVolume) {
          volumeSeries.setData(normalized.map(c => ({
            time: c.time,
            value: c.volume,
            color: c.close >= c.open ? 'rgba(34,197,94,0.45)' : 'rgba(239,68,68,0.45)'
          })));
        } else {
          volumeSeries.setData([]);
        }

        // Bollinger Bands
        const bbUpper = priceChart.addLineSeries({ color: 'rgba(148,163,184,0.55)', lineWidth: 1 });
        const bbMid = priceChart.addLineSeries({ color: 'rgba(6,182,212,0.65)', lineWidth: 1 });
        const bbLower = priceChart.addLineSeries({ color: 'rgba(148,163,184,0.55)', lineWidth: 1 });
        seriesRef.current.bbUpper = bbUpper;
        seriesRef.current.bbMid = bbMid;
        seriesRef.current.bbLower = bbLower;

        if (showBollinger) {
          const bb = computeBollinger(closes, 20, 2);
          bbUpper.setData(times.map((t, i) => bb.upper[i] == null ? null : ({ time: t, value: bb.upper[i] })).filter(Boolean));
          bbMid.setData(times.map((t, i) => bb.mid[i] == null ? null : ({ time: t, value: bb.mid[i] })).filter(Boolean));
          bbLower.setData(times.map((t, i) => bb.lower[i] == null ? null : ({ time: t, value: bb.lower[i] })).filter(Boolean));
        } else {
          bbUpper.setData([]);
          bbMid.setData([]);
          bbLower.setData([]);
        }

        // Comparison overlay (% change)
        if (comparisonCandles && comparisonCandles.length > 0) {
          const cmp = normalizeFmpCandles(comparisonCandles);
          if (cmp.length > 2) {
            const base = cmp[0].close || 1;
            const compareSeries = priceChart.addLineSeries({
              color: 'rgba(139,92,246,0.85)',
              lineWidth: 2,
              priceScaleId: 'compare'
            });
            priceChart.priceScale('compare').applyOptions({
              scaleMargins: { top: 0.1, bottom: 0.1 },
              borderVisible: false
            });
            compareSeries.setData(cmp.map(p => ({ time: p.time, value: ((p.close - base) / base) * 100 })));
            seriesRef.current.compare = compareSeries;
          }
        }

        // RSI chart
        let rsiChart = null;
        if (showRSI && rsiRef.current) {
          rsiChart = window.LightweightCharts.createChart(rsiRef.current, {
            ...common,
            height: 140,
            timeScale: { visible: false },
          });
          chartsRef.current.rsi = rsiChart;
          const rsiSeries = rsiChart.addLineSeries({ color: 'rgba(6,182,212,0.85)', lineWidth: 2 });
          seriesRef.current.rsi = rsiSeries;
          const rsiVals = computeRSI(closes, 14);
          rsiSeries.setData(times.map((t, i) => rsiVals[i] == null ? null : ({ time: t, value: rsiVals[i] })).filter(Boolean));
        }

        // MACD chart
        let macdChart = null;
        if (showMACD && macdRef.current) {
          macdChart = window.LightweightCharts.createChart(macdRef.current, {
            ...common,
            height: 160,
            timeScale: { visible: true },
          });
          chartsRef.current.macd = macdChart;
          const macdLine = macdChart.addLineSeries({ color: 'rgba(6,182,212,0.85)', lineWidth: 2 });
          const signalLine = macdChart.addLineSeries({ color: 'rgba(148,163,184,0.75)', lineWidth: 1 });
          const histSeries = macdChart.addHistogramSeries({ priceFormat: { type: 'price' } });
          seriesRef.current.macd = macdLine;
          seriesRef.current.macdSignal = signalLine;
          seriesRef.current.macdHist = histSeries;

          const macd = computeMACD(closes, 12, 26, 9);
          macdLine.setData(times.map((t, i) => macd.macd[i] == null ? null : ({ time: t, value: macd.macd[i] })).filter(Boolean));
          signalLine.setData(times.map((t, i) => macd.signal[i] == null ? null : ({ time: t, value: macd.signal[i] })).filter(Boolean));
          histSeries.setData(times.map((t, i) => {
            const v = macd.hist[i];
            if (v == null) return null;
            return { time: t, value: v, color: v >= 0 ? 'rgba(34,197,94,0.55)' : 'rgba(239,68,68,0.55)' };
          }).filter(Boolean));
        }

        // Sync visible range across charts
        const syncRange = (source, target) => {
          if (!source || !target) return () => { };
          const handler = (range) => {
            try { target.timeScale().setVisibleRange(range); } catch { }
          };
          source.timeScale().subscribeVisibleTimeRangeChange(handler);
          return () => source.timeScale().unsubscribeVisibleTimeRangeChange(handler);
        };
        const unsub1 = syncRange(priceChart, rsiChart);
        const unsub2 = syncRange(priceChart, macdChart);

        // Drawing tool: trendline (two clicks)
        const clickHandler = (param) => {
          if (!drawStateRef.current.enabled) return;
          if (!param || !param.time) return;
          const seriesData = param.seriesData;
          let price = null;
          try {
            if (seriesData && seriesData.get && seriesRef.current.candle) {
              const p = seriesData.get(seriesRef.current.candle);
              price = p?.close ?? p?.value ?? p?.open ?? null;
            }
          } catch { }
          if (price == null) return;

          if (!drawStateRef.current.firstPoint) {
            drawStateRef.current.firstPoint = { time: param.time, value: price };
            return;
          }
          const p1 = drawStateRef.current.firstPoint;
          const p2 = { time: param.time, value: price };
          drawStateRef.current.firstPoint = null;

          const line = priceChart.addLineSeries({ color: 'rgba(6,182,212,0.75)', lineWidth: 2 });
          line.setData([p1, p2].sort((a, b) => a.time - b.time));
          seriesRef.current.drawings.push(line);
        };
        priceChart.subscribeClick(clickHandler);

        const ro = new ResizeObserver(entries => {
          for (const e of entries) {
            const w = Math.floor(e.contentRect.width);
            try { priceChart.applyOptions({ width: w }); } catch { }
            try { rsiChart?.applyOptions({ width: w }); } catch { }
            try { macdChart?.applyOptions({ width: w }); } catch { }
          }
        });
        ro.observe(priceRef.current);

        return () => {
          try { priceChart.unsubscribeClick(clickHandler); } catch { }
          unsub1();
          unsub2();
          try { ro.disconnect(); } catch { }
          try { priceChart.remove(); } catch { }
          try { rsiChart?.remove(); } catch { }
          try { macdChart?.remove(); } catch { }
        };
      }, [normalized, showBollinger, showRSI, showMACD, showVolume, comparisonCandles]);

      return (
        <div className="space-y-4">
          {!window.LightweightCharts && (
            <div className="glass-card p-4 rounded-xl border border-yellow-500/30 bg-yellow-500/10">
              <div className="text-yellow-300 font-semibold text-sm mb-1">Chart library failed to load</div>
              <div className="text-xs text-slate-300">The Lightweight Charts script didnâ€™t load (network blocked or CDN unavailable). Refresh the page or try a different network.</div>
            </div>
          )}

          {window.LightweightCharts && (!normalized || normalized.length === 0) && (
            <div className="glass-card p-4 rounded-xl border border-slate-700/40">
              <div className="text-slate-200 font-semibold text-sm mb-1">No chart candles available</div>
              <div className="text-xs text-slate-400">This usually means the API returned no candles for the selected timeframe, or the timestamps were not parseable.</div>
            </div>
          )}
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div className="flex items-center gap-2 flex-wrap">
              <div className="text-xs text-slate-500">Timeframe</div>
              {[{ id: '1hour', label: '1H' }, { id: '4hour', label: '4H' }, { id: '1day', label: '1D' }].map(tf => (
                <button
                  key={tf.id}
                  onClick={() => onTimeframe(tf.id)}
                  className={`px-3 py-1 rounded-lg text-xs font-semibold border transition ${timeframe === tf.id ? 'bg-cyan-500/20 text-cyan-300 border-cyan-500/30' : 'bg-slate-800/40 text-slate-300 border-slate-700/30 hover:bg-slate-700/30'}`}
                >
                  {tf.label}
                </button>
              ))}

              <div className="w-px h-6 bg-slate-700/40 mx-1"></div>

              <button
                onClick={() => setShowBollinger(v => !v)}
                className={`px-3 py-1 rounded-lg text-xs font-semibold border transition ${showBollinger ? 'bg-slate-700/40 text-slate-100 border-slate-600/40' : 'bg-slate-800/40 text-slate-400 border-slate-700/30'}`}
              >
                Bollinger
              </button>
              <button
                onClick={() => setShowRSI(v => !v)}
                className={`px-3 py-1 rounded-lg text-xs font-semibold border transition ${showRSI ? 'bg-slate-700/40 text-slate-100 border-slate-600/40' : 'bg-slate-800/40 text-slate-400 border-slate-700/30'}`}
              >
                RSI
              </button>
              <button
                onClick={() => setShowMACD(v => !v)}
                className={`px-3 py-1 rounded-lg text-xs font-semibold border transition ${showMACD ? 'bg-slate-700/40 text-slate-100 border-slate-600/40' : 'bg-slate-800/40 text-slate-400 border-slate-700/30'}`}
              >
                MACD
              </button>
              <button
                onClick={() => setShowVolume(v => !v)}
                className={`px-3 py-1 rounded-lg text-xs font-semibold border transition ${showVolume ? 'bg-slate-700/40 text-slate-100 border-slate-600/40' : 'bg-slate-800/40 text-slate-400 border-slate-700/30'}`}
              >
                Volume
              </button>
            </div>

            <div className="flex items-center gap-2 flex-wrap">
              <div className="text-xs text-slate-500">Compare</div>
              <input
                value={comparisonSymbol}
                onChange={(e) => onComparisonSymbol(e.target.value.toUpperCase().replace(/[^A-Z.]/g, '').slice(0, 10))}
                placeholder="e.g. SPY"
                className="px-3 py-1 rounded-lg text-xs bg-slate-900/40 border border-slate-700/40 text-slate-200 w-28"
              />
              {comparisonLoading && (
                <span className="text-xs text-slate-500">Loadingâ€¦</span>
              )}
              <div className="w-px h-6 bg-slate-700/40 mx-1"></div>
              <button
                onClick={() => setDrawEnabled(!drawMode)}
                className={`px-3 py-1 rounded-lg text-xs font-semibold border transition ${drawMode ? 'bg-cyan-500/20 text-cyan-300 border-cyan-500/30' : 'bg-slate-800/40 text-slate-300 border-slate-700/30 hover:bg-slate-700/30'}`}
              >
                {drawMode ? 'Drawing: ON' : 'Draw Trendline'}
              </button>
              <button
                onClick={clearDrawings}
                className="px-3 py-1 rounded-lg text-xs font-semibold border border-slate-700/30 bg-slate-800/40 text-slate-300 hover:bg-slate-700/30"
              >
                Clear
              </button>
            </div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-5 gap-4">
            <div className="lg:col-span-4 space-y-3">
              <div className="glass-card p-4 rounded-xl">
                <div ref={priceRef} style={{ width: '100%' }} />
              </div>
              {showRSI && (
                <div className="glass-card p-4 rounded-xl">
                  <div className="text-xs text-slate-500 mb-2">
                    RSI (14)
                  </div>
                  <div ref={rsiRef} style={{ width: '100%' }} />
                </div>
              )}
              {showMACD && (
                <div className="glass-card p-4 rounded-xl">
                  <div className="text-xs text-slate-500 mb-2">MACD (12, 26, 9)</div>
                  <div ref={macdRef} style={{ width: '100%' }} />
                </div>
              )}
            </div>

            <div className="lg:col-span-1">
              <div className="glass-card p-4 rounded-xl">
                <div className="flex items-center justify-between mb-3">
                  <div>
                    <div className="text-sm font-bold text-white">Volume Profile</div>
                    <div className="text-xs text-slate-500">Approx. by typical price</div>
                  </div>
                </div>
                {profile.length === 0 ? (
                  <div className="text-sm text-slate-500">Not enough data</div>
                ) : (
                  <div className="space-y-1">
                    {profile.slice(0, 18).map((b, idx) => (
                      <div key={idx} className="flex items-center gap-2">
                        <div className="text-[10px] text-slate-500 w-16 font-mono">
                          {b.lo.toFixed(0)}-{b.hi.toFixed(0)}
                        </div>
                        <div className="flex-1 h-2 bg-slate-800/40 rounded overflow-hidden">
                          <div className="h-full bg-slate-500/50" style={{ width: `${Math.max(2, Math.min(100, b.pct))}%` }} />
                        </div>
                      </div>
                    ))}
                  </div>
                )}
                <div className="mt-3 text-[10px] text-slate-500">
                  {comparisonSymbol ? `Compare overlay: ${comparisonSymbol}` : 'Add a comparison symbol to overlay % change.'}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ULTIMATE ANALYSIS ENGINE - Advanced Scoring & Pattern Detection
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class UltimateAnalysisEngine {
      constructor() {
        this.cache = new Map();
        this.cacheDuration = 300000; // 5 minutes
      }

      // 15-Factor Advanced Scoring System
      calculateUltimateScore(stock) {
        const factors = {};
        let totalScore = 0;
        let maxScore = 0;

        // 1. RSI Score (15 points)
        if (stock.rsi) {
          maxScore += 15;
          const rsi = parseFloat(stock.rsi);
          if (rsi >= 40 && rsi <= 60) {
            factors.rsi = 15;
          } else if (rsi >= 30 && rsi <= 70) {
            factors.rsi = 10;
          } else if (rsi < 30) {
            factors.rsi = 12; // Oversold = potential bounce
          } else {
            factors.rsi = 5;
          }
          totalScore += factors.rsi;
        }

        // 2. MACD Score (10 points)
        if (stock.macd || stock.macdHistogram) {
          maxScore += 10;
          const macd = parseFloat(stock.macd || stock.macdHistogram || 0);
          if (macd > 0) {
            factors.macd = 10;
          } else if (macd > -0.5) {
            factors.macd = 7;
          } else {
            factors.macd = 3;
          }
          totalScore += factors.macd;
        }

        // 3. Moving Average Trend (12 points)
        if (stock.sma20 && stock.sma50) {
          maxScore += 12;
          const price = parseFloat(stock.price);
          const sma20 = parseFloat(stock.sma20);
          const sma50 = parseFloat(stock.sma50);

          if (price > sma20 && sma20 > sma50) {
            factors.trend = 12; // Golden cross
          } else if (price > sma20 || sma20 > sma50) {
            factors.trend = 8;
          } else {
            factors.trend = 3;
          }
          totalScore += factors.trend;
        }

        // 4. Volume Momentum (10 points)
        if (stock.volume && stock.avgVolume) {
          maxScore += 10;
          const volumeRatio = parseFloat(stock.volume) / parseFloat(stock.avgVolume);
          if (volumeRatio > 2.0) {
            factors.volume = 10; // Surge
          } else if (volumeRatio > 1.5) {
            factors.volume = 8;
          } else if (volumeRatio > 1.0) {
            factors.volume = 5;
          } else {
            factors.volume = 2;
          }
          totalScore += factors.volume;
        }

        // 5. Valuation Score (8 points)
        if (stock.pe) {
          maxScore += 8;
          const pe = parseFloat(stock.pe);
          if (pe > 0 && pe < 15) {
            factors.valuation = 8;
          } else if (pe >= 15 && pe < 25) {
            factors.valuation = 6;
          } else if (pe >= 25 && pe < 40) {
            factors.valuation = 4;
          } else {
            factors.valuation = 2;
          }
          totalScore += factors.valuation;
        }

        // 6. Profitability (8 points)
        if (stock.roe) {
          maxScore += 8;
          const roe = parseFloat(stock.roe);
          if (roe > 20) {
            factors.profitability = 8;
          } else if (roe > 15) {
            factors.profitability = 6;
          } else if (roe > 10) {
            factors.profitability = 4;
          } else {
            factors.profitability = 2;
          }
          totalScore += factors.profitability;
        }

        // 7. Growth Score (10 points)
        if (stock.revenueGrowth || stock.epsGrowth) {
          maxScore += 10;
          const growth = Math.max(
            parseFloat(stock.revenueGrowth || 0),
            parseFloat(stock.epsGrowth || 0)
          );
          if (growth > 20) {
            factors.growth = 10;
          } else if (growth > 10) {
            factors.growth = 7;
          } else if (growth > 5) {
            factors.growth = 4;
          } else {
            factors.growth = 2;
          }
          totalScore += factors.growth;
        }

        // 8. Financial Health (8 points)
        if (stock.debtToEquity !== undefined) {
          maxScore += 8;
          const dte = parseFloat(stock.debtToEquity);
          if (dte < 0.5) {
            factors.health = 8;
          } else if (dte < 1.0) {
            factors.health = 6;
          } else if (dte < 2.0) {
            factors.health = 4;
          } else {
            factors.health = 2;
          }
          totalScore += factors.health;
        }

        // 9. Momentum (7 points)
        if (stock.changePct !== undefined) {
          maxScore += 7;
          const change = parseFloat(stock.changePct);
          if (change > 5) {
            factors.momentum = 7;
          } else if (change > 2) {
            factors.momentum = 5;
          } else if (change > 0) {
            factors.momentum = 3;
          } else if (change > -2) {
            factors.momentum = 2;
          } else {
            factors.momentum = 1;
          }
          totalScore += factors.momentum;
        }

        // 10. Volatility (6 points) - Lower is better
        if (stock.beta) {
          maxScore += 6;
          const beta = Math.abs(parseFloat(stock.beta));
          if (beta < 0.8) {
            factors.volatility = 6; // Low volatility = stable
          } else if (beta < 1.2) {
            factors.volatility = 4;
          } else {
            factors.volatility = 2;
          }
          totalScore += factors.volatility;
        }

        // 11. Market Position (6 points)
        if (stock.marketCap) {
          maxScore += 6;
          const mcap = parseFloat(stock.marketCap);
          if (mcap > 200e9) { // Large cap
            factors.market_pos = 6;
          } else if (mcap > 10e9) { // Mid cap
            factors.market_pos = 5;
          } else if (mcap > 2e9) { // Small cap
            factors.market_pos = 4;
          } else {
            factors.market_pos = 3; // Micro cap = higher risk
          }
          totalScore += factors.market_pos;
        }

        // 12. Analyst Sentiment (5 points)
        if (stock.analystRating || stock.rating) {
          maxScore += 5;
          const rating = stock.analystRating || stock.rating || '';
          if (rating.toLowerCase().includes('strong buy') || rating.toLowerCase().includes('buy')) {
            factors.analyst = 5;
          } else if (rating.toLowerCase().includes('hold')) {
            factors.analyst = 3;
          } else {
            factors.analyst = 1;
          }
          totalScore += factors.analyst;
        }

        // 13. Price Position (5 points) - Distance from 52w high
        if (stock.week52High && stock.price) {
          maxScore += 5;
          const distanceFrom52wHigh = ((parseFloat(stock.price) - parseFloat(stock.week52High)) / parseFloat(stock.week52High)) * 100;
          if (distanceFrom52wHigh > -5) {
            factors.price_pos = 5; // Near 52w high
          } else if (distanceFrom52wHigh > -15) {
            factors.price_pos = 4;
          } else if (distanceFrom52wHigh > -30) {
            factors.price_pos = 3;
          } else {
            factors.price_pos = 2; // Far from high, potential recovery
          }
          totalScore += factors.price_pos;
        }

        // 14. Dividend Yield (4 points) - Bonus for income
        if (stock.dividendYield) {
          maxScore += 4;
          const divYield = parseFloat(stock.dividendYield);
          if (divYield > 3) {
            factors.dividend = 4;
          } else if (divYield > 2) {
            factors.dividend = 3;
          } else if (divYield > 1) {
            factors.dividend = 2;
          } else {
            factors.dividend = 1;
          }
          totalScore += factors.dividend;
        }

        // 15. Institutional Ownership (6 points)
        if (stock.institutionalOwnership) {
          maxScore += 6;
          const instOwn = parseFloat(stock.institutionalOwnership);
          if (instOwn > 70) {
            factors.institutional = 6;
          } else if (instOwn > 50) {
            factors.institutional = 5;
          } else if (instOwn > 30) {
            factors.institutional = 4;
          } else {
            factors.institutional = 2;
          }
          totalScore += factors.institutional;
        }

        // Normalize to 100
        const normalizedScore = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0;

        return {
          score: normalizedScore,
          factors: factors,
          totalPoints: totalScore,
          maxPoints: maxScore,
          confidence: maxScore > 80 ? 'High' : maxScore > 50 ? 'Medium' : 'Low'
        };
      }

      // Generate AI-Powered Trading Plan
      generateTradingPlan(stock, scoreData) {
        const price = parseFloat(stock.price);
        const atr = stock.atr ? parseFloat(stock.atr) : price * 0.02;
        const signal = this.determineSignal(stock, scoreData);

        let plan = {
          signal: signal,
          entry: price,
          target: 0,
          stopLoss: 0,
          positionSize: '2-5%',
          timeframe: 'Medium-term (2-8 weeks)',
          confidence: scoreData.confidence,
          reasoning: []
        };

        if (signal === 'BUY') {
          // Target: 10-15% above entry based on score
          const targetMultiplier = 1 + (scoreData.score / 1000) + 0.05;
          plan.target = price * targetMultiplier;

          // Stop loss: 2x ATR below entry
          plan.stopLoss = price - (2 * atr);

          // Reasoning
          if (stock.rsi && parseFloat(stock.rsi) < 35) {
            plan.reasoning.push('Oversold RSI indicates potential bounce');
          }
          if (scoreData.factors.volume && scoreData.factors.volume >= 8) {
            plan.reasoning.push('Strong volume surge suggests institutional interest');
          }
          if (scoreData.factors.trend && scoreData.factors.trend >= 10) {
            plan.reasoning.push('Golden cross formation supports bullish trend');
          }
          if (scoreData.factors.growth && scoreData.factors.growth >= 7) {
            plan.reasoning.push('Strong growth metrics indicate expansion');
          }

        } else if (signal === 'SELL') {
          plan.target = price * 0.95; // Exit target
          plan.stopLoss = price * 1.05; // Stop if it reverses up

          if (stock.rsi && parseFloat(stock.rsi) > 70) {
            plan.reasoning.push('Overbought RSI suggests potential correction');
          }
          if (scoreData.score < 40) {
            plan.reasoning.push('Low overall score indicates weakness');
          }

        } else { // HOLD
          plan.target = price * 1.05;
          plan.stopLoss = price * 0.95;
          plan.reasoning.push('Mixed signals - monitor for clearer direction');
        }

        // Risk/Reward ratio
        plan.riskRewardRatio = plan.stopLoss !== price ?
          ((plan.target - price) / (price - plan.stopLoss)).toFixed(2) : 0;

        return plan;
      }

      // Determine trading signal
      determineSignal(stock, scoreData) {
        const score = scoreData.score;
        const rsi = stock.rsi ? parseFloat(stock.rsi) : 50;
        const macd = stock.macd ? parseFloat(stock.macd) : 0;

        // Strong buy conditions
        if (score >= 75 && rsi < 70 && macd > 0) {
          return 'STRONG BUY';
        }

        // Buy conditions
        if (score >= 60 || (rsi < 35 && score >= 50)) {
          return 'BUY';
        }

        // Sell conditions
        if (score < 35 || (rsi > 75 && score < 60)) {
          return 'SELL';
        }

        // Default hold
        return 'HOLD';
      }

      // Detect chart patterns
      detectPatterns(stock) {
        const patterns = [];

        // Check for basic patterns based on available data
        if (stock.sma20 && stock.sma50) {
          const price = parseFloat(stock.price);
          const sma20 = parseFloat(stock.sma20);
          const sma50 = parseFloat(stock.sma50);

          if (sma20 > sma50 && price > sma20) {
            patterns.push({
              name: 'Golden Cross',
              type: 'bullish',
              confidence: 0.80,
              description: '20-day MA crossed above 50-day MA - bullish momentum'
            });
          } else if (sma20 < sma50 && price < sma20) {
            patterns.push({
              name: 'Death Cross',
              type: 'bearish',
              confidence: 0.75,
              description: '20-day MA crossed below 50-day MA - bearish momentum'
            });
          }
        }

        // RSI-based patterns
        if (stock.rsi) {
          const rsi = parseFloat(stock.rsi);
          if (rsi < 30) {
            patterns.push({
              name: 'Oversold',
              type: 'bullish',
              confidence: 0.70,
              description: 'RSI below 30 - potential bounce opportunity'
            });
          } else if (rsi > 70) {
            patterns.push({
              name: 'Overbought',
              type: 'bearish',
              confidence: 0.70,
              description: 'RSI above 70 - potential correction incoming'
            });
          }
        }

        // Volume patterns
        if (stock.volume && stock.avgVolume) {
          const volumeRatio = parseFloat(stock.volume) / parseFloat(stock.avgVolume);
          if (volumeRatio > 2.0) {
            patterns.push({
              name: 'Volume Surge',
              type: 'bullish',
              confidence: 0.65,
              description: 'Volume 2x above average - institutional interest'
            });
          }
        }

        // Bollinger Band patterns
        if (stock.bollingerUpper && stock.bollingerLower && stock.price) {
          const price = parseFloat(stock.price);
          const upper = parseFloat(stock.bollingerUpper);
          const lower = parseFloat(stock.bollingerLower);

          if (price <= lower) {
            patterns.push({
              name: 'Bollinger Bounce',
              type: 'bullish',
              confidence: 0.68,
              description: 'Price at lower Bollinger Band - potential bounce'
            });
          } else if (price >= upper) {
            patterns.push({
              name: 'Bollinger Squeeze',
              type: 'bearish',
              confidence: 0.68,
              description: 'Price at upper Bollinger Band - potential pullback'
            });
          }
        }

        return patterns;
      }

      // Generate comprehensive AI insights
      generateAIInsights(stock, scoreData, patterns, tradingPlan) {
        const insights = {
          summary: '',
          strengths: [],
          risks: [],
          opportunities: [],
          recommendation: ''
        };

        // Summary
        insights.summary = `${stock.symbol} scores ${scoreData.score}/100 with a ${tradingPlan.signal} signal. `;

        if (scoreData.score >= 70) {
          insights.summary += 'Strong fundamentals and technical setup. ';
        } else if (scoreData.score >= 50) {
          insights.summary += 'Moderate quality with mixed signals. ';
        } else {
          insights.summary += 'Weak metrics indicate caution. ';
        }

        // Strengths
        if (scoreData.factors.trend && scoreData.factors.trend >= 10) {
          insights.strengths.push('Bullish trend confirmed by moving averages');
        }
        if (scoreData.factors.volume && scoreData.factors.volume >= 8) {
          insights.strengths.push('Strong volume supports price movement');
        }
        if (scoreData.factors.growth && scoreData.factors.growth >= 7) {
          insights.strengths.push('Solid revenue and earnings growth');
        }
        if (scoreData.factors.profitability && scoreData.factors.profitability >= 6) {
          insights.strengths.push('High return on equity indicates efficiency');
        }

        // Risks
        if (stock.rsi && parseFloat(stock.rsi) > 70) {
          insights.risks.push('Overbought conditions may lead to correction');
        }
        if (stock.debtToEquity && parseFloat(stock.debtToEquity) > 2.0) {
          insights.risks.push('High debt levels increase financial risk');
        }
        if (stock.beta && Math.abs(parseFloat(stock.beta)) > 1.5) {
          insights.risks.push('High volatility stock - expect sharp moves');
        }
        if (scoreData.factors.valuation && scoreData.factors.valuation <= 4) {
          insights.risks.push('Expensive valuation may limit upside');
        }

        // Opportunities
        if (stock.rsi && parseFloat(stock.rsi) < 35) {
          insights.opportunities.push('Oversold bounce play if fundamentals hold');
        }
        if (patterns.some(p => p.type === 'bullish' && p.confidence > 0.7)) {
          insights.opportunities.push('Bullish chart patterns forming');
        }
        if (scoreData.factors.price_pos && scoreData.factors.price_pos <= 3) {
          insights.opportunities.push('Trading well below 52-week high - recovery potential');
        }

        // Recommendation
        if (tradingPlan.signal === 'STRONG BUY' || tradingPlan.signal === 'BUY') {
          insights.recommendation = `Consider ${tradingPlan.positionSize} position. Entry: $${tradingPlan.entry.toFixed(2)}, Target: $${tradingPlan.target.toFixed(2)}, Stop: $${tradingPlan.stopLoss.toFixed(2)}. Risk/Reward: ${tradingPlan.riskRewardRatio}:1`;
        } else if (tradingPlan.signal === 'HOLD') {
          insights.recommendation = 'Wait for clearer signals. Monitor key levels and upcoming catalysts.';
        } else {
          insights.recommendation = 'Avoid or exit position. Consider better opportunities.';
        }

        return insights;
      }
    }

    // Initialize global Ultimate Analysis Engine
    const ultimateEngine = new UltimateAnalysisEngine();
    window.ultimateEngine = ultimateEngine;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THE ORACLE - MULTI-AGENT ANALYSIS SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class OracleAnalyzer {
      constructor() {
        this.baseUrl = `${API_BASE_URL}/api/oracle`;
        this.eventSources = {};
      }

      async startAnalysis(symbol) {
        try {
          const response = await fetch(`${this.baseUrl}/analyze`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ symbol })
          });

          if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
          }

          const data = await response.json();
          return data;
        } catch (error) {
          console.error('The Oracle analysis error:', error);
          throw error;
        }
      }

      subscribeToProgress(symbol, onUpdate, onComplete, onError) {
        const eventSource = new EventSource(`${this.baseUrl}/progress/${symbol}`);
        this.eventSources[symbol] = eventSource;

        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            if (data.type === 'complete') {
              onComplete(data.result);
              eventSource.close();
              delete this.eventSources[symbol];
            } else if (data.type === 'error') {
              onError(data.error);
              eventSource.close();
              delete this.eventSources[symbol];
            } else if (data.type !== 'ping' && data.type !== 'connected') {
              onUpdate(data);
            }
          } catch (e) {
            console.error('Error parsing SSE data:', e);
          }
        };

        eventSource.onerror = (error) => {
          console.error('SSE connection error:', error);
          onError('Connection lost to analysis server');
          eventSource.close();
          delete this.eventSources[symbol];
        };

        return () => {
          eventSource.close();
          delete this.eventSources[symbol];
        };
      }

      async getCachedResult(symbol) {
        try {
          const response = await fetch(`${this.baseUrl}/result/${symbol}`);
          if (!response.ok) return null;
          const data = await response.json();
          return data.result;
        } catch (error) {
          return null;
        }
      }

      async listCachedAnalyses() {
        try {
          const response = await fetch(`${this.baseUrl}/cache`);
          if (!response.ok) return [];
          const data = await response.json();
          return data.cached_analyses || [];
        } catch (error) {
          return [];
        }
      }
    }

    // Initialize global Oracle analyzer
    const oracleAnalyzer = new OracleAnalyzer();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THE ORACLE ANALYSIS MODAL COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function OracleAnalysisModal({ stock, onClose }) {
      const [analysisState, setAnalysisState] = React.useState('idle'); // idle, loading, analyzing, complete, error
      const [progressUpdates, setProgressUpdates] = React.useState([]);
      const [result, setResult] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [cachedResult, setCachedResult] = React.useState(null);

      React.useEffect(() => {
        // Check for cached result on mount
        oracleAnalyzer.getCachedResult(stock.symbol).then(cached => {
          if (cached) {
            setCachedResult(cached);
          }
        });
      }, [stock.symbol]);

      const startAnalysis = async () => {
        try {
          setAnalysisState('loading');
          setProgressUpdates([]);
          setError(null);

          // Start the analysis
          const startResponse = await oracleAnalyzer.startAnalysis(stock.symbol);

          if (startResponse.status === 'cached') {
            setResult(startResponse.result);
            setAnalysisState('complete');
            return;
          }

          setAnalysisState('analyzing');

          // Subscribe to progress updates
          oracleAnalyzer.subscribeToProgress(
            stock.symbol,
            // onUpdate
            (update) => {
              setProgressUpdates(prev => [...prev, update]);
            },
            // onComplete
            (finalResult) => {
              setResult(finalResult);
              setAnalysisState('complete');
            },
            // onError
            (errorMsg) => {
              setError(errorMsg);
              setAnalysisState('error');
            }
          );

        } catch (err) {
          setError(err.message);
          setAnalysisState('error');
        }
      };

      const getAgentIcon = (agent) => {
        const icons = {
          'financial_news_analyst': 'ğŸ“°',
          'technical_analysis_specialist': 'ğŸ“Š',
          'fundamental_analysis_expert': 'ğŸ’°',
          'investment_opportunity_strategist': 'ğŸ¯',
          'system': 'âš™ï¸'
        };
        return icons[agent] || 'ğŸ¤–';
      };

      const getAgentName = (agent) => {
        const names = {
          'financial_news_analyst': 'Financial News Analyst',
          'technical_analysis_specialist': 'Technical Analysis Specialist',
          'fundamental_analysis_expert': 'Fundamental Analysis Expert',
          'investment_opportunity_strategist': 'Investment Opportunity Strategist',
          'system': 'System'
        };
        return names[agent] || agent;
      };

      return (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4 animate-fadeIn">
          <div className="bg-gradient-to-br from-slate-900 to-slate-800 rounded-2xl shadow-2xl border border-cyan-500/20 max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            {/* Header */}
            <div className="p-6 border-b border-slate-700/50 flex items-center justify-between bg-gradient-to-r from-slate-800 to-slate-900">
              <div>
                <h2 className="text-2xl font-bold text-white flex items-center gap-3">
                  <span className="text-3xl">ğŸ¤–</span>
                  Multi-Agent AI Analysis
                </h2>
                <p className="text-slate-400 mt-1">
                  {stock.symbol} - {stock.companyName || stock.symbol}
                </p>
              </div>
              <button
                onClick={onClose}
                className="text-slate-400 hover:text-white transition-colors p-2 hover:bg-slate-700/50 rounded-lg"
              >
                <i className="fas fa-times text-xl"></i>
              </button>
            </div>

            {/* Content */}
            <div className="flex-1 overflow-y-auto p-6 space-y-6">
              {/* Cached Result Notice */}
              {cachedResult && analysisState === 'idle' && (
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-xl p-4">
                  <div className="flex items-start gap-3">
                    <i className="fas fa-info-circle text-blue-400 text-xl mt-0.5"></i>
                    <div className="flex-1">
                      <h4 className="text-blue-300 font-semibold mb-1">Cached Analysis Available</h4>
                      <p className="text-slate-300 text-sm">
                        An analysis from {new Date(cachedResult.timestamp).toLocaleString()} is available.
                        You can view it or run a fresh analysis.
                      </p>
                      <button
                        onClick={() => {
                          setResult(cachedResult);
                          setAnalysisState('complete');
                        }}
                        className="mt-3 px-4 py-2 bg-blue-500/20 hover:bg-blue-500/30 border border-blue-500/40 rounded-lg text-blue-300 text-sm font-medium transition-colors"
                      >
                        View Cached Analysis
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {/* Description */}
              {analysisState === 'idle' && (
                <div className="space-y-4">
                  <p className="text-slate-300 leading-relaxed">
                    Launch a comprehensive multi-agent analysis powered by The Oracle. Four specialized AI agents will collaborate to analyze {stock.symbol}:
                  </p>

                  <div className="grid gap-3">
                    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50">
                      <div className="flex items-center gap-3 mb-2">
                        <span className="text-2xl">ğŸ“°</span>
                        <h4 className="text-white font-semibold">Financial News Analyst</h4>
                      </div>
                      <p className="text-slate-400 text-sm">
                        Monitors real-time news, sentiment, and market-moving events
                      </p>
                    </div>

                    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50">
                      <div className="flex items-center gap-3 mb-2">
                        <span className="text-2xl">ğŸ“Š</span>
                        <h4 className="text-white font-semibold">Technical Analysis Specialist</h4>
                      </div>
                      <p className="text-slate-400 text-sm">
                        Analyzes charts, patterns, indicators, and technical signals
                      </p>
                    </div>

                    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50">
                      <div className="flex items-center gap-3 mb-2">
                        <span className="text-2xl">ğŸ’°</span>
                        <h4 className="text-white font-semibold">Fundamental Analysis Expert</h4>
                      </div>
                      <p className="text-slate-400 text-sm">
                        Evaluates financials, valuation, earnings, and intrinsic value
                      </p>
                    </div>

                    <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50">
                      <div className="flex items-center gap-3 mb-2">
                        <span className="text-2xl">ğŸ¯</span>
                        <h4 className="text-white font-semibold">Investment Opportunity Strategist</h4>
                      </div>
                      <p className="text-slate-400 text-sm">
                        Synthesizes all insights into actionable investment recommendations
                      </p>
                    </div>
                  </div>

                  <div className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-4 mt-4">
                    <div className="flex items-start gap-3">
                      <i className="fas fa-clock text-amber-400 text-lg mt-0.5"></i>
                      <div>
                        <p className="text-amber-300 text-sm font-medium">Analysis Duration</p>
                        <p className="text-slate-400 text-sm mt-1">
                          This comprehensive analysis typically takes 2-5 minutes as agents research and collaborate.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Progress Updates */}
              {analysisState === 'analyzing' && (
                <div className="space-y-3">
                  <div className="flex items-center gap-3 mb-4">
                    <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-cyan-500"></div>
                    <p className="text-white font-medium">Analysis in Progress...</p>
                  </div>

                  <div className="space-y-2 max-h-96 overflow-y-auto">
                    {progressUpdates.map((update, idx) => (
                      <div
                        key={idx}
                        className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50 animate-slideInLeft"
                        style={{ animationDelay: `${idx * 0.1}s` }}
                      >
                        <div className="flex items-start gap-3">
                          <span className="text-2xl">{getAgentIcon(update.agent)}</span>
                          <div className="flex-1">
                            <div className="flex items-center justify-between mb-1">
                              <h4 className="text-white font-medium">{getAgentName(update.agent)}</h4>
                              <span className="text-xs text-slate-500">
                                {new Date(update.timestamp).toLocaleTimeString()}
                              </span>
                            </div>
                            <p className="text-slate-300 text-sm">{update.message}</p>
                            {update.status && (
                              <span className={`inline-block mt-2 px-2 py-1 rounded text-xs font-medium ${update.status === 'running' ? 'bg-blue-500/20 text-blue-300' :
                                update.status === 'complete' ? 'bg-green-500/20 text-green-300' :
                                  'bg-slate-500/20 text-slate-300'
                                }`}>
                                {update.status}
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Results */}
              {analysisState === 'complete' && result && (
                <div className="space-y-4">
                  <div className="bg-green-500/10 border border-green-500/30 rounded-xl p-4">
                    <div className="flex items-center gap-3">
                      <i className="fas fa-check-circle text-green-400 text-2xl"></i>
                      <div>
                        <h4 className="text-green-300 font-semibold">Analysis Complete!</h4>
                        <p className="text-slate-400 text-sm">
                          Generated at {new Date(result.timestamp).toLocaleString()}
                        </p>
                      </div>
                    </div>
                  </div>

                  {/* Individual Agent Outputs */}
                  {result.agents_output && result.agents_output.length > 0 && (
                    <div className="space-y-3">
                      <h3 className="text-white font-semibold text-lg">Agent Reports</h3>
                      {result.agents_output.map((agentOutput, idx) => (
                        <div key={idx} className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50">
                          <div className="flex items-start justify-between mb-3">
                            <h4 className="text-cyan-400 font-medium flex items-center gap-2">
                              <span>{getAgentIcon(agentOutput.agent)}</span>
                              {getAgentName(agentOutput.agent)}
                            </h4>
                            <div className="flex items-center gap-3">
                              <span className={`px-3 py-1 rounded-lg text-xs font-bold ${agentOutput.action === 'BUY' || agentOutput.action === 'STRONG_BUY' ? 'bg-green-500/20 text-green-400' :
                                agentOutput.action === 'SELL' || agentOutput.action === 'STRONG_SELL' ? 'bg-red-500/20 text-red-400' :
                                  'bg-yellow-500/20 text-yellow-400'
                                }`}>
                                {agentOutput.action}
                              </span>
                              <span className="text-cyan-400 font-semibold text-sm">
                                {agentOutput.confidence}% confidence
                              </span>
                            </div>
                          </div>

                          {agentOutput.target_price && (
                            <div className="grid grid-cols-2 gap-3 mb-3">
                              <div className="bg-slate-900/50 rounded p-2">
                                <div className="text-xs text-slate-500 mb-1">Target Price</div>
                                <div className="text-green-400 font-semibold">${agentOutput.target_price.toFixed(2)}</div>
                              </div>
                              {agentOutput.stop_loss && (
                                <div className="bg-slate-900/50 rounded p-2">
                                  <div className="text-xs text-slate-500 mb-1">Stop Loss</div>
                                  <div className="text-red-400 font-semibold">${agentOutput.stop_loss.toFixed(2)}</div>
                                </div>
                              )}
                            </div>
                          )}

                          {agentOutput.key_factors && agentOutput.key_factors.length > 0 && (
                            <div className="mb-3">
                              <div className="text-xs text-slate-500 mb-2">Key Factors:</div>
                              <div className="flex flex-wrap gap-2">
                                {agentOutput.key_factors.map((factor, fIdx) => (
                                  <span key={fIdx} className="px-2 py-1 bg-purple-500/20 text-purple-300 text-xs rounded">
                                    {factor}
                                  </span>
                                ))}
                              </div>
                            </div>
                          )}

                          <pre className="text-slate-300 text-sm whitespace-pre-wrap font-mono bg-slate-900/50 p-3 rounded overflow-x-auto">
                            {agentOutput.output}
                          </pre>
                        </div>
                      ))}
                    </div>
                  )}

                  {/* Full Analysis */}
                  <div className="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50">
                    <h4 className="text-white font-semibold mb-3">Complete Analysis</h4>
                    <pre className="text-slate-300 text-sm whitespace-pre-wrap font-mono bg-slate-900/50 p-4 rounded max-h-96 overflow-y-auto">
                      {result.raw_output || result.analysis}
                    </pre>
                  </div>
                </div>
              )}

              {/* Error State */}
              {analysisState === 'error' && (
                <div className="bg-red-500/10 border border-red-500/30 rounded-xl p-4">
                  <div className="flex items-start gap-3">
                    <i className="fas fa-exclamation-circle text-red-400 text-2xl"></i>
                    <div className="flex-1">
                      <h4 className="text-red-300 font-semibold mb-1">Analysis Failed</h4>
                      <p className="text-slate-300 text-sm mb-3">{error}</p>
                      <p className="text-slate-400 text-sm">
                        Make sure The Oracle backend is running.
                      </p>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Footer Actions */}
            <div className="p-6 border-t border-slate-700/50 bg-slate-800/50 flex items-center justify-between">
              <div>
                {analysisState === 'complete' && (
                  <button
                    onClick={() => {
                      setAnalysisState('idle');
                      setResult(null);
                      setProgressUpdates([]);
                    }}
                    className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white font-medium transition-colors"
                  >
                    <i className="fas fa-redo mr-2"></i>
                    Run New Analysis
                  </button>
                )}
              </div>
              <div className="flex items-center gap-3">
                <button
                  onClick={onClose}
                  className="px-6 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white font-medium transition-colors"
                >
                  Close
                </button>
                {analysisState === 'idle' && (
                  <button
                    onClick={startAnalysis}
                    className="px-6 py-2 bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-600 hover:to-blue-600 rounded-lg text-white font-semibold transition-all transform hover:scale-105 shadow-lg shadow-cyan-500/25"
                  >
                    <i className="fas fa-robot mr-2"></i>
                    Start Multi-Agent Analysis
                  </button>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AI TOURNAMENT COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function AITournamentModal({ onClose, watchlist = [], stocks = [] }) {
      const [activeTab, setActiveTab] = useState('overview');
      const [tournamentStatus, setTournamentStatus] = useState('idle'); // idle, running, completed, error
      const [tournamentResults, setTournamentResults] = useState(null);
      const [leaderboard, setLeaderboard] = useState([]);
      const [tournamentDays, setTournamentDays] = useState(7);
      const [activeTeams, setActiveTeams] = useState([1, 2, 3, 4]);
      const [logs, setLogs] = useState([]);
      const [currentDay, setCurrentDay] = useState(0);
      const [experimentId, setExperimentId] = useState(null);
      const eventSourceRef = useRef(null);
      const pollIntervalRef = useRef(null);

      // Use all available stocks instead of just watchlist
      const availableStocks = useMemo(() => {
        // If stocks prop is provided, use it; otherwise fallback to DEMO_STOCKS or watchlist
        const sourceStocks = stocks.length > 0 ? stocks : (typeof DEMO_STOCKS !== 'undefined' ? DEMO_STOCKS : []);
        return sourceStocks;
      }, [stocks]);

      const availableSymbols = useMemo(() => {
        return availableStocks.map(stock => stock.symbol || stock);
      }, [availableStocks]);

      const addLog = (message, type = 'info') => {
        const timestamp = new Date().toLocaleTimeString();
        setLogs(prev => [{
          time: timestamp,
          message,
          type
        }, ...prev].slice(0, 200));
      };

      const startTournament = async () => {
        if (tournamentStatus === 'running') return;

        setTournamentStatus('running');
        setLogs([]);
        setCurrentDay(0);
        setLeaderboard([]);

        try {
          // Use all available symbols instead of just watchlist
          const symbolsToUse = availableSymbols.length > 0 ? availableSymbols : ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA'];

          addLog(`ğŸš€ Starting tournament with ${symbolsToUse.length} stocks...`, 'info');

          const response = await fetch(`${API_BASE_URL}/api/tournament/start`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              days: tournamentDays,
              teams: activeTeams,
              watchlist: symbolsToUse, // Send all available stocks
              useAllStocks: true // Flag to indicate using all stocks
            })
          });

          if (response.ok) {
            const data = await response.json();
            setExperimentId(data.experimentId);
            connectToSSE(data.experimentId);
            addLog(`ğŸ† Tournament started on backend server with ${symbolsToUse.length} stocks`, 'success');
          } else {
            throw new Error('Failed to start tournament');
          }
        } catch (error) {
          addLog(`âŒ Failed to start: ${error.message}`, 'error');
          setTournamentStatus('error');
        }
      };

      const pollTournamentStatus = async (experimentId) => {
        // Clear any existing polling
        if (pollIntervalRef.current) {
          clearInterval(pollIntervalRef.current);
          pollIntervalRef.current = null;
        }

        // If experimentId is 'current', use the current status endpoint
        const statusUrl = experimentId === 'current'
          ? `${API_BASE_URL}/api/tournament/status/current`
          : `${API_BASE_URL}/api/tournament/status/${experimentId}`;

        pollIntervalRef.current = setInterval(async () => {
          // FIX: Don't poll when tab is hidden to prevent hanging
          if (document.hidden) {
            console.log('ğŸ“´ Skipping tournament poll - tab hidden');
            return;
          }

          try {
            const response = await fetch(statusUrl);
            if (response.ok) {
              const data = await response.json();

              if (data.status === 'running') {
                setCurrentDay(data.current_day || 0);
                if (data.logs && data.logs.length > 0) {
                  data.logs.forEach(log => {
                    if (!logs.some(l => l.message === log.message && l.time === log.time)) {
                      addLog(log.message, log.type || 'info');
                    }
                  });
                }
              } else if (data.status === 'completed') {
                if (pollIntervalRef.current) {
                  clearInterval(pollIntervalRef.current);
                  pollIntervalRef.current = null;
                }
                setTournamentStatus('completed');
                setTournamentResults(data.results);
                setLeaderboard(data.leaderboard || []);
                addLog('ğŸ† Tournament completed!', 'success');
              } else if (data.status === 'error') {
                if (pollIntervalRef.current) {
                  clearInterval(pollIntervalRef.current);
                  pollIntervalRef.current = null;
                }
                setTournamentStatus('error');
                addLog(`âŒ Tournament error: ${data.error}`, 'error');
              }
            }
          } catch (error) {
            console.error('Poll error:', error);
          }
        }, 3000);

        // FIX: Store timeout ID for proper cleanup
        const timeoutId = setTimeout(() => {
          if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
            pollIntervalRef.current = null;
          }
        }, 600000); // 10 minutes

        // Return cleanup function
        return () => {
          clearTimeout(timeoutId);
          if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
            pollIntervalRef.current = null;
          }
        };
      };

      // Handle close without stopping tournament
      const handleClose = () => {
        // Only close SSE connections, keep tournament running
        if (eventSourceRef.current) {
          eventSourceRef.current.leaderboard?.close();
          eventSourceRef.current.logs?.close();
          eventSourceRef.current = null;
        }

        onClose();
      };

      const getTeamName = (teamId) => {
        const names = {
          1: 'Team Alpha (Claude-3-Sonnet)',
          2: 'Team Beta (Kimi-K2)',
          3: 'Team Gamma (DeepSeek-V3)',
          4: 'Team Delta (Gemini-Pro)'
        };
        return names[teamId] || `Team ${teamId}`;
      };

      const getRankEmoji = (rank) => {
        if (rank === 1) return 'ğŸ¥‡';
        if (rank === 2) return 'ğŸ¥ˆ';
        if (rank === 3) return 'ğŸ¥‰';
        return `#${rank}`;
      };

      const loadTournamentResults = async () => {
        try {
          const response = await fetch(`${API_BASE_URL}/api/tournament/results`);
          if (response.ok) {
            const data = await response.json();
            if (data.results) {
              setTournamentResults(data.results);
              setLeaderboard(data.leaderboard || []);
              setTournamentStatus('completed');
            }
          }
        } catch (error) {
          console.error('Error loading results:', error);
        }
      };

      // Check for running tournament on mount
      useEffect(() => {
        checkForRunningTournament();

        return () => {
          // Clean up SSE connections and polling intervals on unmount
          if (eventSourceRef.current) {
            eventSourceRef.current.leaderboard?.close();
            eventSourceRef.current.logs?.close();
          }
          if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
            pollIntervalRef.current = null;
          }
        };
      }, []);

      const checkForRunningTournament = async () => {
        try {
          const response = await fetch(`${API_BASE_URL}/api/tournament/results`);
          if (response.ok) {
            const data = await response.json();
            if (data.results && data.results.status === 'running') {
              setExperimentId(data.results.experimentId);
              setTournamentStatus('running');
              setCurrentDay(data.results.currentDay);
              setTournamentDays(data.results.config.days);
              connectToSSE(data.results.experimentId);
              addLog('ğŸ”„ Reconnected to running tournament', 'success');
            }
          }
        } catch (error) {
          console.log('No running tournament found');
        }
      };

      const connectToSSE = (expId) => {
        // Close existing connections
        if (eventSourceRef.current) {
          eventSourceRef.current.leaderboard?.close();
          eventSourceRef.current.logs?.close();
        }

        // FIX: Don't create SSE when tab is hidden
        if (document.hidden) {
          console.log('ğŸ“´ Deferring SSE connection - tab hidden');
          return;
        }

        // Connect to leaderboard updates
        const leaderboardSSE = new EventSource(
          `${API_BASE_URL}/api/tournament/sse/leaderboard/${expId}`
        );

        leaderboardSSE.onmessage = (event) => {
          // Skip processing when tab is hidden to reduce overhead
          if (document.hidden) return;

          const data = JSON.parse(event.data);
          if (data.leaderboard) {
            setLeaderboard(data.leaderboard);
          }
          if (data.status === 'completed') {
            setTournamentStatus('completed');
            setTournamentResults(data);
            leaderboardSSE.close();
          }
        };

        leaderboardSSE.onerror = (error) => {
          console.error('Leaderboard SSE error:', error);
          addLog('âš ï¸ Lost connection to leaderboard updates', 'warning');
          // Auto-reconnect after 5 seconds if still needed
          setTimeout(() => {
            if (tournamentStatus === 'running' && !document.hidden) {
              console.log('ğŸ”„ Reconnecting to SSE...');
              connectToSSE(expId);
            }
          }, 5000);
        };

        // Connect to logs
        const logsSSE = new EventSource(
          `${API_BASE_URL}/api/tournament/sse/logs/${expId}`
        );

        logsSSE.onmessage = (event) => {
          // Skip processing when tab is hidden
          if (document.hidden) return;

          const data = JSON.parse(event.data);
          if (data.message) {
            addLog(data.message, data.type);
          }
        };

        logsSSE.onerror = (error) => {
          console.error('Logs SSE error:', error);
        };

        eventSourceRef.current = { leaderboard: leaderboardSSE, logs: logsSSE };
      };

      const checkRunningTournament = async () => {
        try {
          const response = await fetch(`${API_BASE_URL}/api/tournament/status/current`);
          if (response.ok) {
            const data = await response.json();
            if (data.status === 'running') {
              // Tournament is running on server - restore UI state
              console.log('ğŸ”„ Tournament detected running on server - restoring UI state');
              setTournamentStatus('running');
              addLog('ğŸ”„ Tournament is running in background - resuming monitoring', 'info');

              // Try to get the actual experiment ID from the status endpoint
              // If we have an experiment_id, use it; otherwise poll the current status
              if (data.experiment_id && data.experiment_id !== 'tournament_undefined') {
                console.log('ğŸ“‹ Resuming polling for experiment:', data.experiment_id);
                pollTournamentStatus(data.experiment_id);
              } else {
                // Poll current status endpoint periodically to check for updates
                console.log('ğŸ“‹ Polling current tournament status');
                const pollCurrentStatus = setInterval(async () => {
                  try {
                    const statusResponse = await fetch(`${API_BASE_URL}/api/tournament/status/current`);
                    if (statusResponse.ok) {
                      const statusData = await statusResponse.json();
                      if (statusData.status === 'running') {
                        // Tournament still running - update UI
                        setTournamentStatus('running');
                        if (statusData.current_day) {
                          setCurrentDay(statusData.current_day);
                        }
                      } else {
                        // Tournament completed or stopped
                        console.log('ğŸ“‹ Tournament completed or stopped');
                        clearInterval(pollCurrentStatus);
                        setTournamentStatus('idle');
                        loadTournamentResults();
                      }
                    }
                  } catch (err) {
                    console.error('Status poll error:', err);
                  }
                }, 5000);

                // Store this interval so we can clear it later
                pollIntervalRef.current = pollCurrentStatus;
              }
            } else {
              // No tournament running - check if we have stale state
              if (tournamentStatus === 'running') {
                console.log('ğŸ“‹ UI shows running but server says idle - updating state');
                setTournamentStatus('idle');
                loadTournamentResults();
              }
            }
          }
        } catch (error) {
          // Tournament might not be running, that's okay
          console.log('No running tournament found:', error);
          // If we have stale running state, clear it
          if (tournamentStatus === 'running') {
            console.log('ğŸ“‹ Clearing stale running state');
            setTournamentStatus('idle');
          }
        }
      };

      useEffect(() => {
        // Always check for running tournament when modal opens
        checkRunningTournament();

        return () => {
          // CRITICAL FIX: Cleanup ALL resources when modal closes
          console.log('ğŸ“‹ Modal unmounting - cleaning up resources');

          // Clear polling intervals
          if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
            pollIntervalRef.current = null;
          }

          // CRITICAL: Close EventSource connections to prevent memory leaks
          if (eventSourceRef.current) {
            if (eventSourceRef.current.leaderboard) {
              eventSourceRef.current.leaderboard.close();
              console.log('ğŸ”Œ Closed leaderboard SSE connection');
            }
            if (eventSourceRef.current.logs) {
              eventSourceRef.current.logs.close();
              console.log('ğŸ”Œ Closed logs SSE connection');
            }
            eventSourceRef.current = null;
          }

          // IMPORTANT: DO NOT call stopTournament() here
          // The tournament continues running on the server independently
        };
      }, []);

      return (
        <div className="modal-overlay" onClick={handleClose}>
          <div className="glass-elevated rounded-2xl p-6 max-w-7xl w-full mx-4 my-8 max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
            {/* Header */}
            <div className="flex items-start justify-between mb-6 pb-4 border-b border-slate-700">
              <div>
                <h2 className="text-3xl font-bold bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent">
                  ğŸ† AI Trading Tournament
                </h2>
                <p className="text-slate-400 text-sm mt-1">Multi-AI Trading Competition</p>
              </div>
              <button onClick={handleClose} className="text-slate-400 hover:text-white text-2xl px-2">âœ•</button>
            </div>

            {/* Tabs */}
            <div className="flex border-b border-slate-700 bg-slate-800/50">
              {['overview', 'leaderboard', 'logs', 'settings'].map(tab => (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab)}
                  className={`px-6 py-3 font-medium capitalize transition ${activeTab === tab
                    ? 'text-purple-400 border-b-2 border-purple-400 bg-slate-700/50'
                    : 'text-slate-400 hover:text-white hover:bg-slate-700/30'
                    }`}>
                  {tab}
                </button>
              ))}
            </div>

            {/* Tab Content */}
            <div className="space-y-6">
              {activeTab === 'overview' && (
                <div>
                  {/* Tournament Controls */}
                  <div className="bg-slate-800/50 rounded-lg p-6 mb-6 border border-slate-700">
                    <h3 className="text-xl font-bold text-white mb-4">Tournament Configuration</h3>

                    <div className="grid grid-cols-2 gap-4 mb-4">
                      <div>
                        <label className="block text-sm text-slate-400 mb-2">Tournament Days</label>
                        <input
                          type="number"
                          value={tournamentDays}
                          onChange={(e) => setTournamentDays(parseInt(e.target.value) || 7)}
                          min="1"
                          max="30"
                          className="w-full bg-slate-900 border border-slate-600 rounded-lg px-3 py-2 text-white"
                          disabled={tournamentStatus === 'running'}
                        />
                      </div>
                      <div>
                        <label className="block text-sm text-slate-400 mb-2">Active Teams</label>
                        <div className="flex gap-2 flex-wrap">
                          {[1, 2, 3, 4].map(team => (
                            <label key={team} className="flex items-center gap-2 cursor-pointer">
                              <input
                                type="checkbox"
                                checked={activeTeams.includes(team)}
                                onChange={(e) => {
                                  if (e.target.checked) {
                                    setActiveTeams([...activeTeams, team]);
                                  } else {
                                    setActiveTeams(activeTeams.filter(t => t !== team));
                                  }
                                }}
                                disabled={tournamentStatus === 'running'}
                                className="w-4 h-4"
                              />
                              <span className="text-sm text-slate-300">Team {team}</span>
                            </label>
                          ))}
                        </div>
                      </div>
                    </div>

                    <div className="mb-4">
                      <label className="block text-sm text-slate-400 mb-2">Available Stocks ({availableSymbols.length} total)</label>
                      <div className="bg-slate-900 rounded-lg p-3 text-sm text-slate-300 max-h-32 overflow-y-auto">
                        {availableSymbols.length > 0 ? availableSymbols.join(', ') : 'No stocks available'}
                      </div>
                      <p className="text-xs text-slate-500 mt-2">AI teams will select from all {availableSymbols.length} stocks in the application</p>
                    </div>

                    <div className="flex gap-3">
                      {tournamentStatus === 'idle' && (
                        <button
                          onClick={startTournament}
                          className="px-8 py-3 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-lg font-bold hover:shadow-lg hover:shadow-purple-500/50 transition"
                        >
                          <i className="fas fa-play mr-2"></i>
                          Start Tournament ({availableSymbols.length} Stocks)
                        </button>
                      )}
                      {tournamentStatus === 'running' && (
                        <div className="flex items-center gap-3">
                          <div className="flex items-center gap-2 px-4 py-3 bg-cyan-500/10 border border-cyan-500/30 rounded-lg">
                            <i className="fas fa-spinner animate-spin text-cyan-400"></i>
                            <span className="text-cyan-400 font-semibold">
                              Day {currentDay} / {tournamentDays}
                            </span>
                          </div>
                          <div className="text-xs text-slate-500">
                            Tournament runs in background
                          </div>
                        </div>
                      )}
                      {tournamentStatus === 'completed' && (
                        <button
                          onClick={loadTournamentResults}
                          className="px-6 py-3 bg-green-600 hover:bg-green-500 text-white rounded-lg font-semibold flex items-center gap-2"
                        >
                          <i className="fas fa-sync"></i>
                          Refresh Results
                        </button>
                      )}
                    </div>
                  </div>

                  {/* Tournament Status */}
                  {tournamentResults && (
                    <div className="bg-slate-800/50 rounded-lg p-6 border border-slate-700">
                      <h3 className="text-xl font-bold text-white mb-4">Tournament Results</h3>
                      <div className="grid grid-cols-3 gap-4">
                        <div className="bg-slate-900/50 rounded-lg p-4 text-center">
                          <div className="text-sm text-slate-400 mb-1">Total Days</div>
                          <div className="text-2xl font-bold text-cyan-400">{tournamentResults.total_days || tournamentDays}</div>
                        </div>
                        <div className="bg-slate-900/50 rounded-lg p-4 text-center">
                          <div className="text-sm text-slate-400 mb-1">Total Trades</div>
                          <div className="text-2xl font-bold text-green-400">{tournamentResults.total_trades || 0}</div>
                        </div>
                        <div className="bg-slate-900/50 rounded-lg p-4 text-center">
                          <div className="text-sm text-slate-400 mb-1">Best Return</div>
                          <div className="text-2xl font-bold text-purple-400">
                            {tournamentResults.best_return ? `${tournamentResults.best_return.toFixed(2)}%` : 'N/A'}
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              )}

              {activeTab === 'leaderboard' && (
                <div>
                  {leaderboard.length > 0 ? (
                    <div className="space-y-3">
                      {leaderboard.map((team, idx) => (
                        <div
                          key={team.teamId}
                          className={`glass-card p-6 rounded-xl border transition ${idx === 0 ? 'border-yellow-500/50 bg-yellow-500/5' :
                            idx === 1 ? 'border-slate-400/50 bg-slate-400/5' :
                              idx === 2 ? 'border-orange-500/50 bg-orange-500/5' :
                                'border-slate-700'
                            }`}>
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-4">
                              <div className="text-3xl">{getRankEmoji(team.rank || idx + 1)}</div>
                              <div>
                                <h4 className="text-lg font-bold text-white">{team.name || getTeamName(team.teamId)}</h4>
                                <p className="text-sm text-slate-400">{team.model || 'Unknown Model'}</p>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className={`text-2xl font-bold ${team.totalReturn > 0 ? 'text-green-400' : 'text-red-400'
                                }`}>
                                {team.totalReturn > 0 ? '+' : ''}{team.totalReturn?.toFixed(2)}%
                              </div>
                              <div className="text-sm text-slate-400">
                                ${team.portfolioValue?.toLocaleString()}
                              </div>
                            </div>
                          </div>

                          {/* Mini chart of returns */}
                          {team.returns && team.returns.length > 0 && (
                            <div className="mt-4 flex items-end gap-1 h-12">
                              {team.returns.map((ret, i) => (
                                <div
                                  key={i}
                                  className={`flex-1 rounded-t ${ret > 0 ? 'bg-green-500' : 'bg-red-500'}`}
                                  style={{ height: `${Math.abs(ret) * 10}px`, minHeight: '2px' }}
                                  title={`Day ${i + 1}: ${ret.toFixed(2)}%`}
                                ></div>
                              ))}
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-20">
                      <i className="fas fa-trophy text-6xl text-slate-700 mb-4"></i>
                      <p className="text-slate-400">No tournament results yet</p>
                      <p className="text-sm text-slate-500 mt-2">Start a tournament to see the leaderboard</p>
                    </div>
                  )}
                </div>
              )}

              {activeTab === 'logs' && (
                <div className="space-y-2">
                  {logs.length === 0 ? (
                    <div className="text-center py-12">
                      <i className="fas fa-file-alt text-6xl text-slate-600 mb-4"></i>
                      <p className="text-slate-400">No logs yet</p>
                    </div>
                  ) : (
                    <div className="glass-card p-4 rounded-xl border border-slate-700 max-h-96 overflow-y-auto">
                      {logs.map((log, idx) => (
                        <div
                          key={idx}
                          className={`py-2 px-3 rounded mb-1 font-mono text-sm ${log.type === 'error' ? 'bg-red-500/10 text-red-400' :
                            log.type === 'success' ? 'bg-green-500/10 text-green-400' :
                              log.type === 'warning' ? 'bg-yellow-500/10 text-yellow-400' :
                                'bg-slate-700/30 text-slate-300'
                            }`}>
                          <span className="text-slate-500 mr-2">[{log.time}]</span>
                          {log.message}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {activeTab === 'settings' && (
                <div className="space-y-6">
                  <div className="glass-card p-6 rounded-xl border border-slate-700">
                    <h3 className="text-lg font-bold text-white mb-4">Tournament Configuration</h3>

                    <div className="space-y-4">
                      <div>
                        <label className="block text-slate-300 mb-2">Duration (days)</label>
                        <input
                          type="number"
                          min="1"
                          max="30"
                          value={tournamentDays}
                          onChange={(e) => setTournamentDays(parseInt(e.target.value))}
                          disabled={tournamentStatus === 'running'}
                          className="w-full bg-slate-700 text-white px-4 py-2 rounded-lg border border-slate-600 focus:border-purple-500 focus:outline-none disabled:opacity-50"
                        />
                      </div>

                      <div>
                        <label className="block text-slate-300 mb-2">Active Teams</label>
                        <div className="grid grid-cols-2 gap-2">
                          {[1, 2, 3, 4].map(teamId => (
                            <label
                              key={teamId}
                              className={`flex items-center gap-2 p-3 rounded-lg border cursor-pointer transition ${activeTeams.includes(teamId)
                                ? 'bg-purple-500/20 border-purple-500'
                                : 'bg-slate-700/30 border-slate-600'
                                } ${tournamentStatus === 'running' ? 'opacity-50 cursor-not-allowed' : ''}`}>
                              <input
                                type="checkbox"
                                checked={activeTeams.includes(teamId)}
                                onChange={(e) => {
                                  if (e.target.checked) {
                                    setActiveTeams([...activeTeams, teamId]);
                                  } else {
                                    setActiveTeams(activeTeams.filter(id => id !== teamId));
                                  }
                                }}
                                disabled={tournamentStatus === 'running'}
                                className="form-checkbox text-purple-500"
                              />
                              <span className="text-white text-sm">{getTeamName(teamId)}</span>
                            </label>
                          ))}
                        </div>
                      </div>

                      <div>
                        <label className="block text-slate-300 mb-2">
                          Available Stocks ({availableSymbols.length} symbols)
                        </label>
                        <div className="bg-slate-700/30 p-3 rounded-lg border border-slate-600 max-h-32 overflow-y-auto">
                          {availableSymbols.length > 0 ? (
                            <div className="flex flex-wrap gap-2">
                              {availableSymbols.map(symbol => (
                                <span key={symbol} className="px-2 py-1 bg-cyan-500/20 text-cyan-300 rounded text-sm">
                                  {symbol}
                                </span>
                              ))}
                            </div>
                          ) : (
                            <p className="text-slate-500 text-sm">Loading available stocks...</p>
                          )}
                        </div>
                        <p className="text-xs text-slate-500 mt-2">
                          Tournament will analyze all {availableSymbols.length} available stocks
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MARKET CRASH SIMULATOR COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


    // MARKET CRASH SIMULATOR COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function MarketCrashSimulator({ holdings, totalValue }) {
      const [selectedScenario, setSelectedScenario] = useState('2008 Financial Crisis');
      const [showDetails, setShowDetails] = useState(false);

      const crashResult = simulateMarketCrash(holdings, selectedScenario);

      if (!crashResult) return null;

      return (
        <div className="space-y-4">
          <div className="flex items-center justify-between mb-3">
            <p className="text-sm text-slate-400">
              See how your portfolio would handle historical market crashes
            </p>
            <select
              value={selectedScenario}
              onChange={(e) => setSelectedScenario(e.target.value)}
              className="px-3 py-1.5 bg-slate-800 border border-slate-700 rounded text-white text-sm focus:outline-none focus:border-purple-500"
            >
              {Object.keys(CRASH_SCENARIOS).map(scenario => (
                <option key={scenario} value={scenario}>{scenario}</option>
              ))}
            </select>
          </div>

          <div className="grid grid-cols-3 gap-4">
            <div className="glass-card p-4 rounded-lg text-center">
              <div className="text-xs text-slate-500 mb-2">Portfolio Loss</div>
              <div className="text-2xl font-bold text-red-400">
                ${crashResult.lossUsd.toLocaleString('en-US', { maximumFractionDigits: 0 })}
              </div>
              <div className="text-xs text-slate-500 mt-1">
                -{crashResult.lossPct}%
              </div>
            </div>
            <div className="glass-card p-4 rounded-lg text-center">
              <div className="text-xs text-slate-500 mb-2">Timeline</div>
              <div className="text-2xl font-bold text-white">
                {crashResult.weeks} {crashResult.weeks === 1 ? 'week' : 'weeks'}
              </div>
              <div className="text-xs text-slate-500 mt-1">
                ~${crashResult.perWeek.toLocaleString('en-US', { maximumFractionDigits: 0 })}/week
              </div>
            </div>
            <div className="glass-card p-4 rounded-lg text-center">
              <div className="text-xs text-slate-500 mb-2">Value After Crash</div>
              <div className="text-2xl font-bold text-yellow-400">
                ${crashResult.finalValue.toLocaleString('en-US', { maximumFractionDigits: 0 })}
              </div>
              <div className="text-xs text-slate-500 mt-1">
                {crashResult.percentRemaining.toFixed(0)}% remaining
              </div>
            </div>
          </div>

          {/* Visual indicator */}
          <div className="glass-card p-4 rounded-lg">
            <div className="flex justify-between items-center mb-2">
              <span className="text-xs text-slate-400">Portfolio Drawdown</span>
              <span className="text-xs font-bold text-red-400">-{crashResult.lossPct}%</span>
            </div>
            <div className="w-full bg-slate-700 rounded-full h-3">
              <div
                className="h-full bg-gradient-to-r from-green-500 to-red-500 rounded-full transition-all"
                style={{ width: `${crashResult.percentRemaining}%` }}
              ></div>
            </div>
            <div className="flex justify-between text-xs text-slate-500 mt-1">
              <span>$0</span>
              <span>${totalValue.toLocaleString('en-US', { maximumFractionDigits: 0 })}</span>
            </div>
          </div>

          <div className="p-3 bg-slate-800/40 border border-slate-700/50 rounded-lg">
            <div className="flex items-start gap-2">
              <i className="fas fa-info-circle text-blue-400 text-sm mt-0.5"></i>
              <div className="text-xs text-slate-300 leading-relaxed">
                <strong>Historical scenario</strong> â€“ not a prediction. Past crashes help you understand your risk tolerance.
                Would you panic-sell, hold steady, or see it as a buying opportunity?
              </div>
            </div>
          </div>

          <button
            onClick={() => setShowDetails(!showDetails)}
            className="text-sm text-purple-400 hover:text-purple-300 font-semibold flex items-center gap-2 transition"
          >
            {showDetails ? 'â–¼' : 'â–¶'} {showDetails ? 'Hide' : 'Show'} Historical Context
          </button>

          {showDetails && (
            <div className="glass-card p-4 rounded-lg space-y-2 text-xs text-slate-300">
              <div className="font-semibold text-white mb-2">{selectedScenario} Details:</div>
              {selectedScenario === '2008 Financial Crisis' && (
                <p>The S&P 500 fell 57% from October 2007 to March 2009 during the subprime mortgage crisis. Recovery took 4+ years.</p>
              )}
              {selectedScenario === '2020 COVID Crash' && (
                <p>Markets dropped 34% in just 5 weeks (Feb-Mar 2020) due to pandemic fears. Recovery was V-shaped, taking only 5 months.</p>
              )}
              {selectedScenario === '2000 Dot-com Bust' && (
                <p>The tech-heavy NASDAQ fell 78% from March 2000 to October 2002. Full recovery took 15 years.</p>
              )}
              {selectedScenario === '1987 Black Monday' && (
                <p>Markets crashed 22.6% in a single day (Oct 19, 1987) due to program trading and panic. Recovery took 2 years.</p>
              )}
            </div>
          )}
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STOCK GRADING SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function calculateStockGrade(stock) {
      let score = 0, maxScore = 0;
      const criteria = [];

      // Valuation (25 pts)
      if (stock.pe) {
        maxScore += 10;
        if (stock.pe < 15) { score += 10; criteria.push({ name: 'P/E Ratio', grade: 'A', reason: 'Attractive valuation (P/E < 15)' }); }
        else if (stock.pe < 25) { score += 7; criteria.push({ name: 'P/E Ratio', grade: 'B', reason: 'Fair valuation (P/E 15-25)' }); }
        else if (stock.pe < 35) { score += 4; criteria.push({ name: 'P/E Ratio', grade: 'C', reason: 'Expensive (P/E 25-35)' }); }
        else { score += 2; criteria.push({ name: 'P/E Ratio', grade: 'D', reason: 'Very expensive (P/E >35)' }); }
      }
      if (stock.priceToBook) {
        maxScore += 8;
        if (stock.priceToBook < 1.5) { score += 8; criteria.push({ name: 'P/B Ratio', grade: 'A', reason: 'Trading below book value' }); }
        else if (stock.priceToBook < 3) { score += 6; criteria.push({ name: 'P/B Ratio', grade: 'B', reason: 'Reasonable P/B ratio' }); }
        else { score += 3; criteria.push({ name: 'P/B Ratio', grade: 'C', reason: 'High P/B ratio' }); }
      }

      // Growth (25 pts)
      if (stock.revenueGrowth) {
        maxScore += 10;
        if (stock.revenueGrowth > 20) { score += 10; criteria.push({ name: 'Revenue Growth', grade: 'A', reason: 'Strong growth (>20%)' }); }
        else if (stock.revenueGrowth > 10) { score += 7; criteria.push({ name: 'Revenue Growth', grade: 'B', reason: 'Solid growth (10-20%)' }); }
        else if (stock.revenueGrowth > 0) { score += 4; criteria.push({ name: 'Revenue Growth', grade: 'C', reason: 'Slow growth (0-10%)' }); }
        else { score += 1; criteria.push({ name: 'Revenue Growth', grade: 'F', reason: 'Declining revenue' }); }
      }
      if (stock.epsGrowth) {
        maxScore += 10;
        if (stock.epsGrowth > 20) { score += 10; criteria.push({ name: 'EPS Growth', grade: 'A', reason: 'Excellent earnings (>20%)' }); }
        else if (stock.epsGrowth > 10) { score += 7; criteria.push({ name: 'EPS Growth', grade: 'B', reason: 'Good earnings (10-20%)' }); }
        else if (stock.epsGrowth > 0) { score += 4; criteria.push({ name: 'EPS Growth', grade: 'C', reason: 'Modest growth (0-10%)' }); }
      }
      if (stock.grossMargin) {
        maxScore += 5;
        if (stock.grossMargin > 60) { score += 5; criteria.push({ name: 'Gross Margin', grade: 'A', reason: 'Exceptional margins (>60%)' }); }
        else if (stock.grossMargin > 40) { score += 3; criteria.push({ name: 'Gross Margin', grade: 'B', reason: 'Strong margins (40-60%)' }); }
        else if (stock.grossMargin > 20) { score += 2; criteria.push({ name: 'Gross Margin', grade: 'C', reason: 'Fair margins (20-40%)' }); }
      }

      // Financial Health (25 pts)
      if (stock.debtToEquity !== undefined) {
        maxScore += 10;
        if (stock.debtToEquity < 0.5) { score += 10; criteria.push({ name: 'Debt/Equity', grade: 'A', reason: 'Very low debt (<0.5)' }); }
        else if (stock.debtToEquity < 1.0) { score += 7; criteria.push({ name: 'Debt/Equity', grade: 'B', reason: 'Conservative debt (0.5-1.0)' }); }
        else if (stock.debtToEquity < 2.0) { score += 4; criteria.push({ name: 'Debt/Equity', grade: 'C', reason: 'Moderate debt (1.0-2.0)' }); }
        else { score += 2; criteria.push({ name: 'Debt/Equity', grade: 'D', reason: 'High debt (>2.0)' }); }
      }
      if (stock.currentRatio) {
        maxScore += 8;
        if (stock.currentRatio > 2.0) { score += 8; criteria.push({ name: 'Current Ratio', grade: 'A', reason: 'Strong liquidity (>2.0)' }); }
        else if (stock.currentRatio > 1.5) { score += 6; criteria.push({ name: 'Current Ratio', grade: 'B', reason: 'Adequate liquidity (1.5-2.0)' }); }
        else if (stock.currentRatio > 1.0) { score += 3; criteria.push({ name: 'Current Ratio', grade: 'C', reason: 'Tight liquidity (1.0-1.5)' }); }
      }
      if (stock.piotroskiScore) {
        maxScore += 7;
        if (stock.piotroskiScore >= 7) { score += 7; criteria.push({ name: 'Piotroski Score', grade: 'A', reason: 'Excellent financial health (7-9)' }); }
        else if (stock.piotroskiScore >= 5) { score += 5; criteria.push({ name: 'Piotroski Score', grade: 'B', reason: 'Good health (5-6)' }); }
        else if (stock.piotroskiScore >= 3) { score += 3; criteria.push({ name: 'Piotroski Score', grade: 'C', reason: 'Fair health (3-4)' }); }
        else { score += 1; criteria.push({ name: 'Piotroski Score', grade: 'D', reason: 'Weak health (<3)' }); }
      }

      // Profitability (15 pts)
      if (stock.roe) {
        maxScore += 8;
        if (stock.roe > 20) { score += 8; criteria.push({ name: 'ROE', grade: 'A', reason: 'Excellent return (>20%)' }); }
        else if (stock.roe > 15) { score += 6; criteria.push({ name: 'ROE', grade: 'B', reason: 'Strong return (15-20%)' }); }
        else if (stock.roe > 10) { score += 4; criteria.push({ name: 'ROE', grade: 'C', reason: 'Fair return (10-15%)' }); }
        else { score += 2; criteria.push({ name: 'ROE', grade: 'D', reason: 'Weak return (<10%)' }); }
      }
      if (stock.roic) {
        maxScore += 7;
        if (stock.roic > 15) { score += 7; criteria.push({ name: 'ROIC', grade: 'A', reason: 'Excellent capital efficiency (>15%)' }); }
        else if (stock.roic > 10) { score += 5; criteria.push({ name: 'ROIC', grade: 'B', reason: 'Good efficiency (10-15%)' }); }
        else if (stock.roic > 5) { score += 3; criteria.push({ name: 'ROIC', grade: 'C', reason: 'Fair efficiency (5-10%)' }); }
      }

      // Technical (10 pts)
      if (stock.rsi) {
        maxScore += 5;
        if (stock.rsi >= 40 && stock.rsi <= 60) { score += 5; criteria.push({ name: 'RSI', grade: 'A', reason: 'Neutral momentum' }); }
        else if (stock.rsi < 30) { score += 4; criteria.push({ name: 'RSI', grade: 'B', reason: 'Oversold - potential bounce' }); }
        else if (stock.rsi > 70) { score += 2; criteria.push({ name: 'RSI', grade: 'C', reason: 'Overbought - caution' }); }
      }
      if (stock.beta !== undefined) {
        maxScore += 5;
        if (stock.beta >= 0.8 && stock.beta <= 1.2) { score += 5; criteria.push({ name: 'Beta', grade: 'A', reason: 'Market-like volatility' }); }
        else if (stock.beta < 0.8) { score += 4; criteria.push({ name: 'Beta', grade: 'B', reason: 'Lower volatility' }); }
        else if (stock.beta < 1.5) { score += 3; criteria.push({ name: 'Beta', grade: 'C', reason: 'Moderate volatility' }); }
        else { score += 2; criteria.push({ name: 'Beta', grade: 'D', reason: 'High volatility' }); }
      }

      // Calculate final grade
      const percentage = maxScore > 0 ? (score / maxScore) * 100 : 0;
      let letterGrade = 'F';
      if (percentage >= 90) letterGrade = 'A';
      else if (percentage >= 80) letterGrade = 'B';
      else if (percentage >= 70) letterGrade = 'C';
      else if (percentage >= 60) letterGrade = 'D';

      return {
        letterGrade,
        percentage: Math.round(percentage),
        score,
        maxScore,
        criteria: criteria.sort((a, b) => {
          const order = { 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'F': 5 };
          return order[a.grade] - order[b.grade];
        })
      };
    }

    // === FINANCIAL GLOSSARY FOR "EXPLAIN THIS" ===
    const FINANCIAL_EXPLANATIONS = {
      pe: {
        label: 'P/E Ratio',
        plain: 'Price-to-Earnings: How much you pay for $1 of earnings. <15 = Undervalued, 15-25 = Fair, >25 = Growth priced in.',
        analogy: 'Like paying $25 for a pizza that gives you $1 worth of satisfaction per year.'
      },
      roe: {
        label: 'ROE (Return on Equity)',
        plain: 'Profit generated from shareholder equity. >15% = strong, >20% = excellent.',
        analogy: 'Like getting $1.20 back for every $1 you invest in the business.'
      },
      roic: {
        label: 'ROIC (Return on Invested Capital)',
        plain: 'How efficiently a company uses its capital to generate profits. >15% is strong.',
        analogy: 'Like a vending machine that returns $1.20 for every $1 you put in.'
      },
      evToEbitda: {
        label: 'EV/EBITDA',
        plain: 'Enterprise Value vs. Earnings Before Interest, Taxes, Depreciation & Amortization. <10 = cheap, >15 = expensive.',
        analogy: 'Like comparing the total price of a business to its core operating cash flow.'
      },
      piotroskiScore: {
        label: 'Piotroski Score',
        plain: 'A 9-point checklist for financial health (profitability, leverage, efficiency). 7-9 = strong, <4 = weak.',
        analogy: 'Like a financial health checkup for stocks.'
      },
      debtToEquity: {
        label: 'Debt-to-Equity',
        plain: 'How much debt a company uses relative to shareholder equity. <0.5 = conservative, >1.5 = risky.',
        analogy: 'Like a home: $200K house with $50K down (low risk) vs. $200K with $180K loan (high risk).'
      },
      rsi: {
        label: 'RSI (Relative Strength Index)',
        plain: 'Momentum indicator: <30 = oversold (potential buy), >70 = overbought (potential sell).',
        analogy: "Like a car's speedometer: too fast = risk of crash, too slow = opportunity to accelerate."
      },
      revenueGrowth: {
        label: 'Revenue Growth',
        plain: 'Year-over-year revenue change. >20% = high growth, <0% = decline.',
        analogy: 'Like a store that sold 100 units last year and 125 this year â€” business is expanding.'
      },
      grossMargin: {
        label: 'Gross Margin',
        plain: 'Profit after cost of goods sold. >40% = excellent, 20-40% = good.',
        analogy: 'If you sell a $10 product for $15, your gross margin is 33% â€” $5 profit before other costs.'
      },
      beta: {
        label: 'Beta',
        plain: 'Volatility relative to market. <1 = less volatile, >1 = more volatile than S&P 500.',
        analogy: 'Like comparing a steady sedan (beta 0.8) vs. a sports car (beta 1.5).'
      },
      dividendYield: {
        label: 'Dividend Yield',
        plain: 'Annual dividend as % of stock price. >3% = income stock, 1-3% = balanced.',
        analogy: 'Like earning $3 per year for every $100 invested in the stock.'
      },
      fcfYield: {
        label: 'Free Cash Flow Yield',
        plain: 'Cash generation as % of market value. >8% = excellent, 5-8% = good, 2-5% = fair.',
        analogy: '6% yield = $6 cash per $100 market value. Cash is harder to manipulate than earnings.'
      },
      epsGrowth: {
        label: 'EPS Growth',
        plain: 'Earnings per share growth rate. >20% = excellent, 10-20% = strong, 5-10% = moderate.',
        analogy: '$2 to $2.50 EPS = 25% growth. Indicates growing profitability per share.'
      },
      priceToBook: {
        label: 'P/B Ratio',
        plain: 'Price-to-Book: Stock price vs. book value per share. <1 = potentially undervalued, 1-3 = fair, >3 = premium.',
        analogy: 'Like buying a house for $200K when its assessed value is $150K (P/B = 1.33).'
      },
      priceToSales: {
        label: 'P/S Ratio',
        plain: 'Price-to-Sales: Market cap vs. annual revenue. <1 = cheap, 1-3 = reasonable, >5 = expensive.',
        analogy: 'Like valuing a store at $1M when it makes $500K in sales per year (P/S = 2).'
      },
      netIncomeGrowth: {
        label: 'Net Income Growth',
        plain: 'Year-over-year profit growth. >20% = excellent, 10-20% = strong, <0% = declining.',
        analogy: 'Like a business that made $100K profit last year and $130K this year â€” 30% growth.'
      },
      roa: {
        label: 'ROA (Return on Assets)',
        plain: 'Profit generated from total assets. >10% = excellent, 5-10% = good, <5% = weak.',
        analogy: 'Like a factory that generates $1.10 profit for every $1 of equipment it owns.'
      },
      operatingMargin: {
        label: 'Operating Margin',
        plain: 'Operating profit as % of revenue. >20% = excellent, 10-20% = good, <10% = tight.',
        analogy: 'If revenue is $100 and operating profit is $15, operating margin is 15%.'
      },
      quickRatio: {
        label: 'Quick Ratio',
        plain: 'Liquidity measure: (Cash + Receivables) / Current Liabilities. >1 = healthy, <1 = may struggle to pay short-term debts.',
        analogy: 'Like having $150K in cash/receivables to cover $100K in bills due soon (ratio = 1.5).'
      },
      currentRatio: {
        label: 'Current Ratio',
        plain: 'Current assets / Current liabilities. >2 = very safe, 1-2 = adequate, <1 = liquidity risk.',
        analogy: 'Like having $200K in liquid assets to cover $100K in short-term debts (ratio = 2.0).'
      }
    };

    // Reusable "Explain This" tooltip component
    function ExplainMetric({ metricKey, stock }) {
      const [isOpen, setIsOpen] = useState(false);
      const exp = FINANCIAL_EXPLANATIONS[metricKey];

      if (!exp) return null;

      // Generate stock-specific context
      let context = "";
      const value = stock[metricKey];

      if (metricKey === 'roe' && value != null) {
        if (value > 30) context = `${stock.symbol}'s ROE is ${value.toFixed(1)}% â€” extremely high, indicating strong profitability.`;
        else if (value > 15) context = `${stock.symbol}'s ROE is ${value.toFixed(1)}% â€” solid profitability.`;
        else context = `${stock.symbol}'s ROE is ${value.toFixed(1)}% â€” below average for its sector.`;
      }

      if (metricKey === 'pe' && value != null) {
        if (value < 15) context = `${stock.symbol}'s P/E of ${value.toFixed(1)} suggests it may be undervalued.`;
        else if (value > 30) context = `${stock.symbol}'s P/E of ${value.toFixed(1)} indicates premium pricing or high growth expectations.`;
        else context = `${stock.symbol}'s P/E of ${value.toFixed(1)} is in a reasonable range.`;
      }

      if (metricKey === 'rsi' && value != null) {
        if (value < 30) context = `${stock.symbol}'s RSI of ${value.toFixed(0)} suggests potential buying opportunity (oversold).`;
        else if (value > 70) context = `${stock.symbol}'s RSI of ${value.toFixed(0)} warns of potential pullback (overbought).`;
        else context = `${stock.symbol}'s RSI of ${value.toFixed(0)} is in neutral territory.`;
      }

      if (metricKey === 'piotroskiScore' && value != null) {
        if (value >= 7) context = `${stock.symbol}'s Piotroski Score of ${value}/9 indicates strong financial health.`;
        else if (value >= 4) context = `${stock.symbol}'s Piotroski Score of ${value}/9 shows moderate financial health.`;
        else context = `${stock.symbol}'s Piotroski Score of ${value}/9 suggests weak financial health.`;
      }

      return (
        <div className="relative inline-block ml-1">
          <button
            onClick={() => setIsOpen(!isOpen)}
            className="text-xs text-slate-400 hover:text-cyan-400 font-bold transition"
            aria-label={`Explain ${exp.label}`}
          >
            ?
          </button>

          {isOpen && (
            <>
              <div className="fixed inset-0 z-40" onClick={() => setIsOpen(false)}></div>
              <div className="absolute z-50 w-72 p-4 bg-slate-800 border border-cyan-500/30 rounded-lg shadow-2xl text-xs"
                style={{ top: '100%', left: '0', marginTop: '4px' }}
              >
                <div className="font-semibold text-cyan-300 mb-2 flex items-center justify-between">
                  <span>{exp.label}</span>
                  <button
                    onClick={() => setIsOpen(false)}
                    className="text-slate-400 hover:text-white"
                  >
                    âœ•
                  </button>
                </div>
                <div className="text-slate-300 mb-3 leading-relaxed">{exp.plain}</div>
                {context && <div className="text-white mb-3 p-2 bg-slate-700/50 rounded border border-slate-600/50 italic">"{context}"</div>}
                <div className="text-slate-400 leading-relaxed">ğŸ’¡ {exp.analogy}</div>
              </div>
            </>
          )}
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIMPLIFIED ANALYTICS FOR NON-EXPERTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Traffic Light System
    const getTrafficLight = (metric, value) => {
      if (value === null || value === undefined) return 'yellow';
      const rules = {
        pe: { green: v => v < 20, yellow: v => v < 30, red: v => v >= 30 },
        revenueGrowth: { green: v => v > 15, yellow: v => v > 5, red: v => v <= 5 },
        debtToEquity: { green: v => v < 0.5, yellow: v => v < 1.5, red: v => v >= 1.5 },
        roe: { green: v => v > 15, yellow: v => v > 10, red: v => v <= 10 },
        beta: { green: v => v < 1.0, yellow: v => v < 1.5, red: v => v >= 1.5 },
      };
      const rule = rules[metric];
      if (!rule) return 'yellow';
      if (rule.green(value)) return 'green';
      if (rule.yellow(value)) return 'yellow';
      return 'red';
    };

    // Plain English Summaries
    const getPlainEnglishSummary = (metric, value) => {
      if (value === null || value === undefined) return { text: 'No data available', detail: '' };
      const summaries = {
        pe: [
          { max: 15, text: 'ğŸ“‰ Bargain price', detail: 'Trading below historical average - potentially undervalued' },
          { max: 25, text: 'âœ… Fair price', detail: 'Reasonable valuation for current earnings' },
          { max: 35, text: 'âš ï¸ Premium price', detail: 'Expensive relative to earnings - needs strong growth to justify' },
          { max: Infinity, text: 'ğŸ”´ Very expensive', detail: 'High valuation - risky if growth slows' }
        ],
        revenueGrowth: [
          { max: 0, text: 'ğŸ“‰ Shrinking', detail: 'Revenue declining - market share loss or industry issues' },
          { max: 5, text: 'ğŸŒ Slow growth', detail: 'Minimal expansion - mature company or tough market' },
          { max: 15, text: 'âœ… Solid growth', detail: 'Healthy expansion rate - gaining market share' },
          { max: Infinity, text: 'ğŸš€ Rapid growth', detail: 'Fast expansion - verify sustainable' }
        ],
        debtToEquity: [
          { max: 0.5, text: 'ğŸ’ª Rock solid', detail: 'Very low debt - financially conservative' },
          { max: 1.0, text: 'âœ… Healthy balance', detail: 'Moderate debt levels - well managed' },
          { max: 2.0, text: 'âš ï¸ Elevated debt', detail: 'Higher debt - monitor closely in downturns' },
          { max: Infinity, text: 'ğŸ”´ High risk', detail: 'Heavy debt burden - vulnerable to rate changes' }
        ],
        roe: [
          { max: 10, text: 'ğŸ“‰ Weak returns', detail: 'Not generating much profit from equity' },
          { max: 15, text: 'â¡ï¸ Average', detail: 'Decent but not exceptional profitability' },
          { max: 20, text: 'âœ… Strong returns', detail: 'Excellent use of shareholder capital' },
          { max: Infinity, text: 'ğŸ† Elite returns', detail: 'Outstanding profitability - competitive advantage' }
        ],
        beta: [
          { max: 0.8, text: 'ğŸ›¡ï¸ Defensive', detail: 'Less volatile than market - safer in downturns' },
          { max: 1.2, text: 'â¡ï¸ Market-like', detail: 'Moves with the market - average risk' },
          { max: 1.8, text: 'âš¡ Volatile', detail: 'More dramatic swings than market' },
          { max: Infinity, text: 'ğŸ¢ Highly volatile', detail: 'Wild price swings - high risk/reward' }
        ]
      };
      const metricSummaries = summaries[metric];
      if (!metricSummaries) return { text: 'â€”', detail: '' };
      for (const summary of metricSummaries) {
        if (value <= summary.max) return summary;
      }
      return { text: 'â€”', detail: '' };
    };

    // Calculate Valuation Score
    const calculateValuationScore = (stock) => {
      let score = 50;
      if (stock.pe) {
        if (stock.pe < 15) score += 15;
        else if (stock.pe < 25) score += 5;
        else if (stock.pe > 35) score -= 15;
        else score -= 5;
      }
      if (stock.priceToBook) {
        if (stock.priceToBook < 1.5) score += 10;
        else if (stock.priceToBook < 3) score += 5;
        else score -= 10;
      }
      if (stock.fcfYield) {
        if (stock.fcfYield > 8) score += 10;
        else if (stock.fcfYield > 5) score += 5;
        else if (stock.fcfYield < 2) score -= 5;
      }
      if (stock.revenueGrowth && stock.revenueGrowth > 20) score += 10;
      return Math.max(0, Math.min(100, score));
    };

    // Get valuation label
    const getValuationLabel = (score) => {
      if (score < 35) return { label: 'Undervalued', color: '#22c55e', emoji: 'ğŸ’°' };
      if (score < 65) return { label: 'Fair Value', color: '#eab308', emoji: 'âš–ï¸' };
      return { label: 'Overvalued', color: '#ef4444', emoji: 'âš ï¸' };
    };

    // LoadingProgressBar Component for Incremental Loading
    function LoadingProgressBar({ current, total }) {
      const percentage = total > 0 ? (current / total) * 100 : 0;

      return (
        <div className="w-full h-2 bg-slate-700 rounded-full overflow-hidden mb-4">
          <div
            className="h-full bg-gradient-to-r from-cyan-500 to-green-500 transition-all duration-300"
            style={{ width: `${percentage}%` }}
          ></div>
          <div className="text-xs text-slate-400 mt-1 text-center">
            {current} of {total} stocks loaded ({percentage.toFixed(1)}%)
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FUNDAMENTALS TAB COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function FundamentalsTab({ stock }) {
      // === DEFENSIVE CHECKS - PREVENT CRASH ===
      if (!stock) {
        return (
          <div className="glass-card p-8 rounded-xl text-center">
            <i className="fas fa-exclamation-triangle text-4xl text-red-400 mb-3"></i>
            <h3 className="text-xl font-bold text-white mb-2">Data Unavailable</h3>
            <p className="text-slate-400 mb-4">No stock data was provided to the Fundamentals tab.</p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 text-white rounded-lg font-semibold"
            >
              Reload Application
            </button>
          </div>
        );
      }

      // Safely access ALL nested properties
      const safeAccess = (obj, path, fallback = null) => {
        try {
          const parts = path.split('.');
          let current = obj;
          for (const part of parts) {
            if (!current || current[part] === undefined) return fallback;
            current = current[part];
          }
          return current;
        } catch {
          return fallback;
        }
      };

      // Safe property extraction
      const symbol = stock.symbol || 'Unknown';
      const name = stock.name || stock.companyName || symbol;
      const price = Number(stock.price || 0);
      const pe = Number(stock.pe || 0);
      const roe = Number(stock.roe || 0);
      const marketCap = Number(stock.marketCap || 0);
      const volume = Number(stock.volume || 0);

      // AI Analysis with fallbacks
      const aiScore = safeAccess(stock, 'aiAnalysis.score', stock.aiScore || 0);
      const aiVerdict = safeAccess(stock, 'aiAnalysis.verdict', stock.verdict || 'HOLD');
      const confidence = safeAccess(stock, 'aiAnalysis.confidence', stock.confidence || 50);

      // Analyst rating with deep fallback
      const analystRating = safeAccess(stock, 'aiAnalysis.analystRating.detail',
        stock.analystRating?.detail ||
        stock.analystRating ||
        'No analyst rating available'
      );

      return (
        <div className="space-y-6 animate-slideInLeft">
          {/* Header Card */}
          <div className="glass-card p-6 rounded-xl">
            <div className="flex items-center justify-between mb-4">
              <div>
                <h3 className="text-2xl font-bold text-white">{symbol}</h3>
                <p className="text-slate-400">{name}</p>
              </div>
              <div className="text-right">
                <div className="text-3xl font-bold text-white">${price.toFixed(2)}</div>
                <div className={`text-sm ${stock.changePct > 0 ? 'text-green-400' : 'text-red-400'}`}>
                  {stock.changePct > 0 ? '+' : ''}{(stock.changePct || 0).toFixed(2)}%
                </div>
              </div>
            </div>
          </div>

          {/* AI Score Card */}
          <div className="glass-card p-4 rounded-xl border-2 border-cyan-500/30">
            <h4 className="text-lg font-semibold text-cyan-300 mb-3">AI Analysis</h4>
            <div className="grid grid-cols-3 gap-4 mb-3">
              <div className="text-center">
                <div className={`text-2xl font-bold ${aiScore >= 80 ? 'text-green-400' :
                  aiScore >= 60 ? 'text-yellow-400' :
                    'text-red-400'
                  }`}>
                  {aiScore}/100
                </div>
                <div className="text-xs text-slate-400">AI Score</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-400">
                  {confidence}%
                </div>
                <div className="text-xs text-slate-400">Confidence</div>
              </div>
              <div className="text-center">
                <span className={`px-3 py-1 rounded-full text-sm font-bold ${aiVerdict === 'STRONG BUY' ? 'bg-green-500/20 text-green-400' :
                  aiVerdict === 'BUY' ? 'bg-green-500/10 text-green-300' :
                    aiVerdict === 'SELL' ? 'bg-red-500/20 text-red-400' :
                      'bg-yellow-500/10 text-yellow-300'
                  }`}>
                  {aiVerdict}
                </span>
              </div>
            </div>
          </div>

          {/* Key Metrics */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <MetricCard
              label="P/E Ratio"
              value={pe > 0 ? pe.toFixed(1) : 'N/A'}
              color={pe > 0 && pe < 15 ? 'text-green-400' : pe > 30 ? 'text-red-400' : 'text-slate-300'}
            />
            <MetricCard
              label="ROE"
              value={`${roe.toFixed(1)}%`}
              color={roe > 20 ? 'text-green-400' : roe < 10 ? 'text-red-400' : 'text-slate-300'}
            />
            <MetricCard
              label="Market Cap"
              value={`$${formatNumber(marketCap)}`}
            />
            <MetricCard
              label="Volume"
              value={formatNumber(volume)}
            />
          </div>

          {/* Analyst Rating */}
          <div className="glass-card p-4 rounded-xl">
            <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
              <i className="fas fa-chart-line text-blue-400"></i>
              Analyst Rating
            </h4>
            <p className="text-slate-300 leading-relaxed">
              {typeof analystRating === 'string' ? analystRating : JSON.stringify(analystRating)}
            </p>
          </div>

          {/* Top Factors */}
          {stock.topDrivers && (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="glass-card p-4 rounded-xl border-green-500/30">
                <h4 className="text-md font-semibold text-green-400 mb-2 flex items-center gap-2">
                  <i className="fas fa-thumbs-up"></i>
                  Bullish Factors
                </h4>
                <ul className="space-y-1">
                  {(stock.topDrivers.positive || []).slice(0, 3).map((item, i) => (
                    <li key={i} className="text-sm text-slate-300 flex items-start gap-2">
                      <span className="text-green-400 mt-1">â€¢</span>
                      <span>{item.factor}</span>
                    </li>
                  ))}
                </ul>
              </div>

              <div className="glass-card p-4 rounded-xl border-red-500/30">
                <h4 className="text-md font-semibold text-red-400 mb-2 flex items-center gap-2">
                  <i className="fas fa-thumbs-down"></i>
                  Bearish Factors
                </h4>
                <ul className="space-y-1">
                  {(stock.topDrivers.negative || []).slice(0, 3).map((item, i) => (
                    <li key={i} className="text-sm text-slate-300 flex items-start gap-2">
                      <span className="text-red-400 mt-1">â€¢</span>
                      <span>{item.factor}</span>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          )}

          {/* Watchlist Guidance */}
          {stock.watchlistGuidance && (
            <div className="glass-card p-4 rounded-xl border-cyan-500/30">
              <h4 className="text-md font-semibold text-cyan-300 mb-3 flex items-center gap-2">
                <i className="fas fa-info-circle"></i>
                What to Watch Next
              </h4>
              <div className="space-y-2">
                {stock.watchlistGuidance.items.map((item, i) => (
                  <div key={i} className="flex items-center justify-between text-sm">
                    <span className="text-slate-400">{item.label}:</span>
                    <span className="text-slate-300">{item.value}</span>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      );
    }

    // Helper component for metrics
    function MetricCard({ label, value, color }) {
      return (
        <div className="glass-card p-4 rounded-xl text-center hover:border-cyan-500/30 transition">
          <div className="text-xs text-slate-400 mb-1">{label}</div>
          <div className={`text-xl font-bold ${color || 'text-white'}`}>{value}</div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PATTERN CARD COMPONENT (extracted to fix hooks violation)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function PatternCard({ pattern, stock, historicalData }) {
      const [showAIAnalysis, setShowAIAnalysis] = useState(false);
      const [aiAnalysis, setAiAnalysis] = useState(null);
      const [analyzing, setAnalyzing] = useState(false);

      const analyzePattern = async () => {
        setAnalyzing(true);
        try {
          const analysis = await generatePatternAnalysis(pattern, stock, historicalData);
          setAiAnalysis(analysis);
          setShowAIAnalysis(true);
        } catch (err) {
          console.error('Pattern analysis error:', err);
          setAiAnalysis(generateFallbackAnalysis(pattern));
          setShowAIAnalysis(true);
        } finally {
          setAnalyzing(false);
        }
      };

      return (
        <div className="glass-card p-5 rounded-xl border border-cyan-500/20">
          <div className="flex items-start justify-between mb-3">
            <div>
              <h4 className="text-lg font-bold text-white">{pattern.pattern.name}</h4>
              <p className="text-sm text-slate-400 mt-1">{pattern.pattern.description}</p>
            </div>
            <div className="text-right">
              <div className={`text-2xl font-bold ${pattern.confidence > 0.75 ? 'text-green-400' : pattern.confidence > 0.65 ? 'text-yellow-400' : 'text-orange-400'}`}>
                {(pattern.confidence * 100).toFixed(0)}%
              </div>
              <div className="text-xs text-slate-500">Confidence</div>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4 mt-4">
            <div>
              <div className="text-xs text-slate-500 mb-1">Type</div>
              <div className={`text-sm font-semibold ${pattern.pattern.type === 'reversal' ? 'text-red-400' : 'text-green-400'}`}>
                {pattern.pattern.type === 'reversal' ? 'Reversal' : 'Continuation'}
              </div>
            </div>
            <div>
              <div className="text-xs text-slate-500 mb-1">Reliability</div>
              <div className="text-sm font-semibold text-cyan-400">
                {(pattern.pattern.reliability * 100).toFixed(0)}%
              </div>
            </div>
            {pattern.targetPrice && (
              <div>
                <div className="text-xs text-slate-500 mb-1">Target Price</div>
                <div className="text-sm font-semibold text-white">${pattern.targetPrice.toFixed(2)}</div>
              </div>
            )}
            <div>
              <div className="text-xs text-slate-500 mb-1">Implications</div>
              <div className={`text-sm font-semibold ${pattern.implications?.includes('Bullish') ? 'text-green-400' : pattern.implications?.includes('Bearish') ? 'text-red-400' : 'text-slate-400'}`}>
                {pattern.implications || 'Neutral'}
              </div>
            </div>
          </div>

          <div className="mt-4 pt-4 border-t border-slate-700/30">
            {!showAIAnalysis ? (
              <button
                onClick={analyzePattern}
                disabled={analyzing}
                className="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-slate-600 disabled:cursor-not-allowed text-white rounded-lg font-semibold text-sm flex items-center justify-center gap-2"
              >
                {analyzing ? (
                  <>
                    <div className="inline-block animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                    <span>AI Analyzing Pattern...</span>
                  </>
                ) : (
                  <>
                    <span>ğŸ¤–</span>
                    <span>Get AI Analysis</span>
                  </>
                )}
              </button>
            ) : aiAnalysis && (
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-bold text-purple-400">ğŸ¤– AI Analysis</span>
                  <button onClick={() => setShowAIAnalysis(false)} className="text-xs text-slate-500 hover:text-slate-400">Hide</button>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-xs text-slate-500 mb-1">Trading Signal</div>
                  <div className={`text-lg font-bold ${aiAnalysis.signal === 'BUY' ? 'text-green-400' : aiAnalysis.signal === 'SELL' ? 'text-red-400' : 'text-yellow-400'}`}>
                    {aiAnalysis.signal}
                  </div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-xs text-slate-500 mb-2">Recommended Strategy</div>
                  <div className="text-sm text-slate-300">{aiAnalysis.strategy}</div>
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-2">
                    <div className="text-xs text-green-400 mb-1">Entry Point</div>
                    <div className="text-sm font-bold text-white">${aiAnalysis.entryPoint?.toFixed(2)}</div>
                  </div>
                  <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-2">
                    <div className="text-xs text-red-400 mb-1">Stop Loss</div>
                    <div className="text-sm font-bold text-white">${aiAnalysis.stopLoss?.toFixed(2)}</div>
                  </div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-xs text-slate-500">Risk Level</span>
                    <span className={`text-sm font-bold ${aiAnalysis.riskLevel === 'Low' ? 'text-green-400' : aiAnalysis.riskLevel === 'Medium' ? 'text-yellow-400' : 'text-red-400'}`}>
                      {aiAnalysis.riskLevel}
                    </span>
                  </div>
                  <div className="text-xs text-slate-400">{aiAnalysis.riskNote}</div>
                </div>
                {aiAnalysis.keyFactors && (
                  <div className="bg-slate-800/50 rounded-lg p-3">
                    <div className="text-xs text-slate-500 mb-2">Key Factors</div>
                    <ul className="space-y-1">
                      {aiAnalysis.keyFactors.map((factor, i) => (
                        <li key={i} className="text-xs text-slate-300 flex items-start gap-2">
                          <span className="text-purple-400">â€¢</span>
                          <span>{factor}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                <div className="bg-purple-500/10 border border-purple-500/20 rounded-lg p-3">
                  <div className="text-xs text-slate-400 leading-relaxed">{aiAnalysis.summary}</div>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STOCK MODAL COMPONENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function StockModal({ stock, onClose, watchlist, toggleWatchlist, detailedDataLoading, sectorAverages, portfolio, stocks, setShowWatchlistOnly, openStockModal }) {
      const [activeTab, setActiveTab] = useState('overview');
      const [showAllFactors, setShowAllFactors] = useState(false);
      const [showExplainScore, setShowExplainScore] = useState(false);
      const [insiderData, setInsiderData] = useState(null);
      const [analystEstimates, setAnalystEstimates] = useState(null);
      const [incomeStatement, setIncomeStatement] = useState(null);
      const [newsData, setNewsData] = useState([]);
      const [newsSentiment, setNewsSentiment] = useState(null);
      const [newsLoading, setNewsLoading] = useState(false);
      const [socialSentiment, setSocialSentiment] = useState(null);
      const [socialLoading, setSocialLoading] = useState(false);
      const [historicalData, setHistoricalData] = useState(null);
      const [historicalMeta, setHistoricalMeta] = useState({ symbol: null, timeframe: null });
      const [chartTimeframe, setChartTimeframe] = useState('4hour');
      const [comparisonSymbol, setComparisonSymbol] = useState('');
      const [comparisonData, setComparisonData] = useState(null);
      const [comparisonMeta, setComparisonMeta] = useState({ symbol: null, timeframe: null });
      const [comparisonLoading, setComparisonLoading] = useState(false);
      const [loadingTabData, setLoadingTabData] = useState(false);
      const [technicalData, setTechnicalData] = useState(null);
      const [ratingsData, setRatingsData] = useState(null);
      const [analystRatingsData, setAnalystRatingsData] = useState(null);
      const [error, setError] = useState(null);
      const [deepseekAnalysis, setDeepseekAnalysis] = useState(null);
      const [aiLoading, setAiLoading] = useState(false);
      const [deepseekLoading, setDeepseekLoading] = useState(false);
      const [fundamentalsData, setFundamentalsData] = useState(null);

      // Real-time price tracking
      const [livePrice, setLivePrice] = useState(stock.price);
      const [liveChange, setLiveChange] = useState(stock.change);
      const [liveChangePct, setLiveChangePct] = useState(stock.changePct);
      const [priceHistory, setPriceHistory] = useState([]);
      const [isLiveUpdating, setIsLiveUpdating] = useState(false);

      const isWatchlisted = watchlist && Array.isArray(watchlist) && watchlist.some(s => s && s.toUpperCase() === stock.symbol.toUpperCase());
      const sectorAvg = sectorAverages[stock.sector] || {};

      const explainNow = useMemo(() => explainDeterministicAIScore(stock), [
        stock.symbol,
        stock.pe,
        stock.roe,
        stock.rsi,
        stock.changePct,
        stock.marketCap
      ]);

      // Subscribe to real-time updates for this stock
      useEffect(() => {
        const handleUpdate = (update) => {
          setLivePrice(update.price);
          setLiveChange(update.change);
          setLiveChangePct(update.changesPercentage || (update.change && update.price ? (update.change / update.price * 100) : 0));
          setIsLiveUpdating(true);

          // Add to price history for mini chart
          setPriceHistory(prev => {
            const newHistory = [...prev, { time: Date.now(), price: update.price }];
            // Keep last 50 data points
            return newHistory.slice(-50);
          });

          // Reset live indicator after 1 second
          setTimeout(() => setIsLiveUpdating(false), 1000);
        };

        // Subscribe based on connection status
        if (realtimeData.isConnected) {
          realtimeData.subscribe(stock.symbol, handleUpdate);
        } else {
          smartPoller.startPolling(stock.symbol, handleUpdate);
        }

        return () => {
          realtimeData.unsubscribe(stock.symbol, handleUpdate);
          smartPoller.stopPolling(stock.symbol);
        };
      }, [stock.symbol]);

      const explainThresholds = useMemo(() => aiExplainThresholds(num(stock.aiScore, 0)), [stock.aiScore]);

      const sensitivity = useMemo(() => aiSensitivitySuggestions(stock), [
        stock.symbol,
        stock.pe,
        stock.roe,
        stock.rsi,
        stock.changePct,
        stock.marketCap
      ]);

      const prevSnapshotEntry = useMemo(() => {
        try {
          const raw = localStorage.getItem(Cache.key(stock.symbol, 'stock_prev'));
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (!parsed || !parsed.data) return null;
          return parsed;
        } catch {
          return null;
        }
      }, [stock.symbol]);

      const prevAnalysis = useMemo(() => {
        if (!prevSnapshotEntry?.data) return null;
        try {
          return generateAIAnalysis(prevSnapshotEntry.data);
        } catch {
          return null;
        }
      }, [stock.symbol, prevSnapshotEntry?.timestamp]);

      // Lazy load tab data when clicked


      // Track previous stock to detect changes
      const prevStockRef = useRef(null);

      useEffect(() => {
        console.log(`ğŸ” useEffect triggered - activeTab: ${activeTab}, stock: ${stock.symbol}`);

        const loadTabData = async () => {
          // Check if stock changed
          const stockChanged = prevStockRef.current && prevStockRef.current !== stock.symbol;

          console.log(`ğŸ“Œ Stock check: prevStock=${prevStockRef.current}, currentStock=${stock.symbol}, changed=${stockChanged}`);

          // Update ref for next check
          if (!prevStockRef.current) {
            prevStockRef.current = stock.symbol;
            console.log(`ğŸ“ First load - set prevStockRef to ${stock.symbol}`);
          }

          if (stockChanged) {
            console.log(`ğŸ”„ Stock